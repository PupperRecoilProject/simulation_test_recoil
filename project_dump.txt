# å°ˆæ¡ˆç¨‹å¼ç¢¼å½™æ•´: C:\git_project\simulation_test_recoil
================================================================================

================================================================================
--- FILE: config.py ---
-----------------------

# config.py
import yaml
from dataclasses import dataclass, field
from typing import Dict, List, Any

@dataclass
class TuningParamsConfig:
    """å¾è¨­å®šæª”è¼‰å…¥çš„åˆå§‹èª¿æ ¡åƒæ•¸è³‡æ–™é¡åˆ¥ã€‚"""
    kp: float
    kd: float
    action_scale: float
    bias: float

@dataclass
class FloatingControllerConfig:
    """æ‡¸æµ®æ§åˆ¶å™¨çš„è¨­å®šã€‚"""
    target_height: float
    kp_vertical: float
    kd_vertical: float
    kp_attitude: float
    kd_attitude: float

@dataclass
class AppConfig:
    """å„²å­˜æ‰€æœ‰æ‡‰ç”¨ç¨‹å¼è¨­å®šçš„è³‡æ–™é¡åˆ¥ã€‚"""
    mujoco_model_file: str
    onnx_model_path: str
    num_motors: int
    physics_timestep: float
    control_freq: float
    control_dt: float
    warmup_duration: float
    command_scaling_factors: List[float]
    
    keyboard_velocity_adjust_step: float
    gamepad_sensitivity: Dict[str, float]
    param_adjust_steps: Dict[str, float]

    initial_tuning_params: TuningParamsConfig
    observation_recipes: Dict[int, List[str]]
    floating_controller: FloatingControllerConfig

def load_config(path: str = "config.yaml") -> AppConfig:
    """
    å¾ YAML æª”æ¡ˆè¼‰å…¥è¨­å®šä¸¦å›å‚³ä¸€å€‹ AppConfig ç‰©ä»¶ã€‚
    """
    try:
        with open(path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"è¨­å®šæª” '{path}' ä¸å­˜åœ¨ã€‚è«‹ç¢ºä¿æª”æ¡ˆè·¯å¾‘æ­£ç¢ºã€‚")
    except Exception as e:
        raise IOError(f"è®€å–æˆ–è§£æè¨­å®šæª” '{path}' æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

    tuning_params = TuningParamsConfig(**config_data['initial_tuning_params'])
    floating_config = FloatingControllerConfig(**config_data['floating_controller'])
    
    config_obj = AppConfig(
        mujoco_model_file=config_data['mujoco_model_file'],
        onnx_model_path=config_data['onnx_model_path'],
        num_motors=config_data['num_motors'],
        physics_timestep=config_data['physics_timestep'],
        control_freq=config_data['control_freq'],
        control_dt=1.0 / config_data['control_freq'],
        warmup_duration=config_data['warmup_duration'],
        command_scaling_factors=config_data['command_scaling_factors'],
        
        keyboard_velocity_adjust_step=config_data['keyboard_velocity_adjust_step'],
        gamepad_sensitivity=config_data['gamepad_sensitivity'],
        param_adjust_steps=config_data['param_adjust_steps'],
        
        initial_tuning_params=tuning_params,
        observation_recipes=config_data['observation_recipes'],
        floating_controller=floating_config
    )
    
    print("âœ… è¨­å®šæª”è¼‰å…¥æˆåŠŸ (åŒ…å«æ‡¸æµ®æ§åˆ¶å™¨è¨­å®š)ã€‚")
    return config_obj

================================================================================
--- FILE: config.yaml ---
-------------------------

# ==================================
# === æ¨¡æ“¬èˆ‡æ¨¡å‹è¨­å®š (Simulation & Model Settings)
# ==================================
# æª”æ¡ˆè·¯å¾‘ (File Paths)
mujoco_model_file: "assets/scene_mjx.xml"
onnx_model_path: "models/pupper_ppo_policy_30965760_tf_converted_ç©©å®šæ­¥æ…‹ç‰ˆ.onnx"

# æ ¸å¿ƒåƒæ•¸ (Core Parameters)
num_motors: 12
physics_timestep: 0.004 # <-- å»ºè­°ä¿®æ”¹ï¼šæé«˜æ¨¡æ“¬ç²¾åº¦ä»¥å¢å¼·ç©©å®šæ€§
control_freq: 50.0
warmup_duration: 0.0

# ONNX æ¨¡å‹å‘½ä»¤è¼¸å…¥ç¸®æ”¾å› å­
# é †åº: [vy ç¸®æ”¾, vx ç¸®æ”¾, wz ç¸®æ”¾]
command_scaling_factors: [1.0, 1.0, 1.0] 

# ==================================
# === è¼¸å…¥æ§åˆ¶è¨­å®š (Input Control Settings)
# ==================================
keyboard_velocity_adjust_step: 0.1 # m/s or rad/s per key press

gamepad_sensitivity:
  vx: 1.0   # å‰å¾Œé€Ÿåº¦éˆæ•åº¦ (å·¦æ–æ¡¿ Y)
  vy: 1.0   # å·¦å³é€Ÿåº¦éˆæ•åº¦ (å·¦æ–æ¡¿ X)
  wz: -1.5  # è½‰å‘è§’é€Ÿåº¦éˆæ•åº¦ (å³æ–æ¡¿ X), è² å€¼è¡¨ç¤ºå³æ¨å³è½‰

param_adjust_steps:
  kp: 0.5
  kd: 0.05
  action_scale: 0.05
  bias: 5

# ==================================
# === åˆå§‹èª¿æ ¡åƒæ•¸ (Initial Tuning Parameters)
# ==================================
initial_tuning_params:
  kp: 4.0
  kd: 0.40
  action_scale: 0.5
  bias: -0.0

# ==================================
# === è§€å¯Ÿé…æ–¹ (Observation Recipes)
# ==================================
observation_recipes:
  31:
    - 'z_angular_velocity'
    - 'gravity_vector'
    - 'commands'
    - 'joint_positions'
    - 'last_action'
  48: # <-- ä¿®æ”¹é€™å€‹ 48 ç¶­çš„é †åº
    - 'linear_velocity'
    - 'angular_velocity'
    - 'gravity_vector'
    - 'joint_positions'
    - 'joint_velocities'
    - 'last_action'
    - 'commands' # <-- å°‡ commands ç§»å‹•åˆ°æœ€å¾Œ

# ================================================================= #
# === æ‡¸æµ®æ§åˆ¶å™¨è¨­å®š (Floating Controller Settings) - ç²¾ç´°èª¿æ ¡ç‰ˆ ===
# ================================================================= #
floating_controller:
  target_height: 0.50     # æ‡¸æµ®çš„ç›®æ¨™é«˜åº¦ (ç±³)
  kp_vertical: 80.0       # å‚ç›´ P (å†æ¬¡é™ä½ä»¥æ±‚å¹³æ»‘)
  kd_vertical: 18.0       # å‚ç›´ D (ä¿æŒèˆ‡Kpçš„é—œä¿‚)
  kp_attitude: 20.0       # å§¿æ…‹ P (å†æ¬¡é™ä½)
  kd_attitude: 4.0        # å§¿æ…‹ D (ç›¸æ‡‰èª¿æ•´)

================================================================================
--- FILE: floating_controller.py ---
------------------------------------

# floating_controller.py
import mujoco
import numpy as np
from config import AppConfig

class FloatingController:
    """
    é€éå•Ÿç”¨/ç¦ç”¨ weld ç´„æŸå’Œè¨­å®š mocap body çš„ä½ç½®ï¼Œ
    ä¾†å°‡æ©Ÿå™¨äººä¸»å¹¹å›ºå®šåœ¨ç©ºä¸­ã€‚
    """
    def __init__(self, config: AppConfig, model, data):
        """
        åˆå§‹åŒ–æ‡¸æµ®æ§åˆ¶å™¨ï¼Œä¸¦ç²å–å¿…è¦çš„ MuJoCo ID å’Œç´¢å¼•ã€‚
        """
        self.config = config.floating_controller
        self.model = model
        self.data = data
        self.is_functional = False
        
        try:
            anchor_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, 'anchor')
            if anchor_body_id == -1: raise ValueError("åœ¨ XML ä¸­æ‰¾ä¸åˆ°åç‚º 'anchor' çš„ bodyã€‚")
            
            self.mocap_index = model.body_mocapid[anchor_body_id]
            if self.mocap_index == -1: raise ValueError("'anchor' body ä¸æ˜¯ä¸€å€‹ mocap bodyã€‚")

            self.weld_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_EQUALITY, 'torso_anchor_weld')
            if self.weld_id == -1: raise ValueError("åœ¨ XML ä¸­æ‰¾ä¸åˆ°åç‚º 'torso_anchor_weld' çš„ weld ç´„æŸã€‚")

            self.is_functional = True
            print(f"âœ… å›ºå®šå¼æ‡¸æµ®æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆã€‚Mocap Index: {self.mocap_index}")
        except ValueError as e:
            print(f"âŒ æ‡¸æµ®æ§åˆ¶å™¨åˆå§‹åŒ–éŒ¯èª¤: {e}")
            print("     è«‹ç¢ºä¿ scene_mjx.xml æª”æ¡ˆå·²æ­£ç¢ºå®šç¾© 'anchor' body å’Œ 'torso_anchor_weld' ç´„æŸã€‚æ‡¸æµ®åŠŸèƒ½å°‡è¢«ç¦ç”¨ã€‚")

    def enable(self, current_pos: np.ndarray):
        """å•Ÿç”¨æ‡¸æµ®æ¨¡å¼ã€‚"""
        if not self.is_functional: return
        
        target_pos = np.array([current_pos[0], current_pos[1], self.config.target_height])
        self.data.mocap_pos[self.mocap_index] = target_pos
        self.data.mocap_quat[self.mocap_index] = np.array([1., 0, 0, 0]) # ä¿æŒæ°´å¹³å§¿æ…‹
        self.data.eq_active[self.weld_id] = 1
        print("ğŸš€ å·²å•Ÿç”¨å›ºå®šæ‡¸æµ®æ¨¡å¼ã€‚")

    def disable(self):
        """ç¦ç”¨æ‡¸æµ®æ¨¡å¼ã€‚"""
        if not self.is_functional: return
        self.data.eq_active[self.weld_id] = 0
        print("ğŸ¾ å·²ç¦ç”¨å›ºå®šæ‡¸æµ®æ¨¡å¼ã€‚")

================================================================================
--- FILE: keyboard_input_handler.py ---
---------------------------------------

# keyboard_input_handler.py
import glfw
from state import SimulationState

class KeyboardInputHandler:
    """
    è™•ç†æ‰€æœ‰éµç›¤è¼¸å…¥äº‹ä»¶ï¼Œä¸¦æ ¹æ“šç•¶å‰æ¨¡å¼é€²è¡Œåˆ†æ´¾ã€‚
    """
    # ã€ä¿®æ”¹ã€‘æ¥æ”¶ terrain_manager
    def __init__(self, state: SimulationState, serial_comm, xbox_handler, terrain_manager):
        self.state = state
        self.config = state.config
        self.serial_comm = serial_comm
        self.xbox_handler = xbox_handler
        self.terrain_manager = terrain_manager # <-- ã€æ–°å¢ã€‘
        self.param_keys = ['kp', 'kd', 'action_scale', 'bias']
        self.num_params = len(self.param_keys)

    def register_callbacks(self, window):
        glfw.set_key_callback(window, self.key_callback)
        glfw.set_char_callback(window, self.char_callback)

    def char_callback(self, window, codepoint):
        if self.state.control_mode == "SERIAL_MODE":
            self.state.serial_command_buffer += chr(codepoint)

    def key_callback(self, window, key, scancode, action, mods):
        # --- 1. åªåœ¨æŒ‰éµæŒ‰ä¸‹æ™‚è§¸ç™¼çš„é€šç”¨åŠŸèƒ½ (æ¨¡å¼åˆ‡æ›ã€é‡ç½®ç­‰) ---
        if action == glfw.PRESS:
            if key == glfw.KEY_SPACE: self.state.single_step_mode = not self.state.single_step_mode; print(f"\n--- SIMULATION {'PAUSED' if self.state.single_step_mode else 'PLAYING'} ---"); return
            if self.state.single_step_mode and key == glfw.KEY_N: self.state.execute_one_step = True; return
            if key == glfw.KEY_ESCAPE: glfw.set_window_should_close(window, 1); return
            if key == glfw.KEY_R: self.state.hard_reset_requested = True; return
            if key == glfw.KEY_X: self.state.soft_reset_requested = True; return
            if key == glfw.KEY_TAB: self.state.display_page = (self.state.display_page + 1) % self.state.num_display_pages; return
            if key == glfw.KEY_M: self.state.toggle_input_mode("GAMEPAD" if self.state.input_mode == "KEYBOARD" else "KEYBOARD"); return
            # ã€æ–°å¢ã€‘V éµåˆ‡æ›åœ°å½¢
            if key == glfw.KEY_V: 
                self.terrain_manager.cycle_terrain()
                return
            
            # è¨­å‚™æƒæ
            if key == glfw.KEY_U: self.state.serial_is_connected = self.serial_comm.scan_and_connect(); return
            if key == glfw.KEY_J: self.state.gamepad_is_connected = self.xbox_handler.scan_and_connect(); return

        # --- 2. å¯é‡è¤‡è§¸ç™¼çš„æ¨¡å¼ç‰¹å®šåŠŸèƒ½ ---
        # é€™æ˜¯æœ€é—œéµçš„ä¿®æ”¹ï¼šå„ªå…ˆè™•ç†ç‰¹å®šæ¨¡å¼çš„æŒ‰éµï¼Œå¦‚æœè™•ç†äº†å°± return
        if action in [glfw.PRESS, glfw.REPEAT]:
            if self.state.control_mode == "SERIAL_MODE":
                if key == glfw.KEY_ENTER: self.state.serial_command_to_send = self.state.serial_command_buffer; self.state.serial_command_buffer = ""
                elif key == glfw.KEY_BACKSPACE: self.state.serial_command_buffer = self.state.serial_command_buffer[:-1]
                elif key == glfw.KEY_T and action == glfw.PRESS: self.state.set_control_mode("WALKING")
                return

            if self.state.control_mode == "JOINT_TEST":
                if key == glfw.KEY_LEFT_BRACKET and action == glfw.PRESS: self.state.joint_test_index = (self.state.joint_test_index - 1) % 12
                elif key == glfw.KEY_RIGHT_BRACKET and action == glfw.PRESS: self.state.joint_test_index = (self.state.joint_test_index + 1) % 12
                elif key == glfw.KEY_UP: self.state.joint_test_offsets[self.state.joint_test_index] += 0.1
                elif key == glfw.KEY_DOWN: self.state.joint_test_offsets[self.state.joint_test_index] -= 0.1
                elif key == glfw.KEY_C and action == glfw.PRESS: self.state.joint_test_offsets.fill(0.0)
                elif key == glfw.KEY_G and action == glfw.PRESS: self.state.set_control_mode("WALKING")
                return

            if self.state.control_mode == "MANUAL_CTRL":
                if key == glfw.KEY_F and action == glfw.PRESS:
                    self.state.manual_mode_is_floating = not self.state.manual_mode_is_floating
                    is_floating = self.state.manual_mode_is_floating
                    if is_floating:
                        if self.state.floating_controller_ref: self.state.floating_controller_ref.enable(self.state.latest_pos)
                    else:
                        if self.state.floating_controller_ref: self.state.floating_controller_ref.disable()
                elif key == glfw.KEY_LEFT_BRACKET and action == glfw.PRESS: self.state.manual_ctrl_index = (self.state.manual_ctrl_index - 1) % 12
                elif key == glfw.KEY_RIGHT_BRACKET and action == glfw.PRESS: self.state.manual_ctrl_index = (self.state.manual_ctrl_index + 1) % 12
                elif key == glfw.KEY_UP: self.state.manual_final_ctrl[self.state.manual_ctrl_index] += 0.1
                elif key == glfw.KEY_DOWN: self.state.manual_final_ctrl[self.state.manual_ctrl_index] -= 0.1
                elif key == glfw.KEY_C and action == glfw.PRESS: self.state.manual_final_ctrl.fill(0.0)
                elif key == glfw.KEY_G and action == glfw.PRESS: self.state.set_control_mode("WALKING")
                return

        # --- 3. å¦‚æœä»¥ä¸Šæ¨¡å¼éƒ½ä¸æ˜¯ï¼Œå‰‡åŸ·è¡Œ WALKING/FLOATING æ¨¡å¼çš„é è¨­æŒ‰éµé‚è¼¯ ---
        if action == glfw.PRESS:
            if key == glfw.KEY_F: self.state.set_control_mode("FLOATING" if self.state.control_mode == "WALKING" else "WALKING"); return
            if key == glfw.KEY_T: self.state.set_control_mode("SERIAL_MODE"); return
            if key == glfw.KEY_G: self.state.set_control_mode("JOINT_TEST"); return
            if key == glfw.KEY_B: self.state.set_control_mode("MANUAL_CTRL"); return
        
        if self.state.input_mode != "KEYBOARD": return
            
        if action in [glfw.PRESS, glfw.REPEAT]:
            # åƒæ•¸èª¿æ•´
            if key == glfw.KEY_LEFT_BRACKET: self.state.tuning_param_index = (self.state.tuning_param_index - 1) % self.num_params
            elif key == glfw.KEY_RIGHT_BRACKET: self.state.tuning_param_index = (self.state.tuning_param_index + 1) % self.num_params
            elif key == glfw.KEY_UP or key == glfw.KEY_DOWN:
                param_to_adjust = self.param_keys[self.state.tuning_param_index]
                step = self.config.param_adjust_steps.get(param_to_adjust, 0.1)
                current_value = getattr(self.state.tuning_params, param_to_adjust)
                direction = 1 if key == glfw.KEY_UP else -1
                setattr(self.state.tuning_params, param_to_adjust, current_value + step * direction)
                
                self.state.tuning_params.kp = max(0, self.state.tuning_params.kp)
                self.state.tuning_params.kd = max(0, self.state.tuning_params.kd)
                self.state.tuning_params.action_scale = max(0, self.state.tuning_params.action_scale)

            # ç§»å‹•æ§åˆ¶
            step = self.config.keyboard_velocity_adjust_step
            if key == glfw.KEY_C: self.state.clear_command()
            elif key == glfw.KEY_W: self.state.command[1] += step
            elif key == glfw.KEY_S: self.state.command[1] -= step
            elif key == glfw.KEY_A: self.state.command[0] += step
            elif key == glfw.KEY_D: self.state.command[0] -= step
            elif key == glfw.KEY_Q: self.state.command[2] += step
            elif key == glfw.KEY_E: self.state.command[2] -= step

================================================================================
--- FILE: main.py ---
---------------------

# main.py
import sys
import numpy as np
import mujoco

from config import load_config
from state import SimulationState
from simulation import Simulation
from policy import ONNXPolicy
from observation import ObservationBuilder
from rendering import DebugOverlay
from keyboard_input_handler import KeyboardInputHandler
from xbox_input_handler import XboxInputHandler
from floating_controller import FloatingController
from serial_communicator import SerialCommunicator
from terrain_manager import TerrainManager # <-- ã€æ–°å¢ã€‘å°å…¥ TerrainManager

def main():
    """ä¸»ç¨‹å¼å…¥å£ï¼šåˆå§‹åŒ–æ‰€æœ‰çµ„ä»¶ä¸¦é‹è¡Œæ¨¡æ“¬è¿´åœˆã€‚"""
    from xbox_controller import XboxController 
    print("\n--- æ©Ÿå™¨äººæ¨¡æ“¬æ§åˆ¶å™¨ (å¤šè¼¸å…¥æ¨¡å¼ç‰ˆ) ---")
    
    config = load_config()
    state = SimulationState(config)
    sim = Simulation(config)
    
    # ã€æ–°å¢ã€‘åˆå§‹åŒ–åœ°å½¢ç®¡ç†å™¨
    terrain_manager = TerrainManager(sim.model, sim.data)
    state.terrain_manager_ref = terrain_manager # å°‡å¼•ç”¨å­˜å…¥ stateï¼Œæ–¹ä¾¿ UI è®€å–
    
    floating_controller = FloatingController(config, sim.model, sim.data)
    state.floating_controller_ref = floating_controller
    
    serial_comm = SerialCommunicator()
    xbox_handler = XboxInputHandler(state)
    
    # ã€ä¿®æ”¹ã€‘å°‡ terrain_manager ä¹Ÿå‚³å…¥
    keyboard_handler = KeyboardInputHandler(state, serial_comm, xbox_handler, terrain_manager)
    keyboard_handler.register_callbacks(sim.window)
    
    try:
        assumed_dim = next(iter(config.observation_recipes))
        recipe = config.observation_recipes[assumed_dim]
    except StopIteration:
        sys.exit("âŒ éŒ¯èª¤: åœ¨ config.yaml ä¸­æ²’æœ‰å®šç¾©ä»»ä½• observation_recipesã€‚")

    obs_builder = ObservationBuilder(recipe, sim.data, sim.model, sim.torso_id, sim.default_pose, config)
    base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
    policy = ONNXPolicy(config, base_obs_dim)

    # =========================================================================
    # === ã€æ–°å¢ã€‘å°‡ policy çš„å¼•ç”¨è¨­å®šåˆ° state ä¸­ï¼Œä»¥ä¾¿åœ¨æ¨¡å¼åˆ‡æ›æ™‚å‘¼å« reset ===
    # =========================================================================
    state.policy_ref = policy
    # =========================================================================
    
    if policy.model_input_dim != base_obs_dim:
        if policy.model_input_dim in config.observation_recipes:
            print(f"âš ï¸ ç¶­åº¦ä¸åŒ¹é…ï¼Œè‡ªå‹•åˆ‡æ›åˆ°ç¶­åº¦ {policy.model_input_dim} çš„æ­£ç¢ºé…æ–¹...")
            recipe = config.observation_recipes[policy.model_input_dim]
            obs_builder = ObservationBuilder(recipe, sim.data, sim.model, sim.torso_id, sim.default_pose, config)
            base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
        else:
            sys.exit(f"âŒ è‡´å‘½éŒ¯èª¤: æ¨¡å‹æœŸæœ›ç¶­åº¦ ({policy.model_input_dim}) èˆ‡é…æ–¹ç”¢ç”Ÿçš„è§€å¯Ÿç¶­åº¦ ({base_obs_dim}) ä¸ç¬¦ï¼Œä¸”æ‰¾ä¸åˆ°åŒ¹é…é…æ–¹ï¼")

    ALL_OBS_DIMS = {'z_angular_velocity':1, 'gravity_vector':3, 'commands':3, 'joint_positions':12, 'joint_velocities':12, 'foot_contact_states':4, 'linear_velocity':3, 'angular_velocity':3, 'last_action':12, 'phase_signal':1}
    used_dims = {k: ALL_OBS_DIMS[k] for k in recipe if k in ALL_OBS_DIMS}
    overlay = DebugOverlay(recipe, used_dims)

    def hard_reset():
        """å®Œå…¨é‡ç½®æ•´å€‹æ¨¡æ“¬ç’°å¢ƒã€‚"""
        print("\n--- æ­£åœ¨åŸ·è¡Œå®Œå…¨é‡ç½® (Hard Reset) ---")
        sim.reset()
        policy.reset()
        if state.control_mode == "FLOATING":
            state.set_control_mode("WALKING")
        state.reset_control_state(sim.data.time)
        state.clear_command()
        
        state.joint_test_offsets.fill(0.0)
        state.manual_final_ctrl.fill(0.0)
        state.manual_mode_is_floating = False
        
        state.hard_reset_requested = False

    def soft_reset():
        """åƒ…é‡ç½®æ©Ÿå™¨äººå§¿æ…‹å’Œæ§åˆ¶å™¨ç‹€æ…‹ï¼Œä¸é‡ç½®æ¨¡æ“¬æ™‚é–“å’Œç‰©ç†ä¸–ç•Œã€‚"""
        print("\n--- æ­£åœ¨åŸ·è¡Œç©ºä¸­å§¿æ…‹é‡ç½® (Soft Reset) ---")
        sim.data.qpos[7:] = sim.default_pose
        sim.data.qvel[6:] = 0
        policy.reset()
        state.clear_command()

        state.joint_test_offsets.fill(0.0)
        state.manual_final_ctrl.fill(0.0)
        state.manual_mode_is_floating = False

        mujoco.mj_forward(sim.model, sim.data)
        state.soft_reset_requested = False

    hard_reset()
    print("\n--- æ¨¡æ“¬é–‹å§‹ (SPACE: æš«åœ, N:ä¸‹ä¸€æ­¥) ---")
    print("    (F: æ‡¸æµ®, G: é—œç¯€æ¸¬è©¦, B: æ‰‹å‹•æ§åˆ¶, T: åºåˆ—åŸ , M: è¼¸å…¥æ¨¡å¼, R: ç¡¬é‡ç½®, X: è»Ÿé‡ç½®)")
    print("    (U: æƒæåºåˆ—åŸ , J: æƒææ–æ¡¿)")

    state.execute_one_step = False

    while not sim.should_close():
        if state.single_step_mode and not state.execute_one_step:
            sim.render(state, overlay)
            continue
        if state.execute_one_step:
            state.execute_one_step = False

        if state.input_mode == "GAMEPAD": xbox_handler.update_state()
        
        if state.hard_reset_requested: hard_reset()
        if state.soft_reset_requested: soft_reset()

        state.latest_pos = sim.data.body('torso').xpos.copy()
        state.latest_quat = sim.data.body('torso').xquat.copy()
        if state.serial_is_connected: state.serial_latest_messages = serial_comm.get_latest_messages()
        if state.serial_command_to_send:
            serial_comm.send_command(state.serial_command_to_send)
            state.serial_command_to_send = ""

        if state.control_mode != "SERIAL_MODE":
            if state.single_step_mode:
                print("\n" + "="*20 + f" STEP AT TIME {sim.data.time:.4f} " + "="*20)

            base_obs = obs_builder.get_observation(state.command, policy.last_action)
            if state.single_step_mode:
                current_joint_angles = sim.data.qpos[7:]
                current_joint_positions = current_joint_angles - sim.default_pose
                print(f"1. [OBSERVED] joint_positions: {np.array2string(current_joint_positions, precision=3, suppress_small=True)}")

            onnx_input, action_raw = policy.get_action(base_obs)
            state.latest_onnx_input = onnx_input.flatten()
            state.latest_action_raw = action_raw
            if state.single_step_mode:
                 print(f"2. [AI DECISION] Raw Action:      {np.array2string(action_raw, precision=3, suppress_small=True)}")

            if state.control_mode == "MANUAL_CTRL":
                state.sim_mode_text = "Manual Ctrl"
                final_ctrl = state.manual_final_ctrl.copy() 
            elif state.control_mode == "JOINT_TEST":
                state.sim_mode_text = "Joint Test"
                final_ctrl = sim.default_pose + state.joint_test_offsets
            else:
                state.sim_mode_text = state.control_mode
                final_ctrl = sim.default_pose + action_raw * state.tuning_params.action_scale

            state.latest_final_ctrl = final_ctrl
            if state.single_step_mode:
                print(f"3. [COMMAND] Final Ctrl:          {np.array2string(final_ctrl, precision=3, suppress_small=True)}")

            sim.apply_position_control(final_ctrl, state.tuning_params)
            
            target_time = sim.data.time + config.control_dt
            while sim.data.time < target_time:
                mujoco.mj_step(sim.model, sim.data)

            if state.single_step_mode:
                next_joint_angles = sim.data.qpos[7:]
                print(f"4. [RESULT] Next actual angles: {np.array2string(next_joint_angles, precision=3, suppress_small=True)}")
        
        sim.render(state, overlay)

    sim.close()
    xbox_handler.close()
    serial_comm.close()
    print("\næ¨¡æ“¬çµæŸï¼Œç¨‹å¼é€€å‡ºã€‚")

if __name__ == "__main__":
    main()

================================================================================
--- FILE: observation.py ---
----------------------------

# observation.py
import numpy as np
import mujoco
from config import AppConfig

class ObservationBuilder:
    def __init__(self, recipe: list, data, model, torso_id, default_pose, config: AppConfig):
        self.recipe = recipe
        self.data = data
        self.model = model
        self.torso_id = torso_id
        # åœ¨çµ•å°è§’åº¦æ¨¡å¼ä¸‹ï¼Œdefault_pose ä¸»è¦ç”¨æ–¼é‡ç½®å’Œé—œç¯€æ¸¬è©¦æ¨¡å¼
        self.default_pose = default_pose
        self.config = config
        self._component_generators = self._register_components()
        for component in self.recipe:
            if component not in self._component_generators:
                print(f"âš ï¸ è­¦å‘Š: è§€å¯Ÿé…æ–¹ä¸­çš„å…ƒä»¶ '{component}' æ²’æœ‰å°æ‡‰çš„ç”¢ç”Ÿå™¨å‡½å¼ï¼Œå°‡è¢«å¿½ç•¥ã€‚")

    def _register_components(self):
        """è¨»å†Šæ‰€æœ‰å·²çŸ¥çš„è§€å¯Ÿå…ƒä»¶åŠå…¶å°æ‡‰çš„ç”¢ç”Ÿå™¨å‡½å¼ã€‚"""
        return {
            'z_angular_velocity': self._get_z_angular_velocity,
            'gravity_vector': self._get_gravity_vector,
            'commands': self._get_commands,
            'joint_positions': self._get_joint_positions,
            'last_action': self._get_last_action,
            'linear_velocity': self._get_linear_velocity,
            'angular_velocity': self._get_full_angular_velocity,
            'joint_velocities': self._get_joint_velocities,
            'foot_contact_states': self._get_foot_contact_states,
            'phase_signal': self._get_phase_signal,
        }

    def get_observation(self, command, last_action) -> np.ndarray:
        """æ ¹æ“šé…æ–¹åˆ—è¡¨ï¼Œä¾åºå‘¼å«ç”¢ç”Ÿå™¨å‡½å¼ä¸¦æ‹¼æ¥æˆæœ€çµ‚çš„è§€å¯Ÿå‘é‡ã€‚"""
        obs_list = []
        for name in self.recipe:
            if name in self._component_generators:
                obs_list.append(self._component_generators[name](command=command, last_action=last_action))
        
        if not obs_list:
            return np.array([], dtype=np.float32)

        return np.concatenate(obs_list).astype(np.float32)

    def _get_torso_inverse_rotation(self):
        """è¼”åŠ©å‡½å¼ï¼šè¨ˆç®—è»€å¹¹å§¿æ…‹çš„é€†å››å…ƒæ•¸ã€‚"""
        torso_quat = self.data.xquat[self.torso_id]
        norm = np.sum(np.square(torso_quat))
        if norm < 1e-8: torso_quat = np.array([1., 0, 0, 0])
        torso_quat /= np.sqrt(np.sum(np.square(torso_quat)))
        return np.array([torso_quat[0], -torso_quat[1], -torso_quat[2], -torso_quat[3]]) / np.sum(np.square(torso_quat))

    def _rotate_vec_by_quat_inv(self, v, q_inv):
        """è¼”åŠ©å‡½å¼ï¼šä½¿ç”¨é€†å››å…ƒæ•¸å°‡ä¸–ç•Œåº§æ¨™ç³»å‘é‡è½‰æ›ç‚ºå±€éƒ¨åº§æ¨™ç³»ã€‚"""
        u, s = q_inv[1:], q_inv[0]
        return 2 * np.dot(u, v) * u + (s * s - np.dot(u, u)) * v + 2 * s * np.cross(u, v)

    def _get_z_angular_velocity(self, **kwargs):
        inv_torso_rot = self._get_torso_inverse_rotation()
        local_rpy_rate = self._rotate_vec_by_quat_inv(self.data.cvel[self.torso_id, 0:3], inv_torso_rot)
        return np.array([local_rpy_rate[2]]) * 0.25

    def _get_gravity_vector(self, **kwargs):
        inv_torso_rot = self._get_torso_inverse_rotation()
        return self._rotate_vec_by_quat_inv(np.array([0, 0, -1]), inv_torso_rot)

    def _get_commands(self, command, **kwargs):
        return command * np.array(self.config.command_scaling_factors) 

    def _get_joint_positions(self, **kwargs):
        # =================================================================
        # === ã€æ ¸å¿ƒä¿®æ”¹ã€‘ç›´æ¥è¿”å›é—œç¯€çš„ã€çµ•å°è§’åº¦ã€‘                    ===
        # === é€™æ¨£ AI è§€å¯Ÿåˆ°çš„å°±æ˜¯çœŸå¯¦çš„ç‰©ç†ä¸–ç•Œçš„è§’åº¦å€¼ã€‚            ===
        # =================================================================
        return self.data.qpos[7:] - self.default_pose


    def _get_joint_velocities(self, **kwargs):
        return self.data.qvel[6:].copy() # ç§»é™¤ * 0.05ï¼Œä¸¦åŠ ä¸Š .copy() ä»¥ç¢ºä¿å®‰å…¨

    def _get_foot_contact_states(self, **kwargs):
        foot_geom_names = ['FR', 'FL', 'RR', 'RL']
        foot_geom_ids = [mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_GEOM, name) for name in foot_geom_names]
        contacts = np.zeros(4, dtype=np.float32)
        for i in range(self.data.ncon):
            con = self.data.contact[i]
            for foot_idx, foot_geom_id in enumerate(foot_geom_ids):
                if foot_geom_id != -1 and (con.geom1 == foot_geom_id or con.geom2 == foot_geom_id):
                    contacts[foot_idx] = 1.0
                    break
        return contacts

    def _get_last_action(self, last_action, **kwargs):
        # åœ¨çµ•å°è§’åº¦æ¨¡å¼ä¸‹ï¼Œlast_action å°±æ˜¯ä¸Šä¸€å€‹ç›®æ¨™çµ•å°è§’åº¦
        return last_action

    def _get_linear_velocity(self, **kwargs):
        inv_torso_rot = self._get_torso_inverse_rotation()
        return self._rotate_vec_by_quat_inv(self.data.cvel[self.torso_id, 3:], inv_torso_rot)

    def _get_full_angular_velocity(self, **kwargs):
        inv_torso_rot = self._get_torso_inverse_rotation()
        return self._rotate_vec_by_quat_inv(self.data.cvel[self.torso_id, :3], inv_torso_rot)
        
    def _get_phase_signal(self, **kwargs):
        return np.array([self.data.time % 1.0], dtype=np.float32)

================================================================================
--- FILE: policy.py ---
-----------------------

# policy.py
import numpy as np
import onnxruntime as ort
import sys
import os
from collections import deque
from config import AppConfig

class ONNXPolicy:
    """
    å°è£ ONNX æ¨¡å‹çš„è¼‰å…¥ã€è§€å¯Ÿæ­·å²ç®¡ç†å’Œæ¨è«–é‚è¼¯ã€‚
    """
    def __init__(self, config: AppConfig, base_obs_dim: int):
        self.config = config
        self.base_obs_dim = base_obs_dim
        
        print(f"æ­£åœ¨è¼‰å…¥ ONNX æ¨¡å‹: {config.onnx_model_path}")
        sess_options = ort.SessionOptions()
        cache_path = os.path.splitext(config.onnx_model_path)[0] + ".optimized.ort"
        
        if os.path.exists(cache_path):
            print(f"âš¡ï¸ ç™¼ç¾å„ªåŒ–æ¨¡å‹å¿«å–ï¼Œå°‡å¾ '{cache_path}' å¿«é€Ÿè¼‰å…¥ã€‚")
        else:
            print(f"ğŸ¢ é¦–æ¬¡è¼‰å…¥ï¼Œå°‡å‰µå»ºå„ªåŒ–æ¨¡å‹å¿«å–æ–¼ '{cache_path}' (å¯èƒ½éœ€è¦ä¸€äº›æ™‚é–“)...")

        sess_options.optimized_model_filepath = cache_path
        sess_options.graph_optimization_level = ort.GraphOptimizationLevel.ORT_ENABLE_ALL

        try:
            self.sess = ort.InferenceSession(
                config.onnx_model_path, 
                sess_options=sess_options,
                providers=['CPUExecutionProvider']
            )
        except Exception as e:
            sys.exit(f"âŒ éŒ¯èª¤: ç„¡æ³•è¼‰å…¥ ONNX æ¨¡å‹ '{config.onnx_model_path}': {e}")

        self.input_name = self.sess.get_inputs()[0].name
        self.output_name = self.sess.get_outputs()[0].name
        self.model_input_dim = self.sess.get_inputs()[0].shape[1]
        
        print(f"âœ… æ¨¡å‹è¼‰å…¥æˆåŠŸ! æ¨¡å‹æœŸæœ›è¼¸å…¥ç¶­åº¦: {self.model_input_dim}")
        self._determine_history_length()

        self.obs_history = deque(
            [np.zeros(self.base_obs_dim, dtype=np.float32)] * self.history_length, 
            maxlen=self.history_length
        )
        self.last_action = np.zeros(config.num_motors, dtype=np.float32)

    def _determine_history_length(self):
        """æ ¹æ“šæ¨¡å‹è¼¸å…¥ç¶­åº¦å’ŒåŸºç¤è§€å¯Ÿç¶­åº¦ï¼Œè‡ªå‹•è¨ˆç®—æ­·å²é•·åº¦ã€‚"""
        if self.base_obs_dim == 0:
            print("âš ï¸ è­¦å‘Š: åŸºç¤è§€å¯Ÿç¶­åº¦ç‚º 0ï¼Œç„¡æ³•è¨ˆç®—æ­·å²é•·åº¦ã€‚")
            self.history_length = 0
            return
            
        if self.model_input_dim % self.base_obs_dim != 0:
            print(
                f"âš ï¸ è­¦å‘Š: åŸºç¤è§€å¯Ÿç¶­åº¦ ({self.base_obs_dim}) ç„¡æ³•æ•´é™¤æ¨¡å‹è¼¸å…¥ç¶­åº¦ "
                f"({self.model_input_dim})ã€‚æ­·å²å †ç–ŠåŠŸèƒ½å¯èƒ½ä¸æº–ç¢ºã€‚"
            )
            self.history_length = 1
        else:
            self.history_length = self.model_input_dim // self.base_obs_dim
        
        if self.history_length > 1:
            print(f"ğŸ¤– è‡ªå‹•åµæ¸¬åˆ°æ¨¡å‹ä½¿ç”¨æ­·å²å †ç–Šï¼Œé•·åº¦ç‚º: {self.history_length} å¹€ã€‚")
        else:
            print("ğŸ¤– æ¨¡å‹åƒ…ä½¿ç”¨ç•¶å‰è§€å¯Ÿ (æ­·å²é•·åº¦ = 1)ã€‚")

    def get_action(self, base_obs: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
        """æ ¹æ“šç•¶å‰çš„åŸºç¤è§€å¯Ÿï¼Œæ›´æ–°æ­·å²ä¸¦åŸ·è¡Œæ¨¡å‹æ¨è«–ï¼Œå›å‚³å‹•ä½œã€‚"""
        if self.history_length == 0:
            return np.array([]), np.zeros(self.config.num_motors)

        self.obs_history.append(base_obs)
        onnx_input = np.concatenate(list(self.obs_history)).astype(np.float32).reshape(1, -1)
        
        if onnx_input.shape[1] != self.model_input_dim:
            return onnx_input, np.zeros(self.config.num_motors)
            
        action_raw = self.sess.run([self.output_name], {self.input_name: onnx_input})[0].flatten()
        self.last_action[:] = action_raw
        return onnx_input, action_raw

    def reset(self):
        """é‡ç½®è§€å¯Ÿæ­·å²å’Œä¸Šä¸€å€‹å‹•ä½œã€‚"""
        self.obs_history.clear()
        if self.history_length > 0:
            for _ in range(self.history_length):
                self.obs_history.append(np.zeros(self.base_obs_dim, dtype=np.float32))
        self.last_action.fill(0.0)
        print("âœ… ONNX ç­–ç•¥ç‹€æ…‹å·²é‡ç½®ã€‚")

================================================================================
--- FILE: project_dump.txt ---
------------------------------

# å°ˆæ¡ˆç¨‹å¼ç¢¼å½™æ•´: C:\git_project\simulation_test_recoil
================================================================================

================================================================================
--- FILE: config.py ---
-----------------------

# config.py
import yaml
from dataclasses import dataclass, field
from typing import Dict, List, Any

@dataclass
class TuningParamsConfig:
    """å¾è¨­å®šæª”è¼‰å…¥çš„åˆå§‹èª¿æ ¡åƒæ•¸è³‡æ–™é¡åˆ¥ã€‚"""
    kp: float
    kd: float
    action_scale: float
    bias: float

@dataclass
class FloatingControllerConfig:
    """æ‡¸æµ®æ§åˆ¶å™¨çš„è¨­å®šã€‚"""
    target_height: float
    kp_vertical: float
    kd_vertical: float
    kp_attitude: float
    kd_attitude: float

@dataclass
class AppConfig:
    """å„²å­˜æ‰€æœ‰æ‡‰ç”¨ç¨‹å¼è¨­å®šçš„è³‡æ–™é¡åˆ¥ã€‚"""
    mujoco_model_file: str
    onnx_model_path: str
    num_motors: int
    physics_timestep: float
    control_freq: float
    control_dt: float
    warmup_duration: float
    command_scaling_factors: List[float]
    
    keyboard_velocity_adjust_step: float
    gamepad_sensitivity: Dict[str, float]
    param_adjust_steps: Dict[str, float]

    initial_tuning_params: TuningParamsConfig
    observation_recipes: Dict[int, List[str]]
    floating_controller: FloatingControllerConfig

def load_config(path: str = "config.yaml") -> AppConfig:
    """
    å¾ YAML æª”æ¡ˆè¼‰å…¥è¨­å®šä¸¦å›å‚³ä¸€å€‹ AppConfig ç‰©ä»¶ã€‚
    """
    try:
        with open(path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"è¨­å®šæª” '{path}' ä¸å­˜åœ¨ã€‚è«‹ç¢ºä¿æª”æ¡ˆè·¯å¾‘æ­£ç¢ºã€‚")
    except Exception as e:
        raise IOError(f"è®€å–æˆ–è§£æè¨­å®šæª” '{path}' æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")

    tuning_params = TuningParamsConfig(**config_data['initial_tuning_params'])
    floating_config = FloatingControllerConfig(**config_data['floating_controller'])
    
    config_obj = AppConfig(
        mujoco_model_file=config_data['mujoco_model_file'],
        onnx_model_path=config_data['onnx_model_path'],
        num_motors=config_data['num_motors'],
        physics_timestep=config_data['physics_timestep'],
        control_freq=config_data['control_freq'],
        control_dt=1.0 / config_data['control_freq'],
        warmup_duration=config_data['warmup_duration'],
        command_scaling_factors=config_data['command_scaling_factors'],
        
        keyboard_velocity_adjust_step=config_data['keyboard_velocity_adjust_step'],
        gamepad_sensitivity=config_data['gamepad_sensitivity'],
        param_adjust_steps=config_data['param_adjust_steps'],
        
        initial_tuning_params=tuning_params,
        observation_recipes=config_data['observation_recipes'],
        floating_controller=floating_config
    )
    
    print("âœ… è¨­å®šæª”è¼‰å…¥æˆåŠŸ (åŒ…å«æ‡¸æµ®æ§åˆ¶å™¨è¨­å®š)ã€‚")
    return config_obj

================================================================================
--- FILE: config.yaml ---
-------------------------

# ==================================
# === æ¨¡æ“¬èˆ‡æ¨¡å‹è¨­å®š (Simulation & Model Settings)
# ==================================
# æª”æ¡ˆè·¯å¾‘ (File Paths)
mujoco_model_file: "assets/scene_mjx.xml"
onnx_model_path: "models/pupper_ppo_policy_30965760_tf_converted_ç©©å®šæ­¥æ…‹ç‰ˆ.onnx"

# æ ¸å¿ƒåƒæ•¸ (Core Parameters)
num_motors: 12
physics_timestep: 0.004 # <-- å»ºè­°ä¿®æ”¹ï¼šæé«˜æ¨¡æ“¬ç²¾åº¦ä»¥å¢å¼·ç©©å®šæ€§
control_freq: 50.0
warmup_duration: 0.0

# ONNX æ¨¡å‹å‘½ä»¤è¼¸å…¥ç¸®æ”¾å› å­
# é †åº: [vy ç¸®æ”¾, vx ç¸®æ”¾, wz ç¸®æ”¾]
command_scaling_factors: [1.0, 1.0, 1.0] 

# ==================================
# === è¼¸å…¥æ§åˆ¶è¨­å®š (Input Control Settings)
# ==================================
keyboard_velocity_adjust_step: 0.1 # m/s or rad/s per key press

gamepad_sensitivity:
  vx: 1.0   # å‰å¾Œé€Ÿåº¦éˆæ•åº¦ (å·¦æ–æ¡¿ Y)
  vy: 1.0   # å·¦å³é€Ÿåº¦éˆæ•åº¦ (å·¦æ–æ¡¿ X)
  wz: -1.5  # è½‰å‘è§’é€Ÿåº¦éˆæ•åº¦ (å³æ–æ¡¿ X), è² å€¼è¡¨ç¤ºå³æ¨å³è½‰

param_adjust_steps:
  kp: 0.5
  kd: 0.05
  action_scale: 0.05
  bias: 5

# ==================================
# === åˆå§‹èª¿æ ¡åƒæ•¸ (Initial Tuning Parameters)
# ==================================
initial_tuning_params:
  kp: 4.0
  kd: 0.40
  action_scale: 0.5
  bias: -0.0

# ==================================
# === è§€å¯Ÿé…æ–¹ (Observation Recipes)
# ==================================
observation_recipes:
  31:
    - 'z_angular_velocity'
    - 'gravity_vector'
    - 'commands'
    - 'joint_positions'
    - 'last_action'
  48: # <-- ä¿®æ”¹é€™å€‹ 48 ç¶­çš„é †åº
    - 'linear_velocity'
    - 'angular_velocity'
    - 'gravity_vector'
    - 'joint_positions'
    - 'joint_velocities'
    - 'last_action'
    - 'commands' # <-- å°‡ commands ç§»å‹•åˆ°æœ€å¾Œ

# ================================================================= #
# === æ‡¸æµ®æ§åˆ¶å™¨è¨­å®š (Floating Controller Settings) - ç²¾ç´°èª¿æ ¡ç‰ˆ ===
# ================================================================= #
floating_controller:
  target_height: 0.50     # æ‡¸æµ®çš„ç›®æ¨™é«˜åº¦ (ç±³)
  kp_vertical: 80.0       # å‚ç›´ P (å†æ¬¡é™ä½ä»¥æ±‚å¹³æ»‘)
  kd_vertical: 18.0       # å‚ç›´ D (ä¿æŒèˆ‡Kpçš„é—œä¿‚)
  kp_attitude: 20.0       # å§¿æ…‹ P (å†æ¬¡é™ä½)
  kd_attitude: 4.0        # å§¿æ…‹ D (ç›¸æ‡‰èª¿æ•´)

================================================================================
--- FILE: floating_controller.py ---
------------------------------------

# floating_controller.py
import mujoco
import numpy as np
from config import AppConfig

class FloatingController:
    """
    é€éå•Ÿç”¨/ç¦ç”¨ weld ç´„æŸå’Œè¨­å®š mocap body çš„ä½ç½®ï¼Œ
    ä¾†å°‡æ©Ÿå™¨äººä¸»å¹¹å›ºå®šåœ¨ç©ºä¸­ã€‚
    """
    def __init__(self, config: AppConfig, model, data):
        """
        åˆå§‹åŒ–æ‡¸æµ®æ§åˆ¶å™¨ï¼Œä¸¦ç²å–å¿…è¦çš„ MuJoCo ID å’Œç´¢å¼•ã€‚
        """
        self.config = config.floating_controller
        self.model = model
        self.data = data
        self.is_functional = False
        
        try:
            anchor_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, 'anchor')
            if anchor_body_id == -1: raise ValueError("åœ¨ XML ä¸­æ‰¾ä¸åˆ°åç‚º 'anchor' çš„ bodyã€‚")
            
            self.mocap_index = model.body_mocapid[anchor_body_id]
            if self.mocap_index == -1: raise ValueError("'anchor' body ä¸æ˜¯ä¸€å€‹ mocap bodyã€‚")

            self.weld_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_EQUALITY, 'torso_anchor_weld')
            if self.weld_id == -1: raise ValueError("åœ¨ XML ä¸­æ‰¾ä¸åˆ°åç‚º 'torso_anchor_weld' çš„ weld ç´„æŸã€‚")

            self.is_functional = True
            print(f"âœ… å›ºå®šå¼æ‡¸æµ®æ§åˆ¶å™¨åˆå§‹åŒ–å®Œæˆã€‚Mocap Index: {self.mocap_index}")
        except ValueError as e:
            print(f"âŒ æ‡¸æµ®æ§åˆ¶å™¨åˆå§‹åŒ–éŒ¯èª¤: {e}")
            print("     è«‹ç¢ºä¿ scene_mjx.xml æª”æ¡ˆå·²æ­£ç¢ºå®šç¾© 'anchor' body å’Œ 'torso_anchor_weld' ç´„æŸã€‚æ‡¸æµ®åŠŸèƒ½å°‡è¢«ç¦ç”¨ã€‚")

    def enable(self, current_pos: np.ndarray):
        """å•Ÿç”¨æ‡¸æµ®æ¨¡å¼ã€‚"""
        if not self.is_functional: return
        
        target_pos = np.array([current_pos[0], current_pos[1], self.config.target_height])
        self.data.mocap_pos[self.mocap_index] = target_pos
        self.data.mocap_quat[self.mocap_index] = np.array([1., 0, 0, 0]) # ä¿æŒæ°´å¹³å§¿æ…‹
        self.data.eq_active[self.weld_id] = 1
        print("ğŸš€ å·²å•Ÿç”¨å›ºå®šæ‡¸æµ®æ¨¡å¼ã€‚")

    def disable(self):
        """ç¦ç”¨æ‡¸æµ®æ¨¡å¼ã€‚"""
        if not self.is_functional: return
        self.data.eq_active[self.weld_id] = 0
        print("ğŸ¾ å·²ç¦ç”¨å›ºå®šæ‡¸æµ®æ¨¡å¼ã€‚")

================================================================================
--- FILE: keyboard_input_handler.py ---
---------------------------------------

# keyboard_input_handler.py
import glfw
from state import SimulationState

class KeyboardInputHandler:
    """
    è™•ç†æ‰€æœ‰éµç›¤è¼¸å…¥äº‹ä»¶ï¼Œä¸¦æ ¹æ“šç•¶å‰æ¨¡å¼é€²è¡Œåˆ†æ´¾ã€‚
    """
    # ã€ä¿®æ”¹ã€‘æ¥æ”¶ terrain_manager
    def __init__(self, state: SimulationState, serial_comm, xbox_handler, terrain_manager):
        self.state = state
        self.config = state.config
        self.serial_comm = serial_comm
        self.xbox_handler = xbox_handler
        self.terrain_manager = terrain_manager # <-- ã€æ–°å¢ã€‘
        self.param_keys = ['kp', 'kd', 'action_scale', 'bias']
        self.num_params = len(self.param_keys)

    def register_callbacks(self, window):
        glfw.set_key_callback(window, self.key_callback)
        glfw.set_char_callback(window, self.char_callback)

    def char_callback(self, window, codepoint):
        if self.state.control_mode == "SERIAL_MODE":
            self.state.serial_command_buffer += chr(codepoint)

    def key_callback(self, window, key, scancode, action, mods):
        # --- 1. åªåœ¨æŒ‰éµæŒ‰ä¸‹æ™‚è§¸ç™¼çš„é€šç”¨åŠŸèƒ½ (æ¨¡å¼åˆ‡æ›ã€é‡ç½®ç­‰) ---
        if action == glfw.PRESS:
            if key == glfw.KEY_SPACE: self.state.single_step_mode = not self.state.single_step_mode; print(f"\n--- SIMULATION {'PAUSED' if self.state.single_step_mode else 'PLAYING'} ---"); return
            if self.state.single_step_mode and key == glfw.KEY_N: self.state.execute_one_step = True; return
            if key == glfw.KEY_ESCAPE: glfw.set_window_should_close(window, 1); return
            if key == glfw.KEY_R: self.state.hard_reset_requested = True; return
            if key == glfw.KEY_X: self.state.soft_reset_requested = True; return
            if key == glfw.KEY_TAB: self.state.display_page = (self.state.display_page + 1) % self.state.num_display_pages; return
            if key == glfw.KEY_M: self.state.toggle_input_mode("GAMEPAD" if self.state.input_mode == "KEYBOARD" else "KEYBOARD"); return
            # ã€æ–°å¢ã€‘V éµåˆ‡æ›åœ°å½¢
            if key == glfw.KEY_V: 
                self.terrain_manager.cycle_terrain()
                return
            
            # è¨­å‚™æƒæ
            if key == glfw.KEY_U: self.state.serial_is_connected = self.serial_comm.scan_and_connect(); return
            if key == glfw.KEY_J: self.state.gamepad_is_connected = self.xbox_handler.scan_and_connect(); return

        # --- 2. å¯é‡è¤‡è§¸ç™¼çš„æ¨¡å¼ç‰¹å®šåŠŸèƒ½ ---
        # é€™æ˜¯æœ€é—œéµçš„ä¿®æ”¹ï¼šå„ªå…ˆè™•ç†ç‰¹å®šæ¨¡å¼çš„æŒ‰éµï¼Œå¦‚æœè™•ç†äº†å°± return
        if action in [glfw.PRESS, glfw.REPEAT]:
            if self.state.control_mode == "SERIAL_MODE":
                if key == glfw.KEY_ENTER: self.state.serial_command_to_send = self.state.serial_command_buffer; self.state.serial_command_buffer = ""
                elif key == glfw.KEY_BACKSPACE: self.state.serial_command_buffer = self.state.serial_command_buffer[:-1]
                elif key == glfw.KEY_T and action == glfw.PRESS: self.state.set_control_mode("WALKING")
                return

            if self.state.control_mode == "JOINT_TEST":
                if key == glfw.KEY_LEFT_BRACKET and action == glfw.PRESS: self.state.joint_test_index = (self.state.joint_test_index - 1) % 12
                elif key == glfw.KEY_RIGHT_BRACKET and action == glfw.PRESS: self.state.joint_test_index = (self.state.joint_test_index + 1) % 12
                elif key == glfw.KEY_UP: self.state.joint_test_offsets[self.state.joint_test_index] += 0.1
                elif key == glfw.KEY_DOWN: self.state.joint_test_offsets[self.state.joint_test_index] -= 0.1
                elif key == glfw.KEY_C and action == glfw.PRESS: self.state.joint_test_offsets.fill(0.0)
                elif key == glfw.KEY_G and action == glfw.PRESS: self.state.set_control_mode("WALKING")
                return

            if self.state.control_mode == "MANUAL_CTRL":
                if key == glfw.KEY_F and action == glfw.PRESS:
                    self.state.manual_mode_is_floating = not self.state.manual_mode_is_floating
                    is_floating = self.state.manual_mode_is_floating
                    if is_floating:
                        if self.state.floating_controller_ref: self.state.floating_controller_ref.enable(self.state.latest_pos)
                    else:
                        if self.state.floating_controller_ref: self.state.floating_controller_ref.disable()
                elif key == glfw.KEY_LEFT_BRACKET and action == glfw.PRESS: self.state.manual_ctrl_index = (self.state.manual_ctrl_index - 1) % 12
                elif key == glfw.KEY_RIGHT_BRACKET and action == glfw.PRESS: self.state.manual_ctrl_index = (self.state.manual_ctrl_index + 1) % 12
                elif key == glfw.KEY_UP: self.state.manual_final_ctrl[self.state.manual_ctrl_index] += 0.1
                elif key == glfw.KEY_DOWN: self.state.manual_final_ctrl[self.state.manual_ctrl_index] -= 0.1
                elif key == glfw.KEY_C and action == glfw.PRESS: self.state.manual_final_ctrl.fill(0.0)
                elif key == glfw.KEY_G and action == glfw.PRESS: self.state.set_control_mode("WALKING")
                return

        # --- 3. å¦‚æœä»¥ä¸Šæ¨¡å¼éƒ½ä¸æ˜¯ï¼Œå‰‡åŸ·è¡Œ WALKING/FLOATING æ¨¡å¼çš„é è¨­æŒ‰éµé‚è¼¯ ---
        if action == glfw.PRESS:
            if key == glfw.KEY_F: self.state.set_control_mode("FLOATING" if self.state.control_mode == "WALKING" else "WALKING"); return
            if key == glfw.KEY_T: self.state.set_control_mode("SERIAL_MODE"); return
            if key == glfw.KEY_G: self.state.set_control_mode("JOINT_TEST"); return
            if key == glfw.KEY_B: self.state.set_control_mode("MANUAL_CTRL"); return
        
        if self.state.input_mode != "KEYBOARD": return
            
        if action in [glfw.PRESS, glfw.REPEAT]:
            # åƒæ•¸èª¿æ•´
            if key == glfw.KEY_LEFT_BRACKET: self.state.tuning_param_index = (self.state.tuning_param_index - 1) % self.num_params
            elif key == glfw.KEY_RIGHT_BRACKET: self.state.tuning_param_index = (self.state.tuning_param_index + 1) % self.num_params
            elif key == glfw.KEY_UP or key == glfw.KEY_DOWN:
                param_to_adjust = self.param_keys[self.state.tuning_param_index]
                step = self.config.param_adjust_steps.get(param_to_adjust, 0.1)
                current_value = getattr(self.state.tuning_params, param_to_adjust)
                direction = 1 if key == glfw.KEY_UP else -1
                setattr(self.state.tuning_params, param_to_adjust, current_value + step * direction)
                
                self.state.tuning_params.kp = max(0, self.state.tuning_params.kp)
                self.state.tuning_params.kd = max(0, self.state.tuning_params.kd)
                self.state.tuning_params.action_scale = max(0, self.state.tuning_params.action_scale)

            # ç§»å‹•æ§åˆ¶
            step = self.config.keyboard_velocity_adjust_step
            if key == glfw.KEY_C: self.state.clear_command()
            elif key == glfw.KEY_W: self.state.command[1] += step
            elif key == glfw.KEY_S: self.state.command[1] -= step
            elif key == glfw.KEY_A: self.state.command[0] += step
            elif key == glfw.KEY_D: self.state.command[0] -= step
            elif key == glfw.KEY_Q: self.state.command[2] += step
            elif key == glfw.KEY_E: self.state.command[2] -= step

================================================================================
--- FILE: main.py ---
---------------------

# main.py
import sys
import numpy as np
import mujoco

from config import load_config
from state import SimulationState
from simulation import Simulation
from policy import ONNXPolicy
from observation import ObservationBuilder
from rendering import DebugOverlay
from keyboard_input_handler import KeyboardInputHandler
from xbox_input_handler import XboxInputHandler
from floating_controller import FloatingController
from serial_communicator import SerialCommunicator
from terrain_manager import TerrainManager # <-- ã€æ–°å¢ã€‘å°å…¥ TerrainManager

def main():
    """ä¸»ç¨‹å¼å…¥å£ï¼šåˆå§‹åŒ–æ‰€æœ‰çµ„ä»¶ä¸¦é‹è¡Œæ¨¡æ“¬è¿´åœˆã€‚"""
    from xbox_controller import XboxController 
    print("\n--- æ©Ÿå™¨äººæ¨¡æ“¬æ§åˆ¶å™¨ (å¤šè¼¸å…¥æ¨¡å¼ç‰ˆ) ---")
    
    config = load_config()
    state = SimulationState(config)
    sim = Simulation(config)
    
    # ã€æ–°å¢ã€‘åˆå§‹åŒ–åœ°å½¢ç®¡ç†å™¨
    terrain_manager = TerrainManager(sim.model, sim.data)
    state.terrain_manager_ref = terrain_manager # å°‡å¼•ç”¨å­˜å…¥ stateï¼Œæ–¹ä¾¿ UI è®€å–
    
    floating_controller = FloatingController(config, sim.model, sim.data)
    state.floating_controller_ref = floating_controller
    
    serial_comm = SerialCommunicator()
    xbox_handler = XboxInputHandler(state)
    
    # ã€ä¿®æ”¹ã€‘å°‡ terrain_manager ä¹Ÿå‚³å…¥
    keyboard_handler = KeyboardInputHandler(state, serial_comm, xbox_handler, terrain_manager)
    keyboard_handler.register_callbacks(sim.window)
    
    try:
        assumed_dim = next(iter(config.observation_recipes))
        recipe = config.observation_recipes[assumed_dim]
    except StopIteration:
        sys.exit("âŒ éŒ¯èª¤: åœ¨ config.yaml ä¸­æ²’æœ‰å®šç¾©ä»»ä½• observation_recipesã€‚")

    obs_builder = ObservationBuilder(recipe, sim.data, sim.model, sim.torso_id, sim.default_pose, config)
    base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
    policy = ONNXPolicy(config, base_obs_dim)

    # =========================================================================
    # === ã€æ–°å¢ã€‘å°‡ policy çš„å¼•ç”¨è¨­å®šåˆ° state ä¸­ï¼Œä»¥ä¾¿åœ¨æ¨¡å¼åˆ‡æ›æ™‚å‘¼å« reset ===
    # =========================================================================
    state.policy_ref = policy
    # =========================================================================
    
    if policy.model_input_dim != base_obs_dim:
        if policy.model_input_dim in config.observation_recipes:
            print(f"âš ï¸ ç¶­åº¦ä¸åŒ¹é…ï¼Œè‡ªå‹•åˆ‡æ›åˆ°ç¶­åº¦ {policy.model_input_dim} çš„æ­£ç¢ºé…æ–¹...")
            recipe = config.observation_recipes[policy.model_input_dim]
            obs_builder = ObservationBuilder(recipe, sim.data, sim.model, sim.torso_id, sim.default_pose, config)
            base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
        else:
            sys.exit(f"âŒ è‡´å‘½éŒ¯èª¤: æ¨¡å‹æœŸæœ›ç¶­åº¦ ({policy.model_input_dim}) èˆ‡é…æ–¹ç”¢ç”Ÿçš„è§€å¯Ÿç¶­åº¦ ({base_obs_dim}) ä¸ç¬¦ï¼Œä¸”æ‰¾ä¸åˆ°åŒ¹é…é…æ–¹ï¼")

    ALL_OBS_DIMS = {'z_angular_velocity':1, 'gravity_vector':3, 'commands':3, 'joint_positions':12, 'joint_velocities':12, 'foot_contact_states':4, 'linear_velocity':3, 'angular_velocity':3, 'last_action':12, 'phase_signal':1}
    used_dims = {k: ALL_OBS_DIMS[k] for k in recipe if k in ALL_OBS_DIMS}
    overlay = DebugOverlay(recipe, used_dims)

    def hard_reset():
        """å®Œå…¨é‡ç½®æ•´å€‹æ¨¡æ“¬ç’°å¢ƒã€‚"""
        print("\n--- æ­£åœ¨åŸ·è¡Œå®Œå…¨é‡ç½® (Hard Reset) ---")
        sim.reset()
        policy.reset()
        if state.control_mode == "FLOATING":
            state.set_control_mode("WALKING")
        state.reset_control_state(sim.data.time)
        state.clear_command()
        
        state.joint_test_offsets.fill(0.0)
        state.manual_final_ctrl.fill(0.0)
        state.manual_mode_is_floating = False
        
        state.hard_reset_requested = False

    def soft_reset():
        """åƒ…é‡ç½®æ©Ÿå™¨äººå§¿æ…‹å’Œæ§åˆ¶å™¨ç‹€æ…‹ï¼Œä¸é‡ç½®æ¨¡æ“¬æ™‚é–“å’Œç‰©ç†ä¸–ç•Œã€‚"""
        print("\n--- æ­£åœ¨åŸ·è¡Œç©ºä¸­å§¿æ…‹é‡ç½® (Soft Reset) ---")
        sim.data.qpos[7:] = sim.default_pose
        sim.data.qvel[6:] = 0
        policy.reset()
        state.clear_command()

        state.joint_test_offsets.fill(0.0)
        state.manual_final_ctrl.fill(0.0)
        state.manual_mode_is_floating = False

        mujoco.mj_forward(sim.model, sim.data)
        state.soft_reset_requested = False

    hard_reset()
    print("\n--- æ¨¡æ“¬é–‹å§‹ (SPACE: æš«åœ, N:ä¸‹ä¸€æ­¥) ---")
    print("    (F: æ‡¸æµ®, G: é—œç¯€æ¸¬è©¦, B: æ‰‹å‹•æ§åˆ¶, T: åºåˆ—åŸ , M: è¼¸å…¥æ¨¡å¼, R: ç¡¬é‡ç½®, X: è»Ÿé‡ç½®)")
    print("    (U: æƒæåºåˆ—åŸ , J: æƒææ–æ¡¿)")

    state.execute_one_step = False

    while not sim.should_close():
        if state.single_step_mode and not state.execute_one_step:
            sim.render(state, overlay)
            continue
        if state.execute_one_step:
            state.execute_one_step = False

        if state.input_mode == "GAMEPAD": xbox_handler.update_state()
        
        if state.hard_reset_requested: hard_reset()
        if state.soft_reset_requested: soft_reset()

        state.latest_pos = sim.data.body('torso').xpos.copy()
        state.latest_quat = sim.data.body('torso').xquat.copy()
        if state.serial_is_connected: state.serial_latest_messages = serial_comm.get_latest_messages()
        if state.serial_command_to_send:
            serial_comm.send_command(state.serial_command_to_send)
            state.serial_command_to_send = ""

        if state.control_mode != "SERIAL_MODE":
            if state.single_step_mode:
                print("\n" + "="*20 + f" STEP AT TIME {sim.data.time:.4f} " + "="*20)

            base_obs = obs_builder.get_observation(state.command, policy.last_action)
            if state.single_step_mode:
                current_joint_angles = sim.data.qpos[7:]
                current_joint_positions = current_joint_angles - sim.default_pose
                print(f"1. [OBSERVED] joint_positions: {np.array2string(current_joint_positions, precision=3, suppress_small=True)}")

            onnx_input, action_raw = policy.get_action(base_obs)
            state.latest_onnx_input = onnx_input.flatten()
            state.latest_action_raw = action_raw
            if state.single_step_mode:
                 print(f"2. [AI DECISION] Raw Action:      {np.array2string(action_raw, precision=3, suppress_small=True)}")

            if state.control_mode == "MANUAL_CTRL":
                state.sim_mode_text = "Manual Ctrl"
                final_ctrl = state.manual_final_ctrl.copy() 
            elif state.control_mode == "JOINT_TEST":
                state.sim_mode_text = "Joint Test"
                final_ctrl = sim.default_pose + state.joint_test_offsets
            else:
                state.sim_mode_text = state.control_mode
                final_ctrl = sim.default_pose + action_raw * state.tuning_params.action_scale

            state.latest_final_ctrl = final_ctrl
            if state.single_step_mode:
                print(f"3. [COMMAND] Final Ctrl:          {np.array2string(final_ctrl, precision=3, suppress_small=True)}")

            sim.apply_position_control(final_ctrl, state.tuning_params)
            
            target_time = sim.data.time + config.control_dt
            while sim.data.time < target_time:
                mujoco.mj_step(sim.model, sim.data)

            if state.single_step_mode:
                next_joint_angles = sim.data.qpos[7:]
                print(f"4. [RESULT] Next actual angles: {np.array2string(next_joint_angles, precision=3, suppress_small=True)}")
        
        sim.render(state, overlay)

    sim.close()
    xbox_handler.close()
    serial_comm.close()
    print("\næ¨¡æ“¬çµæŸï¼Œç¨‹å¼é€€å‡ºã€‚")

if __name__ == "__main__":
    main()

================================================================================
--- FILE: observation.py ---


================================================================================
--- FILE: readme.md ---
-----------------------

å‰ç½®å®‰è£ï¼šä½ éœ€è¦å®‰è£ PyYAMLã€‚åœ¨ä½ çš„çµ‚ç«¯æ©Ÿä¸­åŸ·è¡Œï¼š
pip install onnxruntime numpy
pip install PyYAML
pip install mujoco glfw //é€™å€‹çœ‹çœ‹ç’°å¢ƒæœ‰æ²’æœ‰è¼‰ï¼Œæˆ‘ä¸æ˜¯ç”¨é€™å€‹
pip install inputs //æ–æ¡¿ç”¨çš„
pip install pygame
pip install pyserial



================================================================================
--- FILE: rendering.py ---
--------------------------

# rendering.py
import mujoco
import numpy as np
import time
from state import SimulationState
from typing import TYPE_CHECKING, List, Dict

if TYPE_CHECKING:
    from simulation import Simulation
    from serial_communicator import SerialCommunicator

class DebugOverlay:
    """
    è² è²¬åœ¨ MuJoCo è¦–çª—ä¸Šæ¸²æŸ“æ‰€æœ‰æ–‡å­—é™¤éŒ¯è³‡è¨Šã€‚
    """
    def __init__(self, recipe: List[str], recipe_dims: Dict[str, int]):
        self.recipe = recipe
        self.component_dims = recipe_dims
        self.display_pages_content = [
            ['linear_velocity', 'angular_velocity', 'gravity_vector', 'commands'],
            ['joint_positions', 'joint_velocities', 'last_action'],
        ]
        state_class_ref = SimulationState
        state_class_ref.num_display_pages = len(self.display_pages_content)

    def render(self, viewport, context, state: SimulationState, sim: "Simulation"):
        """æ ¹æ“šç•¶å‰æ§åˆ¶æ¨¡å¼ï¼Œé¸æ“‡ä¸¦å‘¼å«å°æ‡‰çš„æ¸²æŸ“å‡½å¼ã€‚"""
        if state.control_mode == "SERIAL_MODE":
            self.render_serial_console(viewport, context, state)
        elif state.control_mode == "JOINT_TEST":
            self.render_joint_test_overlay(viewport, context, state, sim)
        elif state.control_mode == "MANUAL_CTRL":
            self.render_manual_ctrl_overlay(viewport, context, state, sim)
        else:
            self.render_simulation_overlay(viewport, context, state, sim)

    def render_serial_console(self, viewport, context, state: SimulationState):
        """æ¸²æŸ“ä¸€å€‹å…¨è¢å¹•çš„åºåˆ—åŸ æ§åˆ¶å°ä»‹é¢ã€‚"""
        mujoco.mjr_rectangle(viewport, 0.2, 0.2, 0.2, 0.9)
        title = "--- SERIAL CONSOLE MODE (Press T to exit) ---"
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_BIG, mujoco.mjtGridPos.mjGRID_TOPLEFT, viewport, title, None, context)
        log_text = "\n".join(state.serial_latest_messages)
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, viewport, "\n\n" + log_text, " ", context)
        cursor = "_" if int(time.time() * 2) % 2 == 0 else " "
        buffer_text = f"> {state.serial_command_buffer}{cursor}"
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_BOTTOMLEFT, viewport, buffer_text, None, context)
    
    def render_joint_test_overlay(self, viewport, context, state: SimulationState, sim: "Simulation"):
        """æ¸²æŸ“é—œç¯€æ‰‹å‹•æ¸¬è©¦æ¨¡å¼çš„å°ˆç”¨ä»‹é¢ã€‚"""
        mujoco.mjr_rectangle(viewport, 0.2, 0.25, 0.3, 0.9)
        help_text = (
            "--- JOINT TEST MODE ---\n\n"
            "Press '[ / ]' to Select Joint\n"
            "Press UP / DOWN to Adjust Offset\n"
            "Press 'C' to Clear All Offsets\n\n"
            "Press 'G' to Return to Walking Mode"
        )
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_BIG, mujoco.mjtGridPos.mjGRID_TOPRIGHT, viewport, help_text, None, context)
        joint_names = [
            "0: FR_Abduction", "1: FR_Hip", "2: FR_Knee",
            "3: FL_Abduction", "4: FL_Hip", "5: FL_Knee",
            "6: RR_Abduction", "7: RR_Hip", "8: RR_Knee",
            "9: RL_Abduction", "10: RL_Hip", "11: RL_Knee"
        ]
        num_joints_per_col = 6
        left_col_text, right_col_text = "", ""
        for i, name in enumerate(joint_names):
            prefix = ">> " if i == state.joint_test_index else "   "
            offset_val = state.joint_test_offsets[i]
            final_val = sim.default_pose[i] + offset_val
            line_text = f"{prefix}{name:<15}: Offset={offset_val:+.2f}, Final={final_val:+.2f}\n"
            if i < num_joints_per_col: left_col_text += line_text
            else: right_col_text += line_text
        
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, viewport, left_col_text, None, context)
        right_col_rect = mujoco.MjrRect(int(viewport.width * 0.45), 0, int(viewport.width * 0.55), viewport.height)
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, right_col_rect, right_col_text, None, context)

    def render_manual_ctrl_overlay(self, viewport, context, state: SimulationState, sim: "Simulation"):
        """æ¸²æŸ“æ‰‹å‹• Final Ctrl æ¨¡å¼çš„å°ˆç”¨ä»‹é¢ã€‚"""
        floating_status = "Floating" if state.manual_mode_is_floating else "On Ground"
        help_title = f"--- MANUAL CTRL MODE ({floating_status}) ---"

        help_text = (
            f"{help_title}\n\n"
            "Press 'F' to Toggle Floating\n\n"
            "Press '[ / ]' to Select Joint\n"
            "Press UP / DOWN to Adjust Target Angle\n"
            "Press 'C' to Reset All Targets to 0\n\n"
            "Press 'G' to Return to Walking Mode"
        )
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPRIGHT, viewport, help_text, None, context)
        
        joint_names = [
            "0: FR_Abduction", "1: FR_Hip", "2: FR_Knee",
            "3: FL_Abduction", "4: FL_Hip", "5: FL_Knee",
            "6: RR_Abduction", "7: RR_Hip", "8: RR_Knee",
            "9: RL_Abduction", "10: RL_Hip", "11: RL_Knee"
        ]
        num_joints_per_col = 6
        left_col_text, right_col_text = "", ""
        
        current_joint_positions = sim.data.qpos[7:]
        
        for i, name in enumerate(joint_names):
            prefix = ">> " if i == state.manual_ctrl_index else "   "
            target_val = state.manual_final_ctrl[i]
            actual_val = current_joint_positions[i]
            error = target_val - actual_val
            
            line_text = f"{prefix}{name:<15}: Target={target_val:+.2f}, Actual={actual_val:+.2f}, Err={error:+.2f}\n"
            
            if i < num_joints_per_col:
                left_col_text += line_text
            else:
                right_col_text += line_text
        
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, viewport, left_col_text, None, context)
        
        right_col_rect = mujoco.MjrRect(int(viewport.width * 0.40), 0, int(viewport.width * 0.60), viewport.height)
        
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, right_col_rect, right_col_text, None, context)

    def render_simulation_overlay(self, viewport, context, state: SimulationState, sim: "Simulation"):
        """æ¸²æŸ“æ­£å¸¸çš„æ¨¡æ“¬é™¤éŒ¯è³‡è¨Šã€‚"""
        def format_vec(label: str, vec, precision=3, label_width=24):
            if vec is None or vec.size == 0: return f"{label:<{label_width}}None"
            vec_str = np.array2string(vec, precision=precision, floatmode='fixed', suppress_small=True, threshold=100)
            return f"{label:<{label_width}}{vec_str}"

        help_text = (
            "--- CONTROLS ---\n\n"
            "[Universal]\n"
            "  SPACE: Pause/Play | N: Next Step\n"
            "  F: Float | G: Joint Test/Exit | B: Manual Ctrl\n"
            "  ESC: Exit       | R: Reset\n"
            "  X: Soft Reset   | TAB: Info Page\n"
            "  M: Input Mode   | C: Clear Cmd (Kbd)\n"
            "  U: Scan Serial  | J: Scan Gamepad\n"
            "  V: Cycle Terrain\n\n"   # ã€ä¿®æ”¹ã€‘æ›´æ–°å¹«åŠ©æ–‡å­—ï¼ŒåŠ å…¥ V éµæç¤º
            "[Keyboard Mode]\n"
            "  WASD/QE: Move/Turn\n"
            "  [/]: Select Param\n"
            "  UP/DOWN: Adjust Value\n\n"
            "[Gamepad Mode]\n"
            "  L-Stick: Move | R-Stick: Turn\n"
            "  LB/RB: Select Param\n"
            "  D-Pad U/D: Adjust Value\n"
            "  Select/View: Reset"
        )
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPRIGHT, viewport, help_text, None, context)

        serial_status = "Connected" if state.serial_is_connected else "Disconnected (Press U to Scan)"
        gamepad_status = "Connected" if state.gamepad_is_connected else "Disconnected (Press J to Scan)"

        # ã€æ–°å¢ã€‘ç²å–ç•¶å‰åœ°å½¢åç¨±
        terrain_name = state.terrain_manager_ref.get_current_terrain_name() if state.terrain_manager_ref else "N/A"

        p = state.tuning_params
        
        prefixes = ["   "] * 4
        prefixes[state.tuning_param_index] = ">> "

        # ã€ä¿®æ”¹ã€‘åœ¨ UI ä¸­åŠ å…¥åœ°å½¢è³‡è¨Š
        top_left_text = (
            f"Mode: {state.control_mode} | Input: {state.input_mode}\n"
            f"Time: {sim.data.time:.2f} s\n"
            f"Terrain: {terrain_name}\n\n"
            f"--- Devices ---\n"
            f"Serial: {serial_status}\n"
            f"Gamepad: {gamepad_status}\n\n"
            f"--- Tuning Params ---\n"
            f"{prefixes[0]}{format_vec('Kp:', np.array([p.kp]), 1)}\n"
            f"{prefixes[1]}{format_vec('Kd:', np.array([p.kd]), 2)}\n"
            f"{prefixes[2]}{format_vec('Act Scale:', np.array([p.action_scale]), 3)}\n"
            f"{prefixes[3]}{format_vec('Bias:', np.array([p.bias]), 1)}\n\n"
            f"--- Command ---\n"
            f"{format_vec('User Cmd:', state.command)}\n"
        ) # <--- ã€èªæ³•ä¿®å¾©ã€‘åœ¨é€™è£¡è£œä¸Šäº†éºæ¼çš„å³æ‹¬è™Ÿ ')'

        if state.control_mode == "FLOATING":
            current_height = sim.data.qpos[2]
            target_height = sim.config.floating_controller.target_height
            top_left_text += (
                f"\n--- Floating Info ---\n"
                f"{format_vec('Target H:', np.array([target_height]), 3)}\n"
                f"{format_vec('Current H:', np.array([current_height]), 3)}\n"
            )
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, viewport, top_left_text, None, context)
        
        bottom_left_text = f"--- ONNX INPUTS (Page {state.display_page + 1}/{state.num_display_pages}) ---\n"
        onnx_input_vec = state.latest_onnx_input
        if onnx_input_vec.size > 0 and state.display_page < len(self.display_pages_content):
            current_page_components = self.display_pages_content[state.display_page]
            base_obs_dim = sum(self.component_dims.values()) if self.component_dims else 0
            if base_obs_dim > 0:
                history_len = len(onnx_input_vec) // base_obs_dim
                current_full_obs_idx = 0
                for comp_name_in_recipe in self.recipe:
                    dim = self.component_dims.get(comp_name_in_recipe, 0)
                    if dim > 0:
                        if comp_name_in_recipe in current_page_components:
                            start_idx, end_idx = current_full_obs_idx, current_full_obs_idx + dim
                            value_slice = onnx_input_vec[start_idx:end_idx]
                            bottom_left_text += format_vec(f"{comp_name_in_recipe} [{dim}d]:", value_slice, 2) + "\n"
                        current_full_obs_idx += dim
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_BOTTOMLEFT, viewport, bottom_left_text, None, context)
        
        torso_lin_vel = sim.data.cvel[sim.torso_id, 3:]
        torso_ang_vel_local = self._get_local_ang_vel(sim.data, sim.torso_id)
        bottom_right_text = (
            f"--- ONNX OUTPUTS & STATE ---\n"
            f"{format_vec('Raw Action:', state.latest_action_raw)}\n"
            f"{format_vec('Final Ctrl:', state.latest_final_ctrl)}\n\n"
            f"--- Robot State ---\n"
            f"{format_vec('Torso Z:', np.array([sim.data.qpos[2]]))}\n"
            f"{format_vec('Lin Vel (World):', torso_lin_vel)}\n"
            f"{format_vec('Ang Vel (Local):', torso_ang_vel_local)}"
        )
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_BOTTOMRIGHT, viewport, bottom_right_text, None, context)
    
    def _get_local_ang_vel(self, data, torso_id):
        """è¼”åŠ©å‡½å¼ï¼Œè¨ˆç®—å±€éƒ¨è§’é€Ÿåº¦ç”¨æ–¼é¡¯ç¤ºã€‚"""
        torso_quat = data.xquat[torso_id]
        norm = np.sum(np.square(torso_quat))
        if norm < 1e-8: return np.zeros(3)
        torso_quat /= np.sqrt(norm)
        q_inv = np.array([torso_quat[0], -torso_quat[1], -torso_quat[2], -torso_quat[3]]) / norm
        u, s = q_inv[1:], q_inv[0]
        world_ang_vel = data.cvel[torso_id, :3]
        return 2 * np.dot(u, world_ang_vel) * u + (s*s - np.dot(u, u)) * world_ang_vel + 2*s*np.cross(u, world_ang_vel)

================================================================================
--- FILE: serial_communicator.py ---
------------------------------------

# serial_communicator.py
import serial
import time
import sys
import threading
import serial.tools.list_ports
from collections import deque

class SerialCommunicator:
    """
    ä¸€å€‹é¡åˆ¥ï¼Œå°è£äº†èˆ‡åºåˆ—åŸ è¨­å‚™çš„é€šè¨Šé‚è¼¯ã€‚
    å®ƒä½¿ç”¨èƒŒæ™¯åŸ·è¡Œç·’ä¾†éé˜»å¡åœ°è®€å–æ•¸æ“šã€‚
    """
    def __init__(self, max_log_lines=15):
        """
        åˆå§‹åŒ–é€šè¨Šå™¨ï¼Œä½†ä¸ç«‹å³é€£æ¥ã€‚
        """
        self.ser = None
        self.read_thread = None
        self.exit_signal = threading.Event()
        self.is_connected = False
        self.port_name = None
        self.message_log = deque(maxlen=max_log_lines)
        print("âœ… åºåˆ—åŸ é€šè¨Šå™¨å·²åˆå§‹åŒ– (ç­‰å¾…é€£æ¥æŒ‡ä»¤)ã€‚")

    def scan_and_connect(self) -> bool:
        """
        æƒæåºåˆ—åŸ ï¼Œè®“ä½¿ç”¨è€…åœ¨çµ‚ç«¯æ©Ÿé¸æ“‡ï¼Œä¸¦å˜—è©¦é€£æ¥ã€‚
        è¿”å›é€£æ¥æ˜¯å¦æˆåŠŸã€‚
        """
        if self.is_connected:
            print("åºåˆ—åŸ å·²é€£æ¥ï¼Œç„¡éœ€é‡æ–°æƒæã€‚")
            return True
            
        selected_port = self._select_serial_port()
        if selected_port:
            self.port_name = selected_port
            return self.connect()
        return False

    def _select_serial_port(self):
        """
        æƒæä¸¦è®“ä½¿ç”¨è€…é¸æ“‡åºåˆ—åŸ ã€‚å„ªå…ˆè‡ªå‹•æª¢æ¸¬ Teensyã€‚
        è¿”å›é¸å®šçš„åºåˆ—åŸ åç¨±ï¼Œå¦‚æœæ‰¾ä¸åˆ°å‰‡è¿”å› Noneã€‚
        """
        print("\n" + "="*20 + " æ­£åœ¨æƒæåºåˆ—åŸ  " + "="*20)
        ports = serial.tools.list_ports.comports()
        if not ports:
            print("--- æœªæ‰¾åˆ°ä»»ä½•åºåˆ—åŸ  ---")
            return None

        teensy_ports = [p for p in ports if p.vid == 0x16C0 and p.pid == 0x0483]
        if len(teensy_ports) == 1:
            print(f"è‡ªå‹•æª¢æ¸¬åˆ° Teensy: {teensy_ports[0].device}")
            return teensy_ports[0].device
        
        print("\nè«‹å¾ä»¥ä¸‹åˆ—è¡¨ä¸­é¸æ“‡æ‚¨çš„è¨­å‚™:")
        for i, port in enumerate(ports):
            print(f"  [{i}] {port.device} - {port.description}")
        while True:
            try:
                choice_str = input(f"è«‹è¼¸å…¥é¸æ“‡çš„ç·¨è™Ÿ (0-{len(ports)-1}) æˆ–ç›´æ¥æŒ‰ Enter è·³é: ")
                if not choice_str:
                    print("å·²è·³éåºåˆ—åŸ é¸æ“‡ã€‚")
                    return None
                choice = int(choice_str)
                if 0 <= choice < len(ports):
                    return ports[choice].device
                else:
                    print("è¼¸å…¥ç„¡æ•ˆï¼Œè«‹é‡æ–°è¼¸å…¥ã€‚")
            except (ValueError, IndexError):
                print("è¼¸å…¥ç„¡æ•ˆï¼Œè«‹è¼¸å…¥åˆ—è¡¨ä¸­çš„æ•¸å­—ã€‚")

    def connect(self, baud_rate=115200) -> bool:
        """é€£æ¥åˆ°æŒ‡å®šçš„åºåˆ—åŸ ä¸¦å•Ÿå‹•è®€å–åŸ·è¡Œç·’ã€‚"""
        if not self.port_name: return False
        try:
            print(f"æ­£åœ¨é€£æ¥åˆ° {self.port_name}...")
            self.ser = serial.Serial(self.port_name, baud_rate, timeout=0.1)
            time.sleep(0.5)
            self.ser.reset_input_buffer()
            self.ser.reset_output_buffer()
            
            self.exit_signal.clear()
            self.read_thread = threading.Thread(target=self._read_from_port, daemon=True)
            self.read_thread.start()
            self.is_connected = True
            print(f"âœ… åºåˆ—åŸ  {self.port_name} é€£æ¥æˆåŠŸã€‚")
            return True

        except serial.SerialException as e:
            print(f"âŒ åºåˆ—åŸ é€£æ¥å¤±æ•—: {e}")
            self.is_connected = False
            return False

    def _read_from_port(self):
        """åœ¨èƒŒæ™¯åŸ·è¡Œç·’ä¸­è®€å–æ•¸æ“šä¸¦å­˜å…¥æ—¥èªŒã€‚"""
        while not self.exit_signal.is_set():
            try:
                if self.ser and self.ser.is_open and self.ser.in_waiting > 0:
                    response = self.ser.readline().decode('utf-8', 'ignore').strip()
                    if response:
                        self.message_log.append(response)
            except serial.SerialException:
                self.message_log.append("[éŒ¯èª¤] åºåˆ—åŸ å·²æ–·é–‹ã€‚")
                self.is_connected = False
                break
            time.sleep(0.01)

    def send_command(self, command: str):
        """å‘åºåˆ—åŸ ç™¼é€æŒ‡ä»¤ã€‚"""
        if self.is_connected and command:
            try:
                command_to_send = command + '\n'
                self.ser.write(command_to_send.encode('utf-8'))
                self.message_log.append(f"> {command}")
            except serial.SerialException as e:
                 self.message_log.append(f"[éŒ¯èª¤] ç™¼é€å¤±æ•—: {e}")
                 self.is_connected = False

    def get_latest_messages(self) -> list:
        """ç²å–æ—¥èªŒä¸­çš„æ‰€æœ‰è¨Šæ¯ã€‚"""
        return list(self.message_log)

    def close(self):
        """å®‰å…¨åœ°é—œé–‰åºåˆ—åŸ å’Œè®€å–åŸ·è¡Œç·’ã€‚"""
        if self.read_thread and self.read_thread.is_alive():
            self.exit_signal.set()
            self.read_thread.join(timeout=1)
        if self.ser and self.ser.is_open:
            self.ser.close()
            print(f"åºåˆ—åŸ  {self.port_name} å·²å®‰å…¨é—œé–‰ã€‚")
        self.is_connected = False

================================================================================
--- FILE: simulation.py ---
---------------------------

# simulation.py
import mujoco
import glfw
import sys
import numpy as np
from typing import TYPE_CHECKING
import os

from config import AppConfig
from state import SimulationState, TuningParams

if TYPE_CHECKING:
    from rendering import DebugOverlay
    from keyboard_input_handler import KeyboardInputHandler

class Simulation:
    """
    å°è£ MuJoCo æ¨¡æ“¬ã€GLFW è¦–çª—å’Œæ¸²æŸ“é‚è¼¯ã€‚
    æ–°å¢äº†å®Œæ•´çš„æ»‘é¼ è¦–è§’æ§åˆ¶åŠŸèƒ½ã€‚
    """
    def __init__(self, config: AppConfig):
        """åˆå§‹åŒ– MuJoCo æ¨¡å‹ã€è³‡æ–™ã€GLFW è¦–çª—ä»¥åŠæ»‘é¼ æ§åˆ¶ç›¸é—œç‹€æ…‹ã€‚"""
        self.config = config
        
        try:
            with open(config.mujoco_model_file, 'r', encoding='utf-8') as f:
                xml_string = f.read()
            corrected_xml_string = xml_string.replace('meshdir="assets"', 'meshdir="mesh"')
            
            self.model = mujoco.MjModel.from_xml_string(corrected_xml_string)
            print(f"âœ… XML '{config.mujoco_model_file}' å·²è¼‰å…¥ï¼Œä¸¦åœ¨åŸ·è¡Œæ™‚å°‡ meshdir å¾ 'assets' ä¿®æ­£ç‚º 'mesh'ã€‚")
            
            for i in range(self.model.nu):
                self.model.actuator_biastype[i] = mujoco.mjtBias.mjBIAS_AFFINE
            print("âœ… æ‰€æœ‰è‡´å‹•å™¨çš„æ¨¡å¼å·²åœ¨åŸ·è¡Œæ™‚è¢«å¼·åˆ¶è¨­ç‚º AFFINEï¼Œä»¥å•Ÿç”¨ Python ç«¯çš„ PD æ§åˆ¶ã€‚")
            
        except Exception as e:
            sys.exit(f"âŒ éŒ¯èª¤: ç„¡æ³•è¼‰å…¥æˆ–è™•ç† XML æª”æ¡ˆ '{config.mujoco_model_file}': {e}")
            
        self.data = mujoco.MjData(self.model)
        self.model.opt.timestep = config.physics_timestep

        self.torso_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, 'torso')
        if self.torso_id == -1:
            sys.exit("âŒ éŒ¯èª¤: åœ¨ XML ä¸­æ‰¾ä¸åˆ°åç‚º 'torso' çš„ bodyã€‚")
        
        home_key_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_KEY, 'home')
        if home_key_id != -1:
            self.default_pose = self.model.key_qpos[home_key_id][7:].copy()
        else:
            self.default_pose = np.zeros(config.num_motors)
            print("âš ï¸ è­¦å‘Š: åœ¨ XML ä¸­æœªæ‰¾åˆ°åç‚º 'home' çš„ keyframeï¼Œå°‡ä½¿ç”¨é›¶ä½œç‚ºé è¨­å§¿æ…‹ã€‚")

        if not glfw.init(): sys.exit("âŒ éŒ¯èª¤: GLFW åˆå§‹åŒ–å¤±æ•—ã€‚")
        self.window = glfw.create_window(1200, 900, "MuJoCo æ¨¡æ“¬å™¨ (å«æ»‘é¼ æ§åˆ¶)", None, None)
        if not self.window:
            glfw.terminate()
            sys.exit("âŒ éŒ¯èª¤: GLFW è¦–çª—å»ºç«‹å¤±æ•—ã€‚")
        glfw.make_context_current(self.window)
        glfw.swap_interval(1)

        self.mouse_button_left = False
        self.mouse_button_right = False
        self.last_mouse_x = 0
        self.last_mouse_y = 0

        self.cam = mujoco.MjvCamera()
        self.opt = mujoco.MjvOption()
        mujoco.mjv_defaultCamera(self.cam)
        mujoco.mjv_defaultOption(self.opt)
        self.cam.distance, self.cam.elevation, self.cam.azimuth = 2.5, -20, 90
        
        self.scene = mujoco.MjvScene(self.model, maxgeom=10000)
        self.context = mujoco.MjrContext(self.model, mujoco.mjtFontScale.mjFONTSCALE_100)
        
        glfw.set_cursor_pos_callback(self.window, self._mouse_move_callback)
        glfw.set_mouse_button_callback(self.window, self._mouse_button_callback)
        glfw.set_scroll_callback(self.window, self._scroll_callback)

        print("âœ… MuJoCo æ¨¡æ“¬ç’°å¢ƒèˆ‡è¦–çª—åˆå§‹åŒ–å®Œæˆ (å«æ»‘é¼ æ§åˆ¶)ã€‚")

    def _mouse_button_callback(self, window, button, action, mods):
        if button == glfw.MOUSE_BUTTON_LEFT:
            if action == glfw.PRESS:
                self.mouse_button_left = True
                self.last_mouse_x, self.last_mouse_y = glfw.get_cursor_pos(window)
            elif action == glfw.RELEASE:
                self.mouse_button_left = False
        elif button == glfw.MOUSE_BUTTON_RIGHT:
            if action == glfw.PRESS:
                self.mouse_button_right = True
                self.last_mouse_x, self.last_mouse_y = glfw.get_cursor_pos(window)
            elif action == glfw.RELEASE:
                self.mouse_button_right = False

    def _mouse_move_callback(self, window, xpos, ypos):
        if not (self.mouse_button_left or self.mouse_button_right):
            return
        dx = xpos - self.last_mouse_x
        dy = ypos - self.last_mouse_y
        self.last_mouse_x = xpos
        self.last_mouse_y = ypos
        width, height = glfw.get_window_size(window)
        action_type = None
        if self.mouse_button_right: action_type = mujoco.mjtMouse.mjMOUSE_MOVE_H
        elif self.mouse_button_left: action_type = mujoco.mjtMouse.mjMOUSE_ROTATE_H
        if action_type: mujoco.mjv_moveCamera(self.model, action_type, dx / height, dy / height, self.scene, self.cam)

    def _scroll_callback(self, window, xoffset, yoffset):
        mujoco.mjv_moveCamera(self.model, mujoco.mjtMouse.mjMOUSE_ZOOM, 0, -0.05 * yoffset, self.scene, self.cam)

    def register_callbacks(self, keyboard_handler: "KeyboardInputHandler"):
        keyboard_handler.register_callbacks(self.window)

    def reset(self):
        mujoco.mj_resetData(self.model, self.data)
        mujoco.mj_forward(self.model, self.data)
        print("âœ… MuJoCo æ¨¡æ“¬å·²é‡ç½®ã€‚")

    def should_close(self) -> bool:
        return glfw.window_should_close(self.window)
        
    def apply_position_control(self, target_pos: np.ndarray, params: TuningParams):
        self.model.actuator_gainprm[:, 0] = params.kp
        self.model.actuator_biasprm[:, 1] = -params.kp
        self.model.actuator_biasprm[:, 2] = -params.kd
        self.data.ctrl[:] = target_pos
        force_bias = np.full(self.config.num_motors, params.bias)
        self.data.qfrc_applied[6:] = force_bias

    def step(self, state: SimulationState):
        while self.data.time < state.control_timer:
            mujoco.mj_step(self.model, self.data)

    def render(self, state: SimulationState, overlay: "DebugOverlay"):
        if state.control_mode != "SERIAL_MODE":
            if not (self.mouse_button_left or self.mouse_button_right):
                 self.cam.lookat = self.data.body('torso').xpos
        
        viewport = mujoco.MjrRect(0, 0, *glfw.get_framebuffer_size(self.window))
        
        terrain_manager = getattr(state, 'terrain_manager_ref', None)
        if terrain_manager and terrain_manager.needs_scene_update:
            # =========================================================================
            # === ã€æ ¸å¿ƒä¿®å¾©ã€‘èª¿æ› mjr_uploadHField çš„å‰å…©å€‹åƒæ•¸é †åº             ===
            # =========================================================================
            # æ­£ç¢ºé †åº: (model, context, hfield_id)
            mujoco.mjr_uploadHField(self.model, self.context, terrain_manager.hfield_id)
            terrain_manager.needs_scene_update = False
            print("ğŸ”„ åœ°å½¢å¹¾ä½•å·²ä¸Šå‚³è‡³ GPU é€²è¡Œæ¸²æŸ“ã€‚")
            # =========================================================================
        
        if state.control_mode != "SERIAL_MODE":
            mujoco.mjv_updateScene(self.model, self.data, self.opt, None, self.cam, mujoco.mjtCatBit.mjCAT_ALL, self.scene)
            mujoco.mjr_render(viewport, self.scene, self.context)
        
        overlay.render(viewport, self.context, state, self)
        
        glfw.swap_buffers(self.window)
        glfw.poll_events()
        
    def close(self):
        glfw.terminate()

================================================================================
--- FILE: state.py ---
----------------------

# state.py
from __future__ import annotations
import numpy as np
from dataclasses import dataclass, field
from config import AppConfig
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from floating_controller import FloatingController
    from policy import ONNXPolicy

@dataclass
class TuningParams:
    """ç”¨æ–¼å³æ™‚èª¿æ•´æ©Ÿå™¨äººæ§åˆ¶åƒæ•¸çš„é¡åˆ¥ã€‚"""
    kp: float
    kd: float
    action_scale: float
    bias: float

@dataclass
class SimulationState:
    """ç®¡ç†æ‰€æœ‰æ¨¡æ“¬ä¸­å‹•æ…‹è®ŠåŒ–çš„ç‹€æ…‹ï¼Œå–ä»£ global è®Šæ•¸ã€‚"""
    config: AppConfig
    command: np.ndarray = field(default_factory=lambda: np.zeros(3, dtype=np.float32))
    tuning_params: TuningParams = field(init=False)
    
    hard_reset_requested: bool = False
    soft_reset_requested: bool = False

    control_timer: float = 0.0
    
    sim_mode_text: str = "Initializing"
    input_mode: str = "KEYBOARD"
    control_mode: str = "WALKING"

    latest_onnx_input: np.ndarray = field(default_factory=lambda: np.array([]))
    latest_action_raw: np.ndarray = field(default_factory=lambda: np.zeros(12))
    latest_final_ctrl: np.ndarray = field(default_factory=lambda: np.zeros(12))
    latest_pos: np.ndarray = field(default_factory=lambda: np.zeros(3))
    latest_quat: np.ndarray = field(default_factory=lambda: np.array([1., 0., 0., 0.]))
    display_page: int = 0
    num_display_pages: int = 2

    serial_command_buffer: str = ""
    serial_command_to_send: str = ""
    serial_latest_messages: list = field(default_factory=list)

    joint_test_index: int = 0
    joint_test_offsets: np.ndarray = field(default_factory=lambda: np.zeros(12))

    manual_ctrl_index: int = 0
    manual_final_ctrl: np.ndarray = field(default_factory=lambda: np.zeros(12))
    manual_mode_is_floating: bool = False

    serial_is_connected: bool = False
    gamepad_is_connected: bool = False

    tuning_param_index: int = 0

    floating_controller_ref: 'FloatingController' = None
    policy_ref: 'ONNXPolicy' = None

    single_step_mode: bool = False
    execute_one_step: bool = False

    def __post_init__(self):
        """åœ¨åˆå§‹åŒ–å¾Œï¼Œæ ¹æ“šè¨­å®šæª”è¨­å®šåˆå§‹å€¼ã€‚"""
        self.tuning_params = TuningParams(**self.config.initial_tuning_params.__dict__)
        self.latest_action_raw = np.zeros(self.config.num_motors)
        self.latest_final_ctrl = np.zeros(self.config.num_motors)
        self.manual_final_ctrl = np.zeros(self.config.num_motors)
        print("âœ… SimulationState åˆå§‹åŒ–å®Œæˆã€‚")

    def reset_control_state(self, sim_time: float):
        self.control_timer = sim_time
        print("âœ… æ§åˆ¶ç‹€æ…‹å·²é‡ç½®ã€‚")

    def clear_command(self):
        self.command.fill(0.0)
        print("é‹å‹•æŒ‡ä»¤å·²æ¸…é™¤ã€‚")

    def toggle_input_mode(self, new_mode: str):
        if self.input_mode != new_mode:
            self.input_mode = new_mode
            self.clear_command()
            print(f"è¼¸å…¥æ¨¡å¼å·²åˆ‡æ›è‡³: {self.input_mode}")
            
    def set_control_mode(self, new_mode: str):
        """åˆ‡æ›ä¸»æ§åˆ¶æ¨¡å¼ï¼Œä¸¦å‘¼å«å°æ‡‰çš„å•Ÿç”¨/ç¦ç”¨å‡½å¼ã€‚"""
        if self.control_mode == new_mode: return

        old_mode = self.control_mode
        
        # --- é›¢é–‹èˆŠæ¨¡å¼æ™‚çš„æ¸…ç†å·¥ä½œ ---
        if old_mode == "FLOATING":
            if self.floating_controller_ref: self.floating_controller_ref.disable()
        elif old_mode == "MANUAL_CTRL" and self.manual_mode_is_floating:
             if self.floating_controller_ref: self.floating_controller_ref.disable()
             self.manual_mode_is_floating = False
        
        self.control_mode = new_mode
        print(f"æ§åˆ¶æ¨¡å¼å·²åˆ‡æ›è‡³: {self.control_mode}")

        # --- é€²å…¥æ–°æ¨¡å¼æ™‚çš„è¨­å®šå·¥ä½œ ---
        if new_mode == "FLOATING":
            if self.floating_controller_ref: self.floating_controller_ref.enable(self.latest_pos)
        elif new_mode == "JOINT_TEST":
            self.joint_test_offsets.fill(0.0)
        elif new_mode == "MANUAL_CTRL":
            self.manual_final_ctrl[:] = self.latest_final_ctrl

        # --- ã€æ ¸å¿ƒã€‘æ¨¡å¼åˆ‡æ›ç©©å®šæ€§ä¿®å¾© ---
        # å¦‚æœæ˜¯å¾æ‰‹å‹•æ¨¡å¼åˆ‡æ›å› AI æ¨¡å¼
        is_entering_ai_mode = new_mode in ["WALKING", "FLOATING"]
        is_leaving_manual_mode = old_mode in ["JOINT_TEST", "MANUAL_CTRL"]
        
        if is_entering_ai_mode and is_leaving_manual_mode:
            print("å¾æ‰‹å‹•æ¨¡å¼è¿”å›ï¼Œæ­£åœ¨é‡ç½® AI ç‹€æ…‹ä»¥ç¢ºä¿å¹³æ»‘éæ¸¡...")
            if self.policy_ref:
                self.policy_ref.reset()
            self.clear_command()

================================================================================
--- FILE: terrain_manager.py ---
--------------------------------

# terrain_manager.py
import mujoco
import numpy as np

class TerrainManager:
    """
    ç®¡ç†å’Œå‹•æ…‹åˆ‡æ› MuJoCo é«˜åº¦å ´ (hfield) åœ°å½¢ã€‚
    """
    def __init__(self, model, data):
        self.model = model
        self.data = data
        self.hfield_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_HFIELD, 'terrain')
        
        self.needs_scene_update = False
        
        if self.hfield_id == -1:
            print("âŒ éŒ¯èª¤: åœ¨ XML ä¸­æ‰¾ä¸åˆ°åç‚º 'terrain' çš„ hfieldã€‚åœ°å½¢åˆ‡æ›åŠŸèƒ½å°‡è¢«ç¦ç”¨ã€‚")
            self.is_functional = False
            return

        self.nrow = model.hfield_nrow[self.hfield_id]
        self.ncol = model.hfield_ncol[self.hfield_id]
        self.size = model.hfield_size[self.hfield_id]
        self.adr = model.hfield_adr[self.hfield_id]
        
        self.terrains = {
            "Flat": self.generate_flat,
            "Sine Waves": self.generate_sine_waves,
            "Steps": self.generate_steps,
            "Random Noise": self.generate_random_noise
        }
        self.terrain_names = list(self.terrains.keys())
        self.current_terrain_index = 0
        self.is_functional = True
        
        self.switch_terrain(0)
        print("âœ… åœ°å½¢ç®¡ç†å™¨åˆå§‹åŒ–å®Œæˆ (ä½¿ç”¨é«˜åº¦å ´)ã€‚")

    def generate_flat(self):
        return np.zeros((self.nrow, self.ncol))

    def generate_sine_waves(self):
        x = np.linspace(0, 2 * np.pi, self.ncol)
        y = np.linspace(0, 2 * np.pi, self.nrow)
        X, Y = np.meshgrid(x, y)
        return 0.05 * (np.sin(X * 3) + np.sin(Y * 2))

    def generate_steps(self):
        hfield = np.zeros((self.nrow, self.ncol))
        step_height = 0.03
        step_width = self.nrow // 10
        for i in range(10):
            hfield[i*step_width:(i+1)*step_width, :] = i * step_height
        return hfield

    def generate_random_noise(self):
        return np.random.rand(self.nrow, self.ncol) * 0.05

    def cycle_terrain(self):
        if not self.is_functional: return
        self.current_terrain_index = (self.current_terrain_index + 1) % len(self.terrain_names)
        self.switch_terrain(self.current_terrain_index)

    def get_current_terrain_name(self):
        if not self.is_functional: return "N/A (hfield missing)"
        return self.terrain_names[self.current_terrain_index]

    def switch_terrain(self, index):
        if not self.is_functional: return
        
        terrain_name = self.terrain_names[index]
        print(f"ğŸï¸ åˆ‡æ›åœ°å½¢è‡³: {terrain_name}")
        
        generator = self.terrains[terrain_name]
        hfield_data = generator()
        
        self.model.hfield_data[self.adr:self.adr + self.nrow*self.ncol] = hfield_data.flatten()
        
        self.needs_scene_update = True

================================================================================
--- FILE: tree_structure.txt ---
--------------------------------

RQxx@S  W i n d o w s   vÇŒe>Y  P A T H 
 
 xx@S^_p  D 6 5 2 - B 1 0 3 
 
 C : . 
 
 |       c o n f i g . p y 
 
 |       c o n f i g . y a m l 
 
 |       d u m p _ p r o j e c t . p y 
 
 |       f l o a t i n g _ c o n t r o l l e r . p y 
 
 |       k e y b o a r d _ i n p u t _ h a n d l e r . p y 
 
 |       m a i n . p y 
 
 |       o b s e r v a t i o n . p y 
 
 |       p o l i c y . p y 
 
 |       p r o j e c t _ d u m p . t x t 
 
 |       r e a d m e . m d 
 
 |       r e n d e r i n g . p y 
 
 |       s e r i a l _ c o m m u n i c a t o r . p y 
 
 |       s i m u l a t i o n . p y 
 
 |       s t a t e . p y 
 
 |       t e s t _ j o y s t i c k . p y 
 
 |       t r e e _ s t r u c t u r e . t x t 
 
 |       v e r i f y _ m o d e l _ m o d e . p y 
 
 |       x b o x _ c o n t r o l l e r . p y 
 
 |       x b o x _ i n p u t _ h a n d l e r . p y 
 
 |       
 
 + - - - . v s c o d e 
 
 + - - - a s s e t s 
 
 |       |       p u p p e r . x m l 
 
 |       |       p u p p e r _ m j x . x m l 
 
 |       |       p u p p e r _ m j x _ 1 . x m l 
 
 |       |       s c e n e . x m l 
 
 |       |       s c e n e _ m j x . x m l 
 
 |       |       
 
 |       \ - - - m e s h 
 
 |                       b o d y . s t l 
 
 |                       H i p _ L . s t l 
 
 |                       H i p _ R . s t l 
 
 |                       L o w e r _ L e g _ L . s t l 
 
 |                       L o w e r _ L e g _ R . s t l 
 
 |                       U p p e r _ L e g _ L . s t l 
 
 |                       U p p e r _ L e g _ R . s t l 
 
 |                       
 
 + - - - m o d e l s 
 
 |               p u p p e r _ p p o _ p o l i c y _ 2 0 0 5 4 0 1 6 0 _ t f _ c o n v e r t e d . o n n x 
 
 |               p u p p e r _ p p o _ p o l i c y _ 3 0 9 6 5 7 6 0 _ t f _ c o n v e r t e d _ iz[ekKaHr. o n n x 
 
 |               p u p p e r _ p p o _ p o l i c y _ 3 0 9 6 5 7 6 0 _ t f _ c o n v e r t e d _ iz[ekKaHr. o p t i m i z e d . o r t 
 
 |               
 
 \ - - - _ _ p y c a c h e _ _ 
 
                 c o n f i g . c p y t h o n - 3 1 1 . p y c 
 
                 c o n f i g . c p y t h o n - 3 1 2 . p y c 
 
                 f l o a t i n g _ c o n t r o l l e r . c p y t h o n - 3 1 2 . p y c 
 
                 i n p u t _ h a n d l e r . c p y t h o n - 3 1 1 . p y c 
 
                 i n p u t _ h a n d l e r . c p y t h o n - 3 1 2 . p y c 
 
                 k e y b o a r d _ i n p u t _ h a n d l e r . c p y t h o n - 3 1 2 . p y c 
 
                 o b s e r v a t i o n . c p y t h o n - 3 1 1 . p y c 
 
                 o b s e r v a t i o n . c p y t h o n - 3 1 2 . p y c 
 
                 p o l i c y . c p y t h o n - 3 1 1 . p y c 
 
                 p o l i c y . c p y t h o n - 3 1 2 . p y c 
 
                 r e n d e r i n g . c p y t h o n - 3 1 1 . p y c 
 
                 r e n d e r i n g . c p y t h o n - 3 1 2 . p y c 
 
                 s e r i a l _ c o m m u n i c a t o r . c p y t h o n - 3 1 2 . p y c 
 
                 s i m u l a t i o n . c p y t h o n - 3 1 1 . p y c 
 
                 s i m u l a t i o n . c p y t h o n - 3 1 2 . p y c 
 
                 s t a t e . c p y t h o n - 3 1 1 . p y c 
 
                 s t a t e . c p y t h o n - 3 1 2 . p y c 
 
                 x b o x _ c o n t r o l l e r . c p y t h o n - 3 1 2 . p y c 
 
                 x b o x _ i n p u t _ h a n d l e r . c p y t h o n - 3 1 2 . p y c 
 
                 
 
 

================================================================================
--- FILE: xbox_controller.py ---
--------------------------------

# xbox_controller.py
import pygame

class XboxController:
    """
    ä¸€å€‹ä½¿ç”¨ Pygame å‡½å¼åº«ä¾†è®€å– Xbox æ–æ¡¿è¼¸å…¥çš„é¡åˆ¥ã€‚
    é€™å€‹ç‰ˆæœ¬æ˜¯éé˜»å¡çš„ï¼Œå¯ä»¥å®‰å…¨åœ°åœ¨ä¸»è¿´åœˆä¸­æ›´æ–°ã€‚
    """
    def __init__(self):
        """åˆå§‹åŒ– Pygame ä½†ä¸ç«‹å³æƒææ–æ¡¿ã€‚"""
        pygame.init()
        self.joystick = None
        self.deadzone = 0.15
        self.state = {
            'left_analog_x': 0.0, 'left_analog_y': 0.0,
            'right_analog_x': 0.0, 'right_analog_y': 0.0,
            'dpad': (0, 0),
            'button_a': 0, 'button_b': 0, 'button_x': 0, 'button_y': 0,
            'button_l1': 0, 'button_r1': 0,
            'button_select': 0, 'button_start': 0,
        }
        print("âœ… XBox æ§åˆ¶å™¨å·²åˆå§‹åŒ– (ç­‰å¾…é€£æ¥æŒ‡ä»¤)ã€‚")

    def scan_and_connect(self) -> bool:
        """æƒæä¸¦é€£æ¥åˆ°ç¬¬ä¸€å€‹å¯ç”¨çš„æ–æ¡¿ã€‚"""
        if self.is_connected():
            print("æ–æ¡¿å·²é€£æ¥ï¼Œç„¡éœ€é‡æ–°æƒæã€‚")
            return True

        print("\n" + "="*20 + " æ­£åœ¨æƒææ–æ¡¿ " + "="*20)
        pygame.joystick.init() # æ¯æ¬¡æƒææ™‚é‡æ–°åˆå§‹åŒ–
        
        if pygame.joystick.get_count() > 0:
            self.joystick = pygame.joystick.Joystick(0)
            self.joystick.init()
            print(f"âœ… æˆåŠŸé€£æ¥åˆ°æ–æ¡¿: {self.joystick.get_name()}")
            return True
        else:
            print("--- æœªåµæ¸¬åˆ°ä»»ä½•æ–æ¡¿ ---")
            self.joystick = None
            return False

    def is_connected(self) -> bool:
        """æª¢æŸ¥æ–æ¡¿æ˜¯å¦å·²æˆåŠŸåˆå§‹åŒ–ã€‚"""
        return self.joystick is not None

    def update(self):
        """è™•ç† Pygame äº‹ä»¶ä½‡åˆ—ï¼Œæ›´æ–°æ–æ¡¿ç‹€æ…‹ã€‚"""
        if not self.is_connected():
            return
            
        for event in pygame.event.get():
            if event.type == pygame.JOYAXISMOTION:
                if event.axis == 0: self.state['left_analog_x'] = event.value
                elif event.axis == 1: self.state['left_analog_y'] = event.value
                elif event.axis == 2: self.state['right_analog_x'] = event.value
                elif event.axis == 3: self.state['right_analog_y'] = event.value
            elif event.type == pygame.JOYBUTTONDOWN:
                if event.button == 0: self.state['button_a'] = 1
                elif event.button == 1: self.state['button_b'] = 1
                elif event.button == 2: self.state['button_x'] = 1
                elif event.button == 3: self.state['button_y'] = 1
                elif event.button == 4: self.state['button_l1'] = 1
                elif event.button == 5: self.state['button_r1'] = 1
                elif event.button == 6: self.state['button_select'] = 1
                elif event.button == 7: self.state['button_start'] = 1
            elif event.type == pygame.JOYBUTTONUP:
                if event.button == 0: self.state['button_a'] = 0
                elif event.button == 1: self.state['button_b'] = 0
                elif event.button == 2: self.state['button_x'] = 0
                elif event.button == 3: self.state['button_y'] = 0
                elif event.button == 4: self.state['button_l1'] = 0
                elif event.button == 5: self.state['button_r1'] = 0
                elif event.button == 6: self.state['button_select'] = 0
                elif event.button == 7: self.state['button_start'] = 0
            elif event.type == pygame.JOYHATMOTION:
                self.state['dpad'] = event.value

    def get_input(self) -> dict:
        """ç²å–ç•¶å‰æ–æ¡¿ç‹€æ…‹çš„æ·ºæ‹·è²ï¼Œä¸¦æ‡‰ç”¨æ­»å€ã€‚"""
        for axis in ['left_analog_x', 'left_analog_y', 'right_analog_x', 'right_analog_y']:
            if abs(self.state[axis]) < self.deadzone:
                self.state[axis] = 0.0
        return self.state.copy()

    def close(self):
        """é—œé–‰ Pygameã€‚"""
        pygame.quit()

================================================================================
--- FILE: xbox_input_handler.py ---
-----------------------------------

# xbox_input_handler.py
from state import SimulationState
from xbox_controller import XboxController

class XboxInputHandler:
    """
    è™•ç† Xbox æ–æ¡¿çš„è¼¸å…¥ï¼Œä¸¦å°‡å…¶è½‰æ›ç‚ºå° SimulationState çš„æ›´æ–°ã€‚
    """
    def __init__(self, state: SimulationState):
        """åˆå§‹åŒ– XboxInputHandlerã€‚"""
        self.state = state
        self.config = state.config
        self.controller = XboxController()
        self.last_input_state = {}
        self.param_keys = ['kp', 'kd', 'action_scale', 'bias']
        self.num_params = len(self.param_keys)
    
    def scan_and_connect(self) -> bool:
        """å‘¼å«åº•å±¤æ§åˆ¶å™¨é€²è¡Œæƒæå’Œé€£æ¥ã€‚"""
        is_success = self.controller.scan_and_connect()
        if is_success:
            self.state.toggle_input_mode("GAMEPAD")
        return is_success

    def is_available(self) -> bool:
        """æª¢æŸ¥æ–æ¡¿æ˜¯å¦å·²æˆåŠŸåˆå§‹åŒ–ä¸¦é€£æ¥ã€‚"""
        return self.controller.is_connected()

    def update_state(self):
        """å¾æ–æ¡¿è®€å–è¼¸å…¥ä¸¦æ›´æ–° SimulationStateã€‚"""
        if not self.is_available():
            if self.state.input_mode == "GAMEPAD":
                print("ğŸ® æ–æ¡¿å·²æ–·é–‹ï¼Œè‡ªå‹•åˆ‡æ›å›éµç›¤æ¨¡å¼ã€‚")
                self.state.toggle_input_mode("KEYBOARD")
                self.state.gamepad_is_connected = False
            return

        self.controller.update() 
        current_input = self.controller.get_input()
        
        self.state.command[0] = current_input['left_analog_x'] * self.config.gamepad_sensitivity['vy']
        self.state.command[1] = current_input['left_analog_y'] * self.config.gamepad_sensitivity['vx'] * -1
        self.state.command[2] = current_input['right_analog_x'] * self.config.gamepad_sensitivity['wz']

        if current_input['button_select'] and not self.last_input_state.get('button_select', 0):
            self.state.hard_reset_requested = True
            
        if current_input['button_l1'] and not self.last_input_state.get('button_l1', 0):
            self.state.tuning_param_index = (self.state.tuning_param_index - 1) % self.num_params
        
        if current_input['button_r1'] and not self.last_input_state.get('button_r1', 0):
            self.state.tuning_param_index = (self.state.tuning_param_index + 1) % self.num_params

        dpad_y = current_input['dpad'][1]
        last_dpad_y = self.last_input_state.get('dpad', (0,0))[1]

        if dpad_y != last_dpad_y:
            param_to_adjust = self.param_keys[self.state.tuning_param_index]
            step = self.config.param_adjust_steps.get(param_to_adjust, 0.1)
            current_value = getattr(self.state.tuning_params, param_to_adjust)

            if dpad_y == 1:
                setattr(self.state.tuning_params, param_to_adjust, current_value + step)
            elif dpad_y == -1:
                setattr(self.state.tuning_params, param_to_adjust, current_value - step)
        
        self.last_input_state = current_input
        
        self.state.tuning_params.kp = max(0, self.state.tuning_params.kp)
        self.state.tuning_params.kd = max(0, self.state.tuning_params.kd)
        self.state.tuning_params.action_scale = max(0, self.state.tuning_params.action_scale)

    def close(self):
        """é—œé–‰æ–æ¡¿é€£æ¥ã€‚"""
        if self.controller:
            self.controller.close()

================================================================================
--- FILE: assets/pupper.xml ---
-------------------------------

<!-- 
  Pupper Model - Final Corrected Version
-->
<mujoco model="pupper_env">
    <compiler angle="radian" autolimits="true"/>

    <option timestep="0.001" gravity="0 0 -9.81" 
            iterations="5" ls_iterations="10" noslip_iterations="2">
        <flag eulerdamp="disable"/>
    </option>

    <default>
        <default class="pupper">
            <joint armature="0.01" damping="0.5239" solimplimit="0.9 0.99 0.001" solreflimit="0.02 1"/>
            <geom type="mesh" contype="0" conaffinity="0" rgba="0.8 0.6 .4 1"/>
            <general biastype="affine" gainprm="35.0 0 0" biasprm="0 -35.0 0"/>
            <default class="pupper/collision/foot">
                <geom type="sphere" 
                      contype="1" conaffinity="1" 
                      group="3"
                      friction="1.0 0.2 0.1" 
                      solimp="0.9 0.99 0.001" 
                      solref="0.02 1"
                      rgba="1 0 0 1"/>
            </default>
        </default>
    </default>

    <asset>
        <mesh name="body" file="mesh/body.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Hip_L" file="mesh/Hip_L.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Hip_R" file="mesh/Hip_R.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Upper_Leg_L" file="mesh/Upper_Leg_L.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Upper_Leg_R" file="mesh/Upper_Leg_R.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Lower_Leg_L" file="mesh/Lower_Leg_L.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Lower_Leg_R" file="mesh/Lower_Leg_R.stl" scale="0.001 0.001 0.001"/>
    </asset>

    <worldbody>
        <body name="torso" pos="0 0 0.2" childclass="pupper">
            <freejoint name="root"/>
            <camera name="track" pos="1.958 -2.348 0.591" xyaxes="0.768 0.641 0.000 -0.101 0.122 0.987" mode="trackcom"/>
            <inertial pos="0.00109 -0.074 0" mass="0.7833" diaginertia="0.0003688 0.002508 0.002674"/>
            <geom name="torso_geom" mesh="body"/>
            <site name="imu_frame" pos="0 0 0" size="0.01" type="sphere" rgba="1 0 0 0.5"/>

            <!-- ==================== Front-Right Leg ==================== -->
            <body name="leg_front_right" pos="-0.046891 -0.203946 -0.0064">
                <inertial pos="0 0 0" mass="0.1081" diaginertia="3.698e-05 7.127e-06 4.075e-05"/>
                <joint name="abduction_front_right" type="hinge" axis="0 1 0" pos="0 0 0" range="-1.0472 1.0472"/>
                <geom name="fr_block_geom" mesh="Hip_R"/>
                <body name="upper_leg_front_right" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
                    <inertial pos="0 0 0" mass="0.1321" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                    <joint name="hip_front_right" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.76166 3.81442"/>
                    <geom name="fr_geom" mesh="Upper_Leg_R"/>
                    <body name="lower_leg_front_right" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
                        <inertial pos="0 0 0" mass="0.1036" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                        <joint name="knee_front_right" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.78540 1.65806"/>
                        <geom name="fr_l2_geom" mesh="Lower_Leg_R"/>
                        
                        <!-- FINAL FIX: å°‡ site çš„åå­—æ”¹å› "foot_front_right"ï¼Œä»¥åŒ¹é… Python ç’°å¢ƒçš„éœ€æ±‚ã€‚-->
                        <site name="foot_front_right" pos="0.003475 0 -0.11" size="0.009525" type="sphere" rgba="0 1 0 0.5"/>
                        <geom name="foot_front_right_collision" class="pupper/collision/foot" 
                              pos="0.003475 0 -0.11" size="0.009525"/>
                    </body>
                </body>
            </body>
            
            <!-- ==================== Front-Left Leg ==================== -->
            <body name="leg_front_left" pos="0.047109 -0.203946 -0.0064">
                <inertial pos="0 0 0" mass="0.1081" diaginertia="3.698e-05 7.127e-06 4.075e-05"/>
                <joint name="abduction_front_left" type="hinge" axis="0 1 0" pos="0 0 0" range="-1.0472 1.0472"/>
                <geom name="fl_block_geom" mesh="Hip_L"/>
                <body name="upper_leg_front_left" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
                    <inertial pos="0 0 0" mass="0.1321" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                    <joint name="hip_front_left" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.76166 3.81442"/>
                    <geom name="fl_geom" mesh="Upper_Leg_L"/>
                    <body name="lower_leg_front_left" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
                        <inertial pos="0 0 0" mass="0.1036" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                        <joint name="knee_front_left" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.78540 1.65806"/>
                        <geom name="fl_l2_geom" mesh="Lower_Leg_L"/>
                        <site name="foot_front_left" pos="-0.003475 0 -0.11" size="0.009525" type="sphere" rgba="0 1 0 0.5"/>
                        <geom name="foot_front_left_collision" class="pupper/collision/foot" 
                              pos="-0.003475 0 -0.11" size="0.009525"/>
                    </body>
                </body>
            </body>
            
            <!-- ==================== Hind-Right Leg ==================== -->
            <body name="leg_hind_right" pos="-0.046896 -0.004096 -0.0064">
                <inertial pos="0 0 0" mass="0.1081" diaginertia="3.698e-05 7.127e-06 4.075e-05"/>
                <joint name="abduction_hind_right" type="hinge" axis="0 1 0" pos="0 0 0" range="-1.0472 1.0472"/>
                <geom name="br_block_geom" mesh="Hip_R"/>
                <body name="upper_leg_hind_right" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
                    <inertial pos="0 0 0" mass="0.1321" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                    <joint name="hip_hind_right" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.76166 3.81442"/>
                    <geom name="br_geom" mesh="Upper_Leg_R"/>
                    <body name="lower_leg_hind_right" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
                        <inertial pos="0 0 0" mass="0.1036" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                        <joint name="knee_hind_right" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.78540 1.65806"/>
                        <geom name="br_l2_geom" mesh="Lower_Leg_R"/>
                        <site name="foot_hind_right" pos="0.003475 0 -0.11" size="0.009525" type="sphere" rgba="0 1 0 0.5"/>
                        <geom name="foot_hind_right_collision" class="pupper/collision/foot" 
                              pos="0.003475 0 -0.11" size="0.009525"/>
                    </body>
                </body>
            </body>
            
            <!-- ==================== Hind-Left Leg ==================== -->
            <body name="leg_hind_left" pos="0.047104 -0.004096 -0.0064">
                <inertial pos="0 0 0" mass="0.1081" diaginertia="3.698e-05 7.127e-06 4.075e-05"/>
                <joint name="abduction_hind_left" type="hinge" axis="0 1 0" pos="0 0 0" range="-1.0472 1.0472"/>
                <geom name="bl_block_geom" mesh="Hip_L"/>
                <body name="upper_leg_hind_left" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
                    <inertial pos="0 0 0" mass="0.1321" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                    <joint name="hip_hind_left" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.76166 3.81442"/>
                    <geom name="bl_geom" mesh="Upper_Leg_L"/>
                    <body name="lower_leg_hind_left" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
                        <inertial pos="0 0 0" mass="0.1036" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                        <joint name="knee_hind_left" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.78540 1.65806"/>
                        <geom name="bl_l2_geom" mesh="Lower_Leg_L"/>
                        <site name="foot_hind_left" pos="-0.003475 0 -0.11" size="0.009525" type="sphere" rgba="0 1 0 0.5"/>
                        <geom name="foot_hind_left_collision" class="pupper/collision/foot" 
                              pos="-0.003475 0 -0.11" size="0.009525"/>
                    </body>
                </body>
            </body>
        </body>
    </worldbody>

    <actuator>
        <general class="pupper" joint="abduction_front_right"/>
        <general class="pupper" joint="hip_front_right"/>
        <general class="pupper" joint="knee_front_right"/>
        <general class="pupper" joint="abduction_front_left"/>
        <general class="pupper" joint="hip_front_left"/>
        <general class="pupper" joint="knee_front_left"/>
        <general class="pupper" joint="abduction_hind_right"/>
        <general class="pupper" joint="hip_hind_right"/>
        <general class="pupper" joint="knee_hind_right"/>
        <general class="pupper" joint="abduction_hind_left"/>
        <general class="pupper" joint="hip_hind_left"/>
        <general class="pupper" joint="knee_hind_left"/>
    </actuator>
    
    <sensor>
        <!-- Sensor section remains unchanged -->
    </sensor>

    <keyframe>
        <key name="home"
            qpos="0 0 0.2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"
            ctrl="0 0 0 0 0 0 0 0 0 0 0 0" />
    </keyframe>
</mujoco>

================================================================================
--- FILE: assets/pupper_mjx.xml ---
-----------------------------------

<!-- =================================================================
     Pupper Model - Final Version with Global PD(Kp, Kv) Settings
     ================================================================= -->
<mujoco model="pupper_global_pd">
  <compiler angle="radian" meshdir="assets/mesh" autolimits="true"/> <!-- assets to assets/mesh -->
  <option iterations="1" ls_iterations="5" timestep="0.004" integrator="Euler">
    <flag eulerdamp="disable"/>
  </option>
  <custom>
    <numeric data="30" name="max_contact_points"/>
    <numeric data="12" name="max_geom_pairs"/>
  </custom>

  <!-- [MODIFIED] All physical and control parameters are now globally defined here -->
  <default>
    <default class="pupper">
      <!-- 1. Global physical properties for ALL joints -->
      <joint armature="0.005" damping="0.1" frictionloss="0.2"/>
      
      <!-- 2. Global controller template for ALL position actuators -->
      <!--    kp and kv are placeholders to be modified by the Python script -->
      <general gainprm="0.333" ctrlrange="-5.0 5.0" gear="1" biastype="none"/>


      <!-- Joint-specific kinematics -->
      <default class="abduction">
        <joint axis="0 1 0" range="-1.0472 1.0472"/>
      </default>
      <default class="hip">
        <joint axis="1 0 0" range="-0.76166 3.81442"/>
      </default>
      <default class="knee">
        <joint axis="1 0 0" range="-0.78540 1.65806"/>
      </default>
      
      <!-- Visual and collision definitions -->
      <default class="visual"> <geom type="mesh" contype="0" conaffinity="0" group="2"/> </default>
      <default class="collision"> <geom group="3"/>
        <default class="foot"> <geom type="sphere" size="0.009525" solimp="0.9 .95 0.01" condim="3" friction="0.8 0.1 0.1"/> </default>
      </default>
    </default>
  </default>

  <!-- Assets and Worldbody remain the same -->
  <asset>
    <mesh name="body" file="body.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Hip_L" file="Hip_L.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Hip_R" file="Hip_R.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Upper_Leg_L" file="Upper_Leg_L.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Upper_Leg_R" file="Upper_Leg_R.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Lower_Leg_L" file="Lower_Leg_L.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Lower_Leg_R" file="Lower_Leg_R.stl" scale="0.001 0.001 0.001"/>
  </asset>

  <worldbody>
    <light name="spotlight" mode="targetbodycom" target="torso" pos="3 0 4"/>
    <body name="torso" pos="0 0 0.2" childclass="pupper">
      <camera name="track" pos="0.8 -1.0 0.5" xyaxes="0.707 0.707 0 -0.354 0.354 0.866" mode="trackcom"/>
      <site name="head" pos="0.15 0 0" rgba="1 0 0 1" size="0.02" group="5"/>
      <inertial pos="0 -0.048 -0.00964" mass="0.991" fullinertia="0.00626 0.00175 0.00678 2e-05 0 2e-05" />
      <freejoint/>
      <geom class="visual" mesh="body"/>
      <geom class="collision" type="box" size="0.06 0.11 0.03" pos="0 -0.07 0"/>
      <site name="imu" pos="0 -0.122542 0" size="0.01" group="5"/>
      <body name="FR_hip" pos="-0.046891 -0.203946 -0.0064">
        <inertial pos="0.0139 -0.0269 0" mass="0.106" diaginertia="2e-05 6e-05 6e-05" />
        <joint class="abduction" name="FR_hip_joint"/>
        <geom class="visual" mesh="Hip_R"/>
        <body name="FR_thigh" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
          <inertial pos="0.0172 0 -0.061" mass="0.142" diaginertia="0.00014 0.00016 3e-05" />
          <joint class="hip" name="FR_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_R"/>
          <body name="FR_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <inertial pos="-0.00588 -0.00075 -0.0658" mass="0.038" diaginertia="0.00018 0.00018 2e-05" />
            <joint class="knee" name="FR_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_R"/>
            <geom name="FR" class="foot" pos="0.003475 0 -0.11"/>
            <site name="FR" pos="0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
      <body name="FL_hip" pos="0.047109 -0.203946 -0.0064">
        <inertial pos="0.0139 0.0254 0" mass="0.106" diaginertia="2e-05 6e-05 6e-05" />
        <joint class="abduction" name="FL_hip_joint"/>
        <geom class="visual" mesh="Hip_L"/>
        <body name="FL_thigh" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
          <inertial pos="0.0172 0 -0.061" mass="0.142" diaginertia="0.00014 0.00016 3e-05" />
          <joint class="hip" name="FL_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_L"/>
          <body name="FL_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <inertial pos="0.00558 -0.00075 -0.0658" mass="0.038" diaginertia="0.00018 0.00018 2e-05" />
            <joint class="knee" name="FL_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_L"/>
            <geom name="FL" class="foot" pos="-0.003475 0 -0.11"/>
            <site name="FL" pos="-0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
      <body name="RR_hip" pos="-0.046896 -0.004096 -0.0064">
        <inertial pos="0.0139 -0.0269 0" mass="0.106" diaginertia="2e-05 6e-05 6e-05" />
        <joint class="abduction" name="RR_hip_joint"/>
        <geom class="visual" mesh="Hip_R"/>
        <body name="RR_thigh" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
          <inertial pos="0.0172 0 -0.061" mass="0.142" diaginertia="0.00014 0.00016 3e-05" />
          <joint class="hip" name="RR_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_R"/>
          <body name="RR_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <inertial pos="-0.00588 -0.00075 -0.0658" mass="0.038" diaginertia="0.00018 0.00018 2e-05" />
            <joint class="knee" name="RR_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_R"/>
            <geom name="RR" class="foot" pos="0.003475 0 -0.11"/>
            <site name="RR" pos="0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
      <body name="RL_hip" pos="0.047104 -0.004096 -0.0064">
        <inertial pos="0.0139 0.0254 0" mass="0.106" diaginertia="2e-05 6e-05 6e-05" />
        <joint class="abduction" name="RL_hip_joint"/>
        <geom class="visual" mesh="Hip_L"/>
        <body name="RL_thigh" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
          <inertial pos="0.0172 0 -0.061" mass="0.142" diaginertia="0.00014 0.00016 3e-05" />
          <joint class="hip" name="RL_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_L"/>
          <body name="RL_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <inertial pos="0.00558 -0.00075 -0.0658" mass="0.038" diaginertia="0.00018 0.00018 2e-05" />
            <joint class="knee" name="RL_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_L"/>
            <geom name="RL" class="foot" pos="-0.003475 0 -0.11"/>
            <site name="RL" pos="-0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
    </body>
  </worldbody>

  <actuator>
      <general name="FR_hip"   joint="FR_hip_joint"/>
      <general name="FR_thigh" joint="FR_thigh_joint"/>
      <general name="FR_calf"  joint="FR_calf_joint"/>
      <general name="FL_hip"   joint="FL_hip_joint"/>
      <general name="FL_thigh" joint="FL_thigh_joint"/>
      <general name="FL_calf"  joint="FL_calf_joint"/>
      <general name="RR_hip"   joint="RR_hip_joint"/>
      <general name="RR_thigh" joint="RR_thigh_joint"/>
      <general name="RR_calf"  joint="RR_calf_joint"/>
      <general name="RL_hip"   joint="RL_hip_joint"/>
      <general name="RL_thigh" joint="RL_thigh_joint"/>
      <general name="RL_calf"  joint="RL_calf_joint"/>
  </actuator>

  <!-- Sensors remain the same -->
  <sensor>
    <gyro site="imu" name="gyro"/>
    <velocimeter site="imu" name="local_linvel"/>
    <accelerometer site="imu" name="accelerometer"/>
    <framepos objtype="site" objname="imu" name="position"/>
    <framezaxis objtype="site" objname="imu" name="upvector"/>
    <framexaxis objtype="site" objname="imu" name="forwardvector"/>
    <framelinvel objtype="site" objname="imu" name="global_linvel"/>
    <frameangvel objtype="site" objname="imu" name="global_angvel"/>
    <framequat objtype="site" objname="imu" name="orientation"/>
    <framelinvel objtype="site" objname="FR" name="FR_global_linvel"/>
    <framelinvel objtype="site" objname="FL" name="FL_global_linvel"/>
    <framelinvel objtype="site" objname="RR" name="RR_global_linvel"/>
    <framelinvel objtype="site" objname="RL" name="RL_global_linvel"/>
    <framepos objtype="site" objname="FR" name="FR_pos" reftype="site" refname="imu"/>
    <framepos objtype="site" objname="FL" name="FL_pos" reftype="site" refname="imu"/>
    <framepos objtype="site" objname="RR" name="RR_pos" reftype="site" refname="imu"/>
    <framepos objtype="site" objname="RL" name="RL_pos" reftype="site" refname="imu"/>
    <framepos objtype="site" objname="head" name="head_pos"/>
  </sensor>
</mujoco>

================================================================================
--- FILE: assets/pupper_mjx_1.xml ---
-------------------------------------

<!-- =================================================================
     Pupper Model - Final Version with Global PD(Kp, Kv) Settings
     ================================================================= -->
<mujoco model="pupper_global_pd">
  <compiler angle="radian" meshdir="assets" autolimits="true"/>
  <option iterations="1" ls_iterations="5" timestep="0.004" integrator="Euler">
    <flag eulerdamp="disable"/>
  </option>
  <custom>
    <numeric data="30" name="max_contact_points"/>
    <numeric data="12" name="max_geom_pairs"/>
  </custom>

  <!-- [MODIFIED] All physical and control parameters are now globally defined here -->
  <default>
    <default class="pupper">
      <!-- 1. Global physical properties for ALL joints -->
      <joint armature="0.005" damping="0.1" frictionloss="0.2"/>
      
      <!-- 2. Global controller template for ALL position actuators -->
      <!--    kp and kv are placeholders to be modified by the Python script -->
      <general gainprm="0.333" ctrlrange="-5.0 5.0" gear="1" biastype="none"/>


      <!-- Joint-specific kinematics -->
      <default class="abduction">
        <joint axis="0 1 0" range="-1.0472 1.0472"/>
      </default>
      <default class="hip">
        <joint axis="1 0 0" range="-0.76166 3.81442"/>
      </default>
      <default class="knee">
        <joint axis="1 0 0" range="-0.78540 1.65806"/>
      </default>
      
      <!-- Visual and collision definitions -->
      <default class="visual"> <geom type="mesh" contype="0" conaffinity="0" group="2"/> </default>
      <default class="collision"> <geom group="3"/>
        <default class="foot"> <geom type="sphere" size="0.009525" solimp="0.9 .95 0.01" condim="3" friction="0.8 0.1 0.1"/> </default>
      </default>
    </default>
  </default>

  <!-- Assets and Worldbody remain the same -->
  <asset>
    <mesh name="body" file="body.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Hip_L" file="Hip_L.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Hip_R" file="Hip_R.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Upper_Leg_L" file="Upper_Leg_L.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Upper_Leg_R" file="Upper_Leg_R.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Lower_Leg_L" file="Lower_Leg_L.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Lower_Leg_R" file="Lower_Leg_R.stl" scale="0.001 0.001 0.001"/>
  </asset>

  <worldbody>
    <light name="spotlight" mode="targetbodycom" target="torso" pos="3 0 4"/>
    <body name="torso" pos="0 0 0.2" childclass="pupper">
      <camera name="track" pos="0.8 -1.0 0.5" xyaxes="0.707 0.707 0 -0.354 0.354 0.866" mode="trackcom"/>
      <site name="head" pos="0.15 0 0" rgba="1 0 0 1" size="0.02" group="5"/>
      <inertial pos="0 -0.048 -0.00964" mass="0.991" fullinertia="0.00626 0.00175 0.00678 2e-05 0 2e-05" />
      <freejoint/>
      <geom class="visual" mesh="body"/>
      <geom class="collision" type="box" size="0.06 0.11 0.03" pos="0 -0.07 0"/>
      <site name="imu" pos="0 -0.122542 0" size="0.01" group="5"/>
      <body name="FR_hip" pos="-0.046891 -0.203946 -0.0064">
        <inertial pos="0.0139 -0.0269 0" mass="0.106" diaginertia="2e-05 6e-05 6e-05" />
        <joint class="abduction" name="FR_hip_joint"/>
        <geom class="visual" mesh="Hip_R"/>
        <body name="FR_thigh" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
          <inertial pos="0.0172 0 -0.061" mass="0.142" diaginertia="0.00014 0.00016 3e-05" />
          <joint class="hip" name="FR_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_R"/>
          <body name="FR_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <inertial pos="-0.00588 -0.00075 -0.0658" mass="0.038" diaginertia="0.00018 0.00018 2e-05" />
            <joint class="knee" name="FR_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_R"/>
            <geom name="FR" class="foot" pos="0.003475 0 -0.11"/>
            <site name="FR" pos="0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
      <body name="FL_hip" pos="0.047109 -0.203946 -0.0064">
        <inertial pos="0.0139 0.0254 0" mass="0.106" diaginertia="2e-05 6e-05 6e-05" />
        <joint class="abduction" name="FL_hip_joint"/>
        <geom class="visual" mesh="Hip_L"/>
        <body name="FL_thigh" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
          <inertial pos="0.0172 0 -0.061" mass="0.142" diaginertia="0.00014 0.00016 3e-05" />
          <joint class="hip" name="FL_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_L"/>
          <body name="FL_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <inertial pos="0.00558 -0.00075 -0.0658" mass="0.038" diaginertia="0.00018 0.00018 2e-05" />
            <joint class="knee" name="FL_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_L"/>
            <geom name="FL" class="foot" pos="-0.003475 0 -0.11"/>
            <site name="FL" pos="-0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
      <body name="RR_hip" pos="-0.046896 -0.004096 -0.0064">
        <inertial pos="0.0139 -0.0269 0" mass="0.106" diaginertia="2e-05 6e-05 6e-05" />
        <joint class="abduction" name="RR_hip_joint"/>
        <geom class="visual" mesh="Hip_R"/>
        <body name="RR_thigh" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
          <inertial pos="0.0172 0 -0.061" mass="0.142" diaginertia="0.00014 0.00016 3e-05" />
          <joint class="hip" name="RR_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_R"/>
          <body name="RR_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <inertial pos="-0.00588 -0.00075 -0.0658" mass="0.038" diaginertia="0.00018 0.00018 2e-05" />
            <joint class="knee" name="RR_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_R"/>
            <geom name="RR" class="foot" pos="0.003475 0 -0.11"/>
            <site name="RR" pos="0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
      <body name="RL_hip" pos="0.047104 -0.004096 -0.0064">
        <inertial pos="0.0139 0.0254 0" mass="0.106" diaginertia="2e-05 6e-05 6e-05" />
        <joint class="abduction" name="RL_hip_joint"/>
        <geom class="visual" mesh="Hip_L"/>
        <body name="RL_thigh" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
          <inertial pos="0.0172 0 -0.061" mass="0.142" diaginertia="0.00014 0.00016 3e-05" />
          <joint class="hip" name="RL_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_L"/>
          <body name="RL_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <inertial pos="0.00558 -0.00075 -0.0658" mass="0.038" diaginertia="0.00018 0.00018 2e-05" />
            <joint class="knee" name="RL_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_L"/>
            <geom name="RL" class="foot" pos="-0.003475 0 -0.11"/>
            <site name="RL" pos="-0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
    </body>
  </worldbody>

  <actuator>
      <general name="FR_hip"   joint="FR_hip_joint"/>
      <general name="FR_thigh" joint="FR_thigh_joint"/>
      <general name="FR_calf"  joint="FR_calf_joint"/>
      <general name="FL_hip"   joint="FL_hip_joint"/>
      <general name="FL_thigh" joint="FL_thigh_joint"/>
      <general name="FL_calf"  joint="FL_calf_joint"/>
      <general name="RR_hip"   joint="RR_hip_joint"/>
      <general name="RR_thigh" joint="RR_thigh_joint"/>
      <general name="RR_calf"  joint="RR_calf_joint"/>
      <general name="RL_hip"   joint="RL_hip_joint"/>
      <general name="RL_thigh" joint="RL_thigh_joint"/>
      <general name="RL_calf"  joint="RL_calf_joint"/>
  </actuator>

  <!-- Sensors remain the same -->
  <sensor>
    <gyro site="imu" name="gyro"/>
    <velocimeter site="imu" name="local_linvel"/>
    <accelerometer site="imu" name="accelerometer"/>
    <framepos objtype="site" objname="imu" name="position"/>
    <framezaxis objtype="site" objname="imu" name="upvector"/>
    <framexaxis objtype="site" objname="imu" name="forwardvector"/>
    <framelinvel objtype="site" objname="imu" name="global_linvel"/>
    <frameangvel objtype="site" objname="imu" name="global_angvel"/>
    <framequat objtype="site" objname="imu" name="orientation"/>
    <framelinvel objtype="site" objname="FR" name="FR_global_linvel"/>
    <framelinvel objtype="site" objname="FL" name="FL_global_linvel"/>
    <framelinvel objtype="site" objname="RR" name="RR_global_linvel"/>
    <framelinvel objtype="site" objname="RL" name="RL_global_linvel"/>
    <framepos objtype="site" objname="FR" name="FR_pos" reftype="site" refname="imu"/>
    <framepos objtype="site" objname="FL" name="FL_pos" reftype="site" refname="imu"/>
    <framepos objtype="site" objname="RR" name="RR_pos" reftype="site" refname="imu"/>
    <framepos objtype="site" objname="RL" name="RL_pos" reftype="site" refname="imu"/>
    <framepos objtype="site" objname="head" name="head_pos"/>
  </sensor>
</mujoco>

================================================================================
--- FILE: assets/scene.xml ---
------------------------------

<mujoco model="pupper scene">
  <!-- åŒ…å«æ©Ÿå™¨äººæ¨¡å‹ -->
  <include file="pupper.xml"/>

  <statistic center="0 0 0.1" extent="0.8"/>

  <visual>
    <headlight diffuse="0.6 0.6 0.6" ambient="0.3 0.3 0.3" specular="0 0 0"/>
    <rgba haze="0.15 0.25 0.35 1"/>
    <global azimuth="120" elevation="-20"/>
  </visual>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1="0.3 0.5 0.7" rgb2="0 0 0" width="512" height="3072"/>
    <texture type="2d" name="groundplane" builtin="checker" mark="edge" rgb1="0.2 0.3 0.4" rgb2="0.1 0.2 0.3"
      markrgb="0.8 0.8 0.8" width="300" height="300"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance="0.2"/>
  </asset>

  <worldbody>
    <light pos="0 0 1.5" dir="0 0 -1" directional="true"/>
    <camera name="default" pos="0.846 -1.465 0.916" xyaxes="0.866 0.500 0.000 -0.171 0.296 0.940"/>
    <geom name="floor" size="0 0 0.05" type="plane" material="groundplane"/>
    
  <keyframe>
    <!-- ç‚ºPupperå®šç¾©ä¸€å€‹'home'ç«™ç«‹å§¿æ…‹ -->
    <!-- qpos: [root_pos(3), root_quat(4), FR(3), FL(3), RR(3), RL(3)] -->
    <!-- åŸå§‹Pupperæ¨¡å‹çš„home: [0 0.4 -0.8] for each leg (abduction, hip, knee) -->
    <key name="home" qpos="
    0 0 0.2
    1 0 0 0
    0 0.0 0.0
    0 0.0 0.0
    0 0.0 0.0
    0 0.0 0.0"
      ctrl="0 0 0  0 0 0  0 0 0  0 0 0"/>
  </keyframe>


    <!-- =========================================================== -->
    <!-- === æ–°å¢éƒ¨åˆ† 1ï¼šMocap Body (æˆ‘å€‘çš„ç©ºä¸­éŒ¨é») === -->
    <!-- mocap="true" è¡¨ç¤ºå®ƒçš„ä½ç½®ç”±æˆ‘å€‘æ‰‹å‹•è¨­å®š -->
    <!-- å°‡å…¶æ”¾åœ¨ worldbody çš„é ‚å±¤ -->
    <body name="anchor" pos="0 0 0.35" mocap="true">
      <!-- æˆ‘å€‘å¯ä»¥çµ¦å®ƒä¸€å€‹çœ‹ä¸è¦‹çš„ geom ä¾†è¦–è¦ºåŒ–å®ƒçš„ä½ç½®ï¼Œæ–¹ä¾¿é™¤éŒ¯ -->
      <geom type="sphere" size="0.02" rgba="1 0 0 0.5" contype="0" conaffinity="0"/>
    </body>
    <!-- =========================================================== -->

  </worldbody>

  <!-- ============================================================= -->
  <!-- === æ–°å¢éƒ¨åˆ† 2ï¼šWeld ç´„æŸ === -->
  <!-- å°‡å…¶æ”¾åœ¨ mujoco æ¨™ç±¤çš„é ‚å±¤ -->
  <!-- é€™å€‹ç´„æŸå°‡ pupper.xml ä¸­çš„ "torso" "ç„Šæ¥" åˆ°æˆ‘å€‘ä¸Šé¢å®šç¾©çš„ "anchor" ä¸Š -->
  <!-- active="false" è¡¨ç¤ºé è¨­æ˜¯ç¦ç”¨çš„ -->
  <equality>
    <weld name="torso_anchor_weld" body1="torso" body2="anchor" solimp="0.9 0.95 0.001" solref="0.02 1" active="false"/>
  </equality>
  <!-- ============================================================= -->

</mujoco>

================================================================================
--- FILE: assets/scene_hfield_mjx.xml ---
-----------------------------------------

<mujoco model="barkour vB scene">
  <include file="pupper_mjx.xml"/>

  <statistic center="0 0 0.1" extent="0.8"/>

  <visual>
    <headlight diffuse="0.6 0.6 0.6" ambient="0.3 0.3 0.3" specular="0 0 0"/>
    <rgba haze="0.15 0.25 0.35 1"/>
    <global azimuth="120" elevation="-20"/>
  </visual>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1="0.3 0.5 0.7" rgb2="0 0 0" width="512" height="3072"/>
    <texture type="2d" name="groundplane" builtin="checker" mark="edge" rgb1="0.2 0.3 0.4" rgb2="0.1 0.2 0.3"
      markrgb="0.8 0.8 0.8" width="300" height="300"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance="0.2"/>
    <hfield name="hfield" file="mesh-2/hfield.png" size="10 10 .02 0.1"/>
  </asset>

  <worldbody>
    <light pos="0 0 1.5" dir="0 0 -1" directional="true"/>
    <camera name="default" pos="0.846 -1.465 0.916" xyaxes="0.866 0.500 0.000 -0.171 0.296 0.940"/>
    <geom name="floor" type="hfield" hfield="hfield" conaffinity="1" material="groundplane"/>
  </worldbody>
</mujoco>

================================================================================
--- FILE: assets/scene_mjx.xml ---
----------------------------------

<!-- assets/scene_mjx.xml -->
<mujoco model="Pupper Scene MJX">
  <include file="assets/pupper_mjx.xml"/>

  <statistic center="0 0 0.1" extent="0.8" meansize="0.04"/>

  <visual>
    <headlight diffuse=".8 .8 .8" ambient=".2 .2 .2" specular="1 1 1"/>
    <global azimuth="120" elevation="-20"/>
    <quality shadowsize="4096"/>
  </visual>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1=".6 .7 .8" rgb2=".2 .3 .4" width="800" height="800"/>
    <texture type="2d" name="groundplane" builtin="checker" mark="edge" rgb1=".2 .3 .4" rgb2=".1 .2 .3" markrgb=".8 .8 .8"
      width="300" height="300"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance="0"/>
    
    <!-- ã€æ–°å¢ã€‘å®šç¾©é«˜åº¦å ´è³‡ç”¢ -->
    <!-- nrow å’Œ ncol å®šç¾©äº†è§£æåº¦ (ä¾‹å¦‚ 100x100 çš„ç¶²æ ¼) -->
    <!-- size å®šç¾©äº†ç‰©ç†å°ºå¯¸ (ä¾‹å¦‚ 10ç±³ x 10ç±³ x æœ€å¤§é«˜åº¦1ç±³) -->
    <hfield name="terrain" nrow="100" ncol="100" size="5 5 1 0.1"/>
  </asset>

  <worldbody>
    <!-- ã€ä¿®æ”¹ã€‘å°‡åŸä¾†çš„å¹³é¢åœ°æ¿ geom æ›¿æ›ç‚ºé«˜åº¦å ´ geom -->
    <!-- <geom name="floor" size="0 0 0.05" type="plane" material="groundplane" condim="3" contype="1" conaffinity="0"/> -->
    <geom name="floor" type="hfield" hfield="terrain" material="groundplane" condim="3" contype="1" conaffinity="0"/>
    
    <body name="anchor" pos="0 0 0.35" mocap="true">
      <geom type="sphere" size="0.02" rgba="1 0 0 0.5" contype="0" conaffinity="0"/>
    </body>
  </worldbody>

  <equality>
    <weld name="torso_anchor_weld" body1="torso" body2="anchor" solimp="0.9 0.95 0.001" solref="0.02 1" active="false"/>
  </equality>
  
  <keyframe>
    <key name="home" qpos="
    0 0 0.3
    1 0 0 0 
    0.0  0.0  0.0  
    0.0  0.0  0.0  
    0.0  0.0  0.0  
    0.0  0.0  0.0 "/>
  </keyframe>
</mujoco>

================================================================================
--- FILE: assets/scene_mjx_feetonly_bowl.xml ---
------------------------------------------------

<mujoco model="go1 feet only scene">
  <include file="go1_mjx_feetonly.xml"/>

  <statistic center="0 0 0.1" extent="0.8" meansize="0.04"/>

  <visual>
    <rgba force="1 0 0 1"/>
    <global azimuth="120" elevation="-20"/>
    <map force="0.01"/>
    <scale forcewidth="0.3" contactwidth="0.5" contactheight="0.2"/>
    <quality shadowsize="8192"/>
  </visual>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1="1 1 1" rgb2="1 1 1" width="800" height="800"/>
    <texture type="2d" name="groundplane" file="assets/rocky_texture.png"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance=".8"/>
    <hfield name="terrain" ncol="201" nrow="201" size="30 30 5 .1"/>
  </asset>

  <worldbody>
    <camera name="global"  pos="-5 5 5" xyaxes="-1 -1 0 1 0 1" mode="trackcom"/>
    <geom name="floor" type="hfield" hfield="terrain" material="groundplane" pos="0 0 -.01"/>
  </worldbody>

  <keyframe>
    <key name="home" qpos="0 0 0.35 1 0 0 0 0 0.9 -1.8 0 0.9 -1.8 0 0.9 -1.8 0 0.9 -1.8"
      ctrl="0 0.9 -1.8 0 0.9 -1.8 0 0.9 -1.8 0 0.9 -1.8"/>
    <key name="home_higher"
    qpos="0 0 0.35 1 0 0 0 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"
    ctrl="0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"/>
  </keyframe>
</mujoco>


================================================================================
--- FILE: assets/scene_mjx_feetonly_flat_terrain.xml ---
--------------------------------------------------------

<mujoco model="go1 feetonly flat terrain scene">
  <include file="go1_mjx_feetonly.xml"/>

  <statistic center="0 0 0.1" extent="0.8" meansize="0.04"/>

  <visual>
    <headlight diffuse=".8 .8 .8" ambient=".2 .2 .2" specular="1 1 1"/>
    <rgba force="1 0 0 1"/>
    <global azimuth="120" elevation="-20"/>
    <map force="0.01"/>
    <scale forcewidth="0.3" contactwidth="0.5" contactheight="0.2"/>
    <quality shadowsize="8192"/>
  </visual>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1="1 1 1" rgb2="1 1 1" width="800" height="800"/>
    <texture type="2d" name="groundplane" builtin="checker" mark="edge" rgb1="1 1 1" rgb2="1 1 1" markrgb="0 0 0"
      width="300" height="300"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance="0"/>
  </asset>

  <worldbody>
    <geom name="floor" size="0 0 0.01" type="plane" material="groundplane" contype="1" conaffinity="0" priority="1"
      friction="0.6" condim="3"/>
  </worldbody>

  <keyframe>
    <key name="home" qpos="
    0 0 0.278
    1 0 0 0
    0.1 0.9 -1.8
    -0.1 0.9 -1.8
    0.1 0.9 -1.8
    -0.1 0.9 -1.8"
      ctrl="0.1 0.9 -1.8 -0.1 0.9 -1.8 0.1 0.9 -1.8 -0.1 0.9 -1.8"/>
    <key name="home_higher" qpos="0 0 0.31 1 0 0 0 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"
      ctrl="0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"/>
    <key
    name="footstand"
    qpos='
    0 0 0.54
    0.8 0 -0.8 0
    0 0.82 -1.6 0 0.82 -1.68 0 1.82 -1.16 0.0 1.82 -1.16'
    ctrl='0 0.82 -1.6 0 0.82 -1.68 0 1.82 -1.16 0.0 1.82 -1.16'/>
    <key name="handstand"
      qpos="0 0 0.54
      0.8 0 0.8 0
      0 -0.686 -1.16
      0 -0.686 -1.16
      0 1.7 -1.853
      0 1.7 -1.853"
      ctrl="0 -0.686 -1.16 0 -0.686 -1.16 0 1.7 -1.853 0 1.7 -1.853"/>
    <key name="pre_recovery"
      qpos="-0.0318481 -0.000215369 0.0579031 1 -2.70738e-05 6.06169e-05 0.000231261 -0.352275 1.18554 -2.80738 0.360892 1.1806 -2.80281 -0.381197 1.16812 -2.79123 0.391054 1.1622 -2.78576"
      ctrl="-0.352275 1.18554 -2.80738 0.360892 1.1806 -2.80281 -0.381197 1.16812 -2.79123 0.391054 1.1622 -2.78576"/>
  </keyframe>
</mujoco>


================================================================================
--- FILE: assets/scene_mjx_feetonly_rough_terrain.xml ---
---------------------------------------------------------

<mujoco model="go1 feet only rough terrain scene">
  <include file="go1_mjx_feetonly.xml"/>

  <statistic center="0 0 0.1" extent="0.8" meansize="0.04"/>

  <visual>
    <rgba force="1 0 0 1"/>
    <global azimuth="120" elevation="-20"/>
    <map force="0.01"/>
    <scale forcewidth="0.3" contactwidth="0.5" contactheight="0.2"/>
    <quality shadowsize="8192"/>
  </visual>

  <asset>
    <!-- https://polyhaven.com/a/rock_face -->
    <texture type="2d" name="groundplane" file="assets/rocky_texture.png"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance=".8"/>
    <hfield name="hfield" file="assets/hfield.png" size="10 10 .05 0.1"/>
  </asset>

  <worldbody>
    <geom name="floor" type="hfield" hfield="hfield" material="groundplane" contype="1" conaffinity="0" priority="1"
      friction="1.0"/>
  </worldbody>

  <keyframe>
    <key name="home" qpos="
    0 0 0.35
    1 0 0 0
    0.1 0.9 -1.8
    -0.1 0.9 -1.8
    0.1 0.9 -1.8
    -0.1 0.9 -1.8"
      ctrl="0.1 0.9 -1.8 -0.1 0.9 -1.8 0.1 0.9 -1.8 -0.1 0.9 -1.8"/>
    <key name="home_higher" qpos="0 0 0.35 1 0 0 0 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"
      ctrl="0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"/>
  </keyframe>
</mujoco>


================================================================================
--- FILE: assets/scene_mjx_feetonly_stairs.xml ---
--------------------------------------------------

<mujoco model="go1 scene">
  <include file="go1_mjx_feetonly.xml"/>

  <statistic center="0 0 0.1" extent="0.8" meansize="0.04"/>

  <visual>
    <headlight diffuse=".8 .8 .8" ambient=".2 .2 .2" specular="1 1 1"/>
    <rgba force="1 0 0 1"/>
    <global azimuth="120" elevation="-20"/>
    <map force="0.01"/>
    <scale forcewidth="0.3" contactwidth="0.5" contactheight="0.2"/>
    <quality shadowsize="8192"/>
  </visual>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1="1 1 1" rgb2="1 1 1" width="800" height="800"/>
    <texture type="2d" name="groundplane" builtin="checker" mark="edge" rgb1="1 1 1" rgb2="1 1 1" markrgb="0 0 0"
      width="300" height="300"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance="0"/>
    <material name="stairs" rgba="1 1 1 1" reflectance=".8"/>
  </asset>

  <default>
    <default class="stairs">
      <geom material="stairs" contype="1" conaffinity="0"/>
    </default>
  </default>

  <worldbody>
    <geom name="floor" size="0 0 0.01" material="groundplane" type="plane" contype="1" conaffinity="0"/>

    <body name="stairs" pos="0.2 0 0" childclass="stairs">
      <geom pos="0.2 0 0.075" type="box" size="0.1 0.75 0.025"/>
      <geom pos="0.4 0 0.22" type="box" size="0.1 0.75 0.025"/>
      <geom pos="0.6 0 0.375" type="box" size="0.1 0.75 0.025"/>
      <geom pos="0.8 0 0.525" type="box" size="0.1 0.75 0.025"/>
      <geom pos="1.0 0 0.675" type="box" size="0.1 0.75 0.025"/>
      <geom pos="1.2 0 0.825" type="box" size="0.1 0.75 0.025"/>
      <geom pos="1.4 0 0.975" type="box" size="0.1 0.75 0.025"/>
      <geom pos="1.6 0 1.125" type="box" size="0.1 0.75 0.025"/>
      <geom pos="1.8 0 1.275" type="box" size="0.1 0.75 0.025"/>
      <geom pos="2 0 1.42" type="box" size="0.1 0.75 0.025"/>
      <geom pos="2.2 0 1.57" type="box" size="0.1 0.75 0.025"/>
      <geom pos="2.4 0 1.72" type="box" size="0.1 0.75 0.025"/>
      <geom pos="2.6 0 1.87" type="box" size="0.1 0.75 0.025"/>
      <geom pos="2.8 0 2.02" type="box" size="0.1 0.75 0.025"/>
      <geom pos="3 0 2.17" type="box" size="0.1 0.75 0.025"/>
      <geom pos="3.2 0 2.32" type="box" size="0.1 0.75 0.025"/>
      <geom pos="3.4 0 2.47" type="box" size="0.1 0.75 0.025"/>
      <geom pos="3.6 0 2.62" type="box" size="0.1 0.75 0.025"/>
      <geom pos="3.8 0 2.77" type="box" size="0.1 0.75 0.025"/>
      <geom pos="4 0 2.92" type="box" size="0.1 0.75 0.025"/>
    </body>
  </worldbody>

  <keyframe>
    <key name="home" qpos="0 0 0.27 1 0 0 0 0 0.9 -1.8 0 0.9 -1.8 0 0.9 -1.8 0 0.9 -1.8"
      ctrl="0 0.9 -1.8 0 0.9 -1.8 0 0.9 -1.8 0 0.9 -1.8"/>
  </keyframe>
</mujoco>


================================================================================
--- FILE: assets/scene_mjx_flat_terrain.xml ---
-----------------------------------------------

<mujoco model="go1 scene">
  <include file="go1_mjx.xml"/>

  <statistic center="0 0 0.1" extent="0.8" meansize="0.04"/>

  <visual>
    <headlight diffuse=".8 .8 .8" ambient=".2 .2 .2" specular="1 1 1"/>
    <rgba force="1 0 0 1"/>
    <global azimuth="120" elevation="-20"/>
    <map force="0.01"/>
    <scale forcewidth="0.3" contactwidth="0.5" contactheight="0.2"/>
    <quality shadowsize="8192"/>
  </visual>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1="1 1 1" rgb2="1 1 1" width="800" height="800"/>
    <texture type="2d" name="groundplane" builtin="checker" mark="edge" rgb1="1 1 1" rgb2="1 1 1" markrgb="0 0 0"
      width="300" height="300"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance="0"/>
  </asset>

  <worldbody>
    <geom name="floor" size="0 0 0.01" type="plane" material="groundplane" priority="1" friction="0.6" condim="3" contype="1" conaffinity="0"/>
  </worldbody>

  <keyframe>
    <key name="home" qpos="
    0 0 0.278
    1 0 0 0
    0.1 0.9 -1.8
    -0.1 0.9 -1.8
    0.1 0.9 -1.8
    -0.1 0.9 -1.8"
      ctrl="0.1 0.9 -1.8 -0.1 0.9 -1.8 0.1 0.9 -1.8 -0.1 0.9 -1.8"/>
    <key name="home_higher" qpos="0 0 0.31 1 0 0 0 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"
      ctrl="0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"/>
    <key name="pre_recovery"
      qpos="-0.0318481 -0.000215369 0.0579031 1 -2.70738e-05 6.06169e-05 0.000231261 -0.352275 1.18554 -2.80738 0.360892 1.1806 -2.80281 -0.381197 1.16812 -2.79123 0.391054 1.1622 -2.78576"
      ctrl="-0.352275 1.18554 -2.80738 0.360892 1.1806 -2.80281 -0.381197 1.16812 -2.79123 0.391054 1.1622 -2.78576"/>
    <key name="footstand"
      qpos="0 0 0.54 0.8 0 -0.8 0 0 0.82 -1.6 0 0.82 -1.68 0 1.82 -1.16 0.0 1.82 -1.16"
      ctrl="0 0.82 -1.6 0 0.82 -1.68 0 1.82 -1.16 0.0 1.82 -1.16"/>
    <key name="handstand"
      qpos="0 0 0.54 0.8 0 0.8 0 0 -0.686 -1.16 0 -0.686 -1.16 0 1.7 -1.853 0 1.7 -1.853"
      ctrl="0 -0.686 -1.16 0 -0.686 -1.16 0 1.7 -1.853 0 1.7 -1.853"/>
  </keyframe>
</mujoco>


================================================================================
--- FILE: assets/scene_mjx_fullcollisions_flat_terrain.xml ---
--------------------------------------------------------------

<mujoco model="go1 scene">
  <include file="go1_mjx_fullcollisions.xml"/>

  <statistic center="0 0 0.1" extent="0.8" meansize="0.04"/>

  <visual>
    <headlight diffuse=".8 .8 .8" ambient=".2 .2 .2" specular="1 1 1"/>
    <rgba force="1 0 0 1"/>
    <global azimuth="120" elevation="-20"/>
    <map force="0.01"/>
    <scale forcewidth="0.3" contactwidth="0.5" contactheight="0.2"/>
    <quality shadowsize="8192"/>
  </visual>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1="1 1 1" rgb2="1 1 1" width="800" height="800"/>
    <texture type="2d" name="groundplane" builtin="checker" mark="edge" rgb1="1 1 1" rgb2="1 1 1" markrgb="0 0 0"
      width="300" height="300"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance="0"/>
  </asset>

  <worldbody>
    <geom name="floor" size="0 0 0.01" type="plane" material="groundplane" priority="1" friction="0.6" condim="3" contype="1" conaffinity="0"/>
  </worldbody>

  <keyframe>
    <key name="home" qpos="
    0 0 0.278
    1 0 0 0
    0.1 0.9 -1.8
    -0.1 0.9 -1.8
    0.1 0.9 -1.8
    -0.1 0.9 -1.8"
      ctrl="0.1 0.9 -1.8 -0.1 0.9 -1.8 0.1 0.9 -1.8 -0.1 0.9 -1.8"/>
    <key name="home_higher" qpos="0 0 0.31 1 0 0 0 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"
      ctrl="0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63 0 0.82 -1.63"/>
    <key name="pre_recovery"
      qpos="-0.0318481 -0.000215369 0.0579031 1 -2.70738e-05 6.06169e-05 0.000231261 -0.352275 1.18554 -2.80738 0.360892 1.1806 -2.80281 -0.381197 1.16812 -2.79123 0.391054 1.1622 -2.78576"
      ctrl="-0.352275 1.18554 -2.80738 0.360892 1.1806 -2.80281 -0.381197 1.16812 -2.79123 0.391054 1.1622 -2.78576"/>
    <key name="footstand"
      qpos="0 0 0.54 0.8 0 -0.8 0 0 0.82 -1.6 0 0.82 -1.68 0 1.82 -1.16 0.0 1.82 -1.16"
      ctrl="0 0.82 -1.6 0 0.82 -1.68 0 1.82 -1.16 0.0 1.82 -1.16"/>
    <key name="handstand"
      qpos="0 0 0.54 0.8 0 0.8 0 0 -0.686 -1.16 0 -0.686 -1.16 0 1.7 -1.853 0 1.7 -1.853"
      ctrl="0 -0.686 -1.16 0 -0.686 -1.16 0 1.7 -1.853 0 1.7 -1.853"/>
  </keyframe>
</mujoco>


================================================================================
--- FILE: test/dump_project.py ---
----------------------------------

import os
import sys

# (å¦‚éœ€ç”¢ç”Ÿç›®éŒ„æ¨¹çµæ§‹ï¼Œè«‹åœ¨å‘½ä»¤æç¤ºå­—å…ƒæˆ– PowerShell åŸ·è¡Œ: tree /F /A > tree_structure.txt)


# --- çµ„æ…‹è¨­å®š (å¯ä¾éœ€æ±‚ä¿®æ”¹) ---

# 1. è¦å¿½ç•¥çš„è³‡æ–™å¤¾åç¨± (ä½¿ç”¨é›†åˆ set æŸ¥è©¢é€Ÿåº¦è¼ƒå¿«)
#    é€šå¸¸æ˜¯ç‰ˆæœ¬æ§åˆ¶ã€è™›æ“¬ç’°å¢ƒã€ç›¸ä¾æ€§å¥—ä»¶ç­‰
EXCLUDE_DIRS = {
    '.git', 'node_modules', '__pycache__', 'venv', '.vscode', 
    'dist', 'build', 'env', '.idea', 'target', '.DS_Store'
}

# 2. è¦å¿½ç•¥çš„æª”æ¡ˆé¡å‹ (å‰¯æª”å)
#    é€šå¸¸æ˜¯äºŒé€²ä½æª”æ¡ˆã€æ—¥èªŒã€å£“ç¸®æª”ç­‰
EXCLUDE_EXTENSIONS = {
    '.pyc', '.pyo', '.o', '.so', '.dll', '.exe',
    '.img', '.iso', '.zip', '.tar', '.gz', '.rar',
    '.pdf', '.docx', '.xlsx', '.pptx', '.ort',
    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg',
    '.lock', '.log', '.swp', '.swo', '.stl', '.onnx'
}

# 3. (å¯é¸) å¦‚æœä½ åªæƒ³åŒ…å«ç‰¹å®šé¡å‹çš„æª”æ¡ˆï¼Œå¯ä»¥è¨­å®šé€™å€‹æ¸…å–®
#    å¦‚æœæ­¤æ¸…å–®ä¸æ˜¯ç©ºçš„ï¼Œè…³æœ¬å°‡åªè™•ç†é€™äº›å‰¯æª”åçš„æª”æ¡ˆã€‚
#    ä¾‹å¦‚: INCLUDE_EXTENSIONS = {'.py', '.js', '.html', '.css'}
INCLUDE_EXTENSIONS = set() 

# --- è…³æœ¬ä¸»é«” ---

def generate_code_dump(root_dir, output_filename):
    """
    éè¿´æƒæä¸€å€‹ç›®éŒ„ï¼Œä¸¦å°‡æ‰€æœ‰éå¿½ç•¥æª”æ¡ˆçš„å…§å®¹å¯«å…¥å–®ä¸€è¼¸å‡ºæª”ã€‚
    """
    # æª¢æŸ¥æ ¹ç›®éŒ„æ˜¯å¦å­˜åœ¨
    if not os.path.isdir(root_dir):
        print(f"éŒ¯èª¤ï¼šç›®éŒ„ '{root_dir}' ä¸å­˜åœ¨ã€‚")
        return

    processed_files_count = 0
    
    try:
        # ä½¿ç”¨ 'w' (å¯«å…¥æ¨¡å¼) å’Œ utf-8 ç·¨ç¢¼é–‹å•Ÿæª”æ¡ˆ
        # errors='ignore' æœƒåœ¨é‡åˆ°ç„¡æ³•è§£ç¢¼çš„å­—å…ƒæ™‚å¿½ç•¥å®ƒï¼Œé¿å…å› äºŒé€²ä½æª”æ¡ˆå‡ºéŒ¯
        with open(output_filename, 'w', encoding='utf-8', errors='ignore') as outfile:
            # åœ¨è¼¸å‡ºæª”æ¡ˆçš„é–‹é ­åŠ ä¸Šæ¨™é¡Œ
            outfile.write(f"# å°ˆæ¡ˆç¨‹å¼ç¢¼å½™æ•´: {os.path.abspath(root_dir)}\n")
            outfile.write("=" * 80 + "\n\n")

            # os.walk æœƒéè¿´åœ°èµ°éç›®éŒ„æ¨¹
            for dirpath, dirnames, filenames in os.walk(root_dir, topdown=True):
                
                # --- éæ¿¾è³‡æ–™å¤¾ ---
                # é€™æ˜¯ os.walk çš„ä¸€å€‹æŠ€å·§ï¼šç›´æ¥ä¿®æ”¹ dirnames åˆ—è¡¨ï¼Œ
                # os.walk å°±ä¸æœƒå†é€²å…¥é€™äº›è¢«ç§»é™¤çš„è³‡æ–™å¤¾ã€‚
                dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]

                # æ’åºæª”æ¡ˆï¼Œè®“è¼¸å‡ºçµæœæ›´ä¸€è‡´
                for filename in sorted(filenames):
                    # å–å¾—æª”æ¡ˆå‰¯æª”å
                    _, extension = os.path.splitext(filename)
                    extension = extension.lower()

                    # --- éæ¿¾æª”æ¡ˆ ---
                    if extension in EXCLUDE_EXTENSIONS:
                        continue
                    
                    if INCLUDE_EXTENSIONS and extension not in INCLUDE_EXTENSIONS:
                        continue

                    # çµ„åˆå®Œæ•´æª”æ¡ˆè·¯å¾‘
                    file_path = os.path.join(dirpath, filename)
                    
                    # å–å¾—ç›¸å°æ–¼æ ¹ç›®éŒ„çš„è·¯å¾‘ï¼Œè®“è¼¸å‡ºæ›´ç°¡æ½”
                    relative_path = os.path.relpath(file_path, root_dir)

                    try:
                        # å¯«å…¥æª”æ¡ˆåˆ†éš”ç·šå’Œè·¯å¾‘æ¨™é¡Œ
                        header = f"--- FILE: {relative_path.replace(os.sep, '/')} ---"
                        outfile.write("=" * 80 + "\n")
                        outfile.write(header + "\n")
                        outfile.write("-" * len(header) + "\n\n")
                        
                        print(f"æ­£åœ¨è™•ç†: {relative_path}")

                        # è®€å–åŸå§‹æª”æ¡ˆå…§å®¹ä¸¦å¯«å…¥è¼¸å‡ºæª”
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as infile:
                            content = infile.read()
                            outfile.write(content)
                            outfile.write("\n\n")
                        
                        processed_files_count += 1

                    except Exception as e:
                        # è™•ç†è®€å–æª”æ¡ˆæ™‚å¯èƒ½ç™¼ç”Ÿçš„å…¶ä»–éŒ¯èª¤
                        error_msg = f"--- ç„¡æ³•è®€å–æª”æ¡ˆ: {relative_path} (éŒ¯èª¤: {e}) ---\n\n"
                        outfile.write(error_msg)
                        print(f"è­¦å‘Š: {error_msg.strip()}")

        # é¡¯ç¤ºæˆåŠŸè¨Šæ¯
        print("\n" + "=" * 80)
        print(f"âœ… æˆåŠŸï¼å…±è™•ç†äº† {processed_files_count} å€‹æª”æ¡ˆã€‚")
        print(f"è¼¸å‡ºçµæœå·²å„²å­˜è‡³: {os.path.abspath(output_filename)}")
        print("=" * 80)

    except IOError as e:
        print(f"éŒ¯èª¤ï¼šç„¡æ³•å¯«å…¥è¼¸å‡ºæª”æ¡ˆ '{output_filename}'ã€‚è«‹æª¢æŸ¥æ¬Šé™ã€‚ ({e})")
    except Exception as e:
        print(f"ç™¼ç”Ÿæœªé æœŸçš„éŒ¯èª¤: {e}")


if __name__ == "__main__":
    # æ±ºå®šè¦æƒæçš„æ ¹ç›®éŒ„
    # å¦‚æœåŸ·è¡Œæ™‚æœ‰çµ¦åƒæ•¸ï¼Œå°±ç”¨ç¬¬ä¸€å€‹åƒæ•¸ç•¶ä½œè·¯å¾‘ï¼Œå¦å‰‡ä½¿ç”¨ç•¶å‰ç›®éŒ„ "."
    target_dir = sys.argv[1] if len(sys.argv) > 1 else '.'
    
    # æ±ºå®šè¼¸å‡ºæª”æ¡ˆçš„åç¨±
    output_file = 'project_dump.txt'
    
    # åŸ·è¡Œä¸»å‡½å¼
    generate_code_dump(target_dir, output_file)

================================================================================
--- FILE: test/test_joystick.py ---
-----------------------------------

# test_joystick.py
import pygame
import time

pygame.init()
pygame.joystick.init()

if pygame.joystick.get_count() == 0:
    print("éŒ¯èª¤ï¼šæœªåµæ¸¬åˆ°ä»»ä½•æ–æ¡¿ã€‚")
    exit()

joystick = pygame.joystick.Joystick(0)
joystick.init()

print(f"å·²é€£æ¥åˆ°: {joystick.get_name()}")
print(f"æ–æ¡¿æœ‰ {joystick.get_numaxes()} å€‹è»¸ã€‚")
print("\nè«‹ç§»å‹•æ‚¨çš„æ–æ¡¿ï¼Œè§€å¯Ÿæ¯å€‹è»¸çš„ç·¨è™Ÿå’Œæ•¸å€¼è®ŠåŒ–...")
print("æŒ‰ Ctrl+C çµæŸæ¸¬è©¦ã€‚")

try:
    while True:
        for event in pygame.event.get():
            if event.type == pygame.JOYAXISMOTION:
                print(f"è»¸ (Axis) {event.axis}: {event.value:.3f}")
        time.sleep(0.01)
except KeyboardInterrupt:
    print("\næ¸¬è©¦çµæŸã€‚")

pygame.quit()

================================================================================
--- FILE: test/verify_model_mode.py ---
---------------------------------------

# verify_model_mode.py
import numpy as np
import mujoco
import sys
import time
from pathlib import Path

# --- å°å…¥æ‚¨å°ˆæ¡ˆçš„æ¨¡çµ„ ---
from config import load_config
from policy import ONNXPolicy
from observation import ObservationBuilder # æˆ‘å€‘å°‡ä½¿ç”¨æ‚¨ä¿®æ”¹å¾Œçš„ç‰ˆæœ¬

# --- è…³æœ¬è¨­å®š ---
SIMULATION_DURATION = 3.0
PERTURBATION_VALUE = 0.3
STABILITY_THRESHOLD = 0.05
HIP_JOINT_INDICES = [1, 4, 7, 10]

def run_simulation(model, data, policy, obs_builder, duration):
    """
    é‹è¡Œä¸€å€‹æ¨¡æ“¬ç‰‡æ®µä¸¦æ”¶é›†æœ€å¾Œçš„ Raw Action æ•¸æ“šã€‚
    é€™å€‹ç‰ˆæœ¬å‡è¨­æ˜¯ã€Œçµ•å°è§’åº¦æ¨¡å¼ã€ã€‚
    """
    # åœ¨é€™å€‹æ¸¬è©¦è…³æœ¬ä¸­ï¼Œæˆ‘å€‘ç›´æ¥ä½¿ç”¨ä¸€å€‹å›ºå®šçš„PDå¢ç›Š
    model.actuator_gainprm[:, 0] = 5.0
    model.dof_damping[6:] = 0.5
    
    start_time = data.time
    recent_actions = []

    # ç°¡å–®çš„ç†±èº«
    warmup_duration = 1.0
    while data.time - start_time < warmup_duration:
        base_obs = obs_builder.get_observation(np.zeros(3), policy.last_action)
        _, action_raw = policy.get_action(base_obs)
        # ã€æ ¸å¿ƒã€‘ä½¿ç”¨çµ•å°è§’åº¦æ¨¡å¼è¨ˆç®—æ§åˆ¶æŒ‡ä»¤
        final_ctrl = action_raw * 1.0 # action_scale è¨­ç‚º 1.0
        data.ctrl[:] = final_ctrl
        mujoco.mj_step(model, data)

    # çœŸæ­£é–‹å§‹æ”¶é›†æ•¸æ“š
    collection_start_time = data.time
    while data.time - collection_start_time < (duration - warmup_duration):
        base_obs = obs_builder.get_observation(np.zeros(3), policy.last_action)
        _, action_raw = policy.get_action(base_obs)
        recent_actions.append(action_raw.copy())
        
        final_ctrl = action_raw * 1.0
        data.ctrl[:] = final_ctrl
        mujoco.mj_step(model, data)

    if not recent_actions:
        print("âŒ éŒ¯èª¤ï¼šæœªèƒ½æ”¶é›†åˆ°ä»»ä½• action æ•¸æ“šã€‚")
        return None
        
    return np.mean(recent_actions, axis=0)

def reset_to_key(model, data, key_id, perturbation=None):
    """
    æ‰‹å‹•å°‡æ¨¡æ“¬é‡ç½®åˆ°æŒ‡å®šçš„ keyframeï¼Œä¸¦å¯é¸æ“‡æ€§åœ°æ–½åŠ æ“¾å‹•ã€‚
    """
    mujoco.mj_resetData(model, data)
    qpos = model.key_qpos[key_id].copy()
    if perturbation is not None:
        qpos[7:] += perturbation
    data.qpos[:] = qpos
    data.qvel[:] = model.key_qvel[key_id]
    mujoco.mj_forward(model, data)


def verify():
    """åŸ·è¡Œé©—è­‰çš„ä¸»å‡½å¼ã€‚"""
    print("=" * 60)
    print("ğŸ¤– æ¨¡å‹è¼¸å‡ºæ¨¡å¼é©—è­‰å·¥å…· (çµ•å°è§’åº¦æ¨¡å¼é©—è­‰ç‰ˆ) ğŸ¤–")
    print("=" * 60)

    try:
        print("1. è¼‰å…¥è¨­å®šèˆ‡æ¨¡å‹...")
        config = load_config()
        if not Path(config.mujoco_model_file).exists():
            print(f"âŒ éŒ¯èª¤ï¼šæ‰¾ä¸åˆ°æ¨¡å‹æª”æ¡ˆ '{config.mujoco_model_file}'")
            return

        model = mujoco.MjModel.from_xml_path(config.mujoco_model_file)
        data = mujoco.MjData(model)
        
        home_key_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_KEY, 'home')
        if home_key_id == -1:
            print("âŒ éŒ¯èª¤ï¼šåœ¨ XML ä¸­æ‰¾ä¸åˆ°åç‚º 'home' çš„ keyframeã€‚")
            return
        
        default_pose_from_key = model.key_qpos[home_key_id][7:].copy()
        
        # ç¢ºä¿ä½¿ç”¨èˆ‡æ¨¡å‹åŒ¹é…çš„è§€å¯Ÿé…æ–¹ (å‡è¨­ç‚º48ç¶­)
        obs_dim = 48
        if obs_dim not in config.observation_recipes:
            print(f"âŒ éŒ¯èª¤: config.yaml ä¸­ç¼ºå°‘ç¶­åº¦ç‚º {obs_dim} çš„ observation_recipesã€‚")
            return
        recipe = config.observation_recipes[obs_dim]
             
        # ã€æ ¸å¿ƒã€‘æˆ‘å€‘åœ¨é€™è£¡å¯¦ä¾‹åŒ–çš„ obs_builder æœƒä½¿ç”¨æ‚¨ä¿®æ”¹å¾Œçš„ absolute mode ç‰ˆæœ¬
        obs_builder = ObservationBuilder(recipe, data, model, mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, 'torso'), default_pose_from_key, config)
        base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
        
        policy_config = config
        policy_config.initial_tuning_params.action_scale = 1.0 # æ¸¬è©¦æ™‚å›ºå®šç‚º1.0
        policy = ONNXPolicy(policy_config, base_obs_dim)
        print("âœ… è³‡æºè¼‰å…¥æˆåŠŸï¼")
        print("-" * 60)

        # --- å¯¦é©—ä¸€ï¼šåŸºæº–æ¸¬è©¦ (Baseline Test) ---
        print("2. åŸ·è¡Œã€å¯¦é©—ä¸€ï¼šåŸºæº–æ¸¬è©¦ã€‘")
        print("   - å¾æ¨™æº–çš„ 'home' å§¿æ…‹é–‹å§‹ã€‚")
        
        reset_to_key(model, data, home_key_id)
        policy.reset()
        
        stable_action_base = run_simulation(model, data, policy, obs_builder, SIMULATION_DURATION)
        if stable_action_base is None: return

        hip_action_base = np.mean(stable_action_base[HIP_JOINT_INDICES])
        print(f"   ğŸ“Š åŸºæº–ç©©å®šå¾Œ Raw Action (é«–é—œç¯€å¹³å‡å€¼): {hip_action_base:.4f}")
        print("-" * 60)
        time.sleep(1)

        # --- å¯¦é©—äºŒï¼šæ“¾å‹•åˆå§‹å§¿æ…‹æ¸¬è©¦ (Perturbation Test) ---
        print("3. åŸ·è¡Œã€å¯¦é©—äºŒï¼šæ“¾å‹•æ¸¬è©¦ã€‘")
        print(f"   - å¾ä¸€å€‹è¢«æ“¾å‹•éçš„åˆå§‹å§¿æ…‹é–‹å§‹ (é«–é—œç¯€å¢åŠ  {PERTURBATION_VALUE})ã€‚")
        
        perturbation_vector = np.zeros(12)
        perturbation_vector[HIP_JOINT_INDICES] = PERTURBATION_VALUE
        reset_to_key(model, data, home_key_id, perturbation=perturbation_vector)
        policy.reset()

        stable_action_perturbed = run_simulation(model, data, policy, obs_builder, SIMULATION_DURATION)
        if stable_action_perturbed is None: return
        
        hip_action_perturbed = np.mean(stable_action_perturbed[HIP_JOINT_INDICES])
        print(f"   ğŸ“Š æ“¾å‹•ç©©å®šå¾Œ Raw Action (é«–é—œç¯€å¹³å‡å€¼): {hip_action_perturbed:.4f}")
        print("-" * 60)

        # --- 4. åˆ†æèˆ‡çµè«– ---
        print("4. åˆ†æçµæœèˆ‡çµè«–...")
        
        # åœ¨çµ•å°è§’åº¦æ¨¡å¼ä¸‹ï¼Œå…©å€‹å¯¦é©—çš„è¼¸å‡ºæ‡‰è©²å¹¾ä¹ç›¸åŒ
        diff = abs(hip_action_perturbed - hip_action_base)
        print(f"   - å…©å€‹å¯¦é©—çš„ Raw Action ç©©å®šå€¼ä¹‹å·®: {diff:.4f}")
        print("-" * 60)

        if diff < STABILITY_THRESHOLD:
            print("âœ… ã€çµè«–ã€‘é©—è­‰æˆåŠŸï¼æ¨¡å‹çš„è¡Œç‚ºèˆ‡ã€çµ•å°è§’åº¦æ¨¡å¼ (Absolute-based)ã€‘çš„é æœŸç›¸ç¬¦ã€‚")
            print("   ç„¡è«–å¾å“ªå€‹åˆå§‹å§¿æ…‹é–‹å§‹ï¼Œæ¨¡å‹éƒ½èƒ½æ”¶æ–‚åˆ°å¹¾ä¹ç›¸åŒçš„ç›®æ¨™è§’åº¦è¼¸å‡ºã€‚")
            print("   æ‚¨åœ¨ main.py å’Œ observation.py ä¸­çš„çµ•å°è§’åº¦æ¨¡å¼ä¿®æ”¹æ˜¯ã€æ­£ç¢ºçš„ã€‘ã€‚")
        else:
            print("âŒ ã€çµè«–ã€‘é©—è­‰å¤±æ•—ï¼æ¨¡å‹çš„è¡Œç‚ºèˆ‡ã€çµ•å°è§’åº¦æ¨¡å¼ã€‘çš„é æœŸä¸ç¬¦ã€‚")
            print("   æ¨¡å‹çš„è¼¸å‡ºæœƒå› ç‚ºåˆå§‹å§¿æ…‹çš„ä¸åŒè€Œç”¢ç”Ÿå·¨å¤§å·®ç•°ï¼Œé€™ä¸ç¬¦åˆçµ•å°è§’åº¦æ¨¡å‹çš„ç‰¹å¾µã€‚")
            print("   é€™å¯èƒ½æ„å‘³è‘—æ¨¡å‹å¯¦éš›ä¸Šæ˜¯ã€Œåç§»é‡æ¨¡å¼ã€ï¼Œæˆ–è€…æ¨¡å‹æœ¬èº«ä¸å¤ ç©©å®šã€‚")
            print("   å»ºè­°èˆ‡æ¨¡å‹ä½œè€…ç¢ºèªè¨“ç·´æ™‚çš„è§€å¯Ÿç©ºé–“å’Œå‹•ä½œç©ºé–“å®šç¾©ã€‚")
        
        print("=" * 60)

    except Exception as e:
        print(f"\nâŒ é©—è­‰éç¨‹ä¸­ç™¼ç”ŸéŒ¯èª¤: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    verify()

