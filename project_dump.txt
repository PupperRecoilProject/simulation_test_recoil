# 專案程式碼彙整: C:\git_project\simulation_test_recoil
================================================================================

================================================================================
--- FILE: config.py ---
-----------------------

# config.py
import yaml
from dataclasses import dataclass, field
from typing import Dict, List, Any

@dataclass
class TuningParamsConfig:
    """從設定檔載入的初始調校參數資料類別。"""
    kp: float
    kd: float
    action_scale: float
    bias: float

@dataclass
class FloatingControllerConfig:
    """懸浮控制器的設定。"""
    target_height: float
    kp_vertical: float
    kd_vertical: float
    kp_attitude: float
    kd_attitude: float

@dataclass
class AppConfig:
    """儲存所有應用程式設定的資料類別。"""
    mujoco_model_file: str
    onnx_model_path: str
    num_motors: int
    physics_timestep: float
    control_freq: float
    control_dt: float
    warmup_duration: float
    command_scaling_factors: List[float]
    
    keyboard_velocity_adjust_step: float
    gamepad_sensitivity: Dict[str, float]
    param_adjust_steps: Dict[str, float]

    initial_tuning_params: TuningParamsConfig
    observation_recipes: Dict[int, List[str]]
    floating_controller: FloatingControllerConfig

def load_config(path: str = "config.yaml") -> AppConfig:
    """
    從 YAML 檔案載入設定並回傳一個 AppConfig 物件。
    """
    try:
        with open(path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"設定檔 '{path}' 不存在。請確保檔案路徑正確。")
    except Exception as e:
        raise IOError(f"讀取或解析設定檔 '{path}' 時發生錯誤: {e}")

    tuning_params = TuningParamsConfig(**config_data['initial_tuning_params'])
    floating_config = FloatingControllerConfig(**config_data['floating_controller'])
    
    config_obj = AppConfig(
        mujoco_model_file=config_data['mujoco_model_file'],
        onnx_model_path=config_data['onnx_model_path'],
        num_motors=config_data['num_motors'],
        physics_timestep=config_data['physics_timestep'],
        control_freq=config_data['control_freq'],
        control_dt=1.0 / config_data['control_freq'],
        warmup_duration=config_data['warmup_duration'],
        command_scaling_factors=config_data['command_scaling_factors'],
        
        keyboard_velocity_adjust_step=config_data['keyboard_velocity_adjust_step'],
        gamepad_sensitivity=config_data['gamepad_sensitivity'],
        param_adjust_steps=config_data['param_adjust_steps'],
        
        initial_tuning_params=tuning_params,
        observation_recipes=config_data['observation_recipes'],
        floating_controller=floating_config
    )
    
    print("✅ 設定檔載入成功 (包含懸浮控制器設定)。")
    return config_obj

================================================================================
--- FILE: config.yaml ---
-------------------------

# ==================================
# === 模擬與模型設定 (Simulation & Model Settings)
# ==================================
# 檔案路徑 (File Paths)
mujoco_model_file: "assets/scene_mjx.xml"
onnx_model_path: "models/pupper_ppo_policy_30965760_tf_converted_穩定步態版.onnx"

# 核心參數 (Core Parameters)
num_motors: 12
physics_timestep: 0.004 # <-- 建議修改：提高模擬精度以增強穩定性
control_freq: 50.0
warmup_duration: 0.0

# ONNX 模型命令輸入縮放因子
# 順序: [vy 縮放, vx 縮放, wz 縮放]
command_scaling_factors: [1.0, 1.0, 1.0] 

# ==================================
# === 輸入控制設定 (Input Control Settings)
# ==================================
keyboard_velocity_adjust_step: 0.1 # m/s or rad/s per key press

gamepad_sensitivity:
  vx: 1.0   # 前後速度靈敏度 (左搖桿 Y)
  vy: 1.0   # 左右速度靈敏度 (左搖桿 X)
  wz: -1.5  # 轉向角速度靈敏度 (右搖桿 X), 負值表示右推右轉

param_adjust_steps:
  kp: 0.5
  kd: 0.05
  action_scale: 0.05
  bias: 5

# ==================================
# === 初始調校參數 (Initial Tuning Parameters)
# ==================================
initial_tuning_params:
  kp: 5.0
  kd: 0.50
  action_scale: 0.5
  bias: -15.0

# ==================================
# === 觀察配方 (Observation Recipes)
# ==================================
observation_recipes:
  31:
    - 'z_angular_velocity'
    - 'gravity_vector'
    - 'commands'
    - 'joint_positions'
    - 'last_action'
  48:
    - 'linear_velocity'
    - 'angular_velocity'
    - 'gravity_vector'
    - 'commands'
    - 'joint_positions'
    - 'joint_velocities'
    - 'last_action'

# ================================================================= #
# === 懸浮控制器設定 (Floating Controller Settings) - 精細調校版 ===
# ================================================================= #
floating_controller:
  target_height: 0.50     # 懸浮的目標高度 (米)
  kp_vertical: 80.0       # 垂直 P (再次降低以求平滑)
  kd_vertical: 18.0       # 垂直 D (保持與Kp的關係)
  kp_attitude: 20.0       # 姿態 P (再次降低)
  kd_attitude: 4.0        # 姿態 D (相應調整)

================================================================================
--- FILE: dump_project.py ---
-----------------------------

import os
import sys

# (如需產生目錄樹結構，請在命令提示字元或 PowerShell 執行: tree /F /A > tree_structure.txt)


# --- 組態設定 (可依需求修改) ---

# 1. 要忽略的資料夾名稱 (使用集合 set 查詢速度較快)
#    通常是版本控制、虛擬環境、相依性套件等
EXCLUDE_DIRS = {
    '.git', 'node_modules', '__pycache__', 'venv', '.vscode', 
    'dist', 'build', 'env', '.idea', 'target', '.DS_Store'
}

# 2. 要忽略的檔案類型 (副檔名)
#    通常是二進位檔案、日誌、壓縮檔等
EXCLUDE_EXTENSIONS = {
    '.pyc', '.pyo', '.o', '.so', '.dll', '.exe',
    '.img', '.iso', '.zip', '.tar', '.gz', '.rar',
    '.pdf', '.docx', '.xlsx', '.pptx', '.ort',
    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg',
    '.lock', '.log', '.swp', '.swo', '.stl', '.onnx'
}

# 3. (可選) 如果你只想包含特定類型的檔案，可以設定這個清單
#    如果此清單不是空的，腳本將只處理這些副檔名的檔案。
#    例如: INCLUDE_EXTENSIONS = {'.py', '.js', '.html', '.css'}
INCLUDE_EXTENSIONS = set() 

# --- 腳本主體 ---

def generate_code_dump(root_dir, output_filename):
    """
    遞迴掃描一個目錄，並將所有非忽略檔案的內容寫入單一輸出檔。
    """
    # 檢查根目錄是否存在
    if not os.path.isdir(root_dir):
        print(f"錯誤：目錄 '{root_dir}' 不存在。")
        return

    processed_files_count = 0
    
    try:
        # 使用 'w' (寫入模式) 和 utf-8 編碼開啟檔案
        # errors='ignore' 會在遇到無法解碼的字元時忽略它，避免因二進位檔案出錯
        with open(output_filename, 'w', encoding='utf-8', errors='ignore') as outfile:
            # 在輸出檔案的開頭加上標題
            outfile.write(f"# 專案程式碼彙整: {os.path.abspath(root_dir)}\n")
            outfile.write("=" * 80 + "\n\n")

            # os.walk 會遞迴地走過目錄樹
            for dirpath, dirnames, filenames in os.walk(root_dir, topdown=True):
                
                # --- 過濾資料夾 ---
                # 這是 os.walk 的一個技巧：直接修改 dirnames 列表，
                # os.walk 就不會再進入這些被移除的資料夾。
                dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]

                # 排序檔案，讓輸出結果更一致
                for filename in sorted(filenames):
                    # 取得檔案副檔名
                    _, extension = os.path.splitext(filename)
                    extension = extension.lower()

                    # --- 過濾檔案 ---
                    if extension in EXCLUDE_EXTENSIONS:
                        continue
                    
                    if INCLUDE_EXTENSIONS and extension not in INCLUDE_EXTENSIONS:
                        continue

                    # 組合完整檔案路徑
                    file_path = os.path.join(dirpath, filename)
                    
                    # 取得相對於根目錄的路徑，讓輸出更簡潔
                    relative_path = os.path.relpath(file_path, root_dir)

                    try:
                        # 寫入檔案分隔線和路徑標題
                        header = f"--- FILE: {relative_path.replace(os.sep, '/')} ---"
                        outfile.write("=" * 80 + "\n")
                        outfile.write(header + "\n")
                        outfile.write("-" * len(header) + "\n\n")
                        
                        print(f"正在處理: {relative_path}")

                        # 讀取原始檔案內容並寫入輸出檔
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as infile:
                            content = infile.read()
                            outfile.write(content)
                            outfile.write("\n\n")
                        
                        processed_files_count += 1

                    except Exception as e:
                        # 處理讀取檔案時可能發生的其他錯誤
                        error_msg = f"--- 無法讀取檔案: {relative_path} (錯誤: {e}) ---\n\n"
                        outfile.write(error_msg)
                        print(f"警告: {error_msg.strip()}")

        # 顯示成功訊息
        print("\n" + "=" * 80)
        print(f"✅ 成功！共處理了 {processed_files_count} 個檔案。")
        print(f"輸出結果已儲存至: {os.path.abspath(output_filename)}")
        print("=" * 80)

    except IOError as e:
        print(f"錯誤：無法寫入輸出檔案 '{output_filename}'。請檢查權限。 ({e})")
    except Exception as e:
        print(f"發生未預期的錯誤: {e}")


if __name__ == "__main__":
    # 決定要掃描的根目錄
    # 如果執行時有給參數，就用第一個參數當作路徑，否則使用當前目錄 "."
    target_dir = sys.argv[1] if len(sys.argv) > 1 else '.'
    
    # 決定輸出檔案的名稱
    output_file = 'project_dump.txt'
    
    # 執行主函式
    generate_code_dump(target_dir, output_file)

================================================================================
--- FILE: floating_controller.py ---
------------------------------------

# floating_controller.py
import mujoco
import numpy as np
from config import AppConfig

class FloatingController:
    """
    透過啟用/禁用 weld 約束和設定 mocap body 的位置，
    來將機器人主幹固定在空中。
    """
    def __init__(self, config: AppConfig, model, data):
        """
        初始化懸浮控制器，並獲取必要的 MuJoCo ID 和索引。
        """
        self.config = config.floating_controller
        self.model = model
        self.data = data
        self.is_functional = False
        
        try:
            anchor_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, 'anchor')
            if anchor_body_id == -1: raise ValueError("在 XML 中找不到名為 'anchor' 的 body。")
            
            self.mocap_index = model.body_mocapid[anchor_body_id]
            if self.mocap_index == -1: raise ValueError("'anchor' body 不是一個 mocap body。")

            self.weld_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_EQUALITY, 'torso_anchor_weld')
            if self.weld_id == -1: raise ValueError("在 XML 中找不到名為 'torso_anchor_weld' 的 weld 約束。")

            self.is_functional = True
            print(f"✅ 固定式懸浮控制器初始化完成。Mocap Index: {self.mocap_index}")
        except ValueError as e:
            print(f"❌ 懸浮控制器初始化錯誤: {e}")
            print("     請確保 scene_mjx.xml 檔案已正確定義 'anchor' body 和 'torso_anchor_weld' 約束。懸浮功能將被禁用。")

    def enable(self, current_pos: np.ndarray):
        """啟用懸浮模式。"""
        if not self.is_functional: return
        
        target_pos = np.array([current_pos[0], current_pos[1], self.config.target_height])
        self.data.mocap_pos[self.mocap_index] = target_pos
        self.data.mocap_quat[self.mocap_index] = np.array([1., 0, 0, 0]) # 保持水平姿態
        self.data.eq_active[self.weld_id] = 1
        print("🚀 已啟用固定懸浮模式。")

    def disable(self):
        """禁用懸浮模式。"""
        if not self.is_functional: return
        self.data.eq_active[self.weld_id] = 0
        print("🐾 已禁用固定懸浮模式。")

================================================================================
--- FILE: keyboard_input_handler.py ---
---------------------------------------

# keyboard_input_handler.py
import glfw
from state import SimulationState

class KeyboardInputHandler:
    """
    處理所有鍵盤輸入事件，包括對序列埠和關節測試模式的特殊處理。
    """
    def __init__(self, state: SimulationState):
        self.state = state
        self.config = state.config

    def register_callbacks(self, window):
        """註冊所有需要的 GLFW 回調。"""
        glfw.set_key_callback(window, self.key_callback)
        glfw.set_char_callback(window, self.char_callback)

    def char_callback(self, window, codepoint):
        """處理字元輸入，用於在 SERIAL_MODE 下建立指令。"""
        if self.state.control_mode == "SERIAL_MODE":
            self.state.serial_command_buffer += chr(codepoint)

    def key_callback(self, window, key, scancode, action, mods):
        """處理按鍵事件，根據不同模式分派邏輯。"""
        if action == glfw.PRESS:
            if key == glfw.KEY_SPACE:
                self.state.single_step_mode = not self.state.single_step_mode
                status = "PAUSED (Press N for next step)" if self.state.single_step_mode else "PLAYING"
                print(f"\n--- SIMULATION {status} ---")
                return

            if self.state.single_step_mode and key == glfw.KEY_N:
                self.state.execute_one_step = True
                return

        if self.state.control_mode == "SERIAL_MODE":
            if action == glfw.PRESS or action == glfw.REPEAT:
                if key == glfw.KEY_ENTER:
                    self.state.serial_command_to_send = self.state.serial_command_buffer
                    self.state.serial_command_buffer = ""
                elif key == glfw.KEY_BACKSPACE:
                    self.state.serial_command_buffer = self.state.serial_command_buffer[:-1]
                elif key == glfw.KEY_T and action == glfw.PRESS:
                    self.state.set_control_mode("WALKING")
            return

        if self.state.control_mode == "JOINT_TEST":
            if action == glfw.PRESS:
                if key == glfw.KEY_1: self.state.joint_test_index = (self.state.joint_test_index - 1) % 12
                elif key == glfw.KEY_2: self.state.joint_test_index = (self.state.joint_test_index + 1) % 12
                elif key == glfw.KEY_UP: self.state.joint_test_offsets[self.state.joint_test_index] += 0.1
                elif key == glfw.KEY_DOWN: self.state.joint_test_offsets[self.state.joint_test_index] -= 0.1
                elif key == glfw.KEY_C: self.state.joint_test_offsets.fill(0.0)
                elif key == glfw.KEY_G: self.state.set_control_mode("WALKING")
            return

        if action != glfw.PRESS: return

        if key == glfw.KEY_ESCAPE: glfw.set_window_should_close(window, 1); return
        if key == glfw.KEY_R: self.state.hard_reset_requested = True; return
        if key == glfw.KEY_TAB: self.state.display_page = (self.state.display_page + 1) % self.state.num_display_pages; return
        if key == glfw.KEY_M: self.state.toggle_input_mode("GAMEPAD" if self.state.input_mode == "KEYBOARD" else "KEYBOARD"); return
        
        # --- 新增：X 鍵觸發軟重置 ---
        if key == glfw.KEY_X:
            self.state.soft_reset_requested = True
            return
        
        if key == glfw.KEY_F:
            new_mode = "FLOATING" if self.state.control_mode == "WALKING" else "WALKING"
            self.state.set_control_mode(new_mode)
            return
        if key == glfw.KEY_T: self.state.set_control_mode("SERIAL_MODE"); return
        if key == glfw.KEY_G: self.state.set_control_mode("JOINT_TEST"); return

        if self.state.input_mode != "KEYBOARD": return
        
        step = self.config.keyboard_velocity_adjust_step
        if key == glfw.KEY_C: self.state.clear_command()
        elif key == glfw.KEY_W: self.state.command[1] += step
        elif key == glfw.KEY_S: self.state.command[1] -= step
        elif key == glfw.KEY_A: self.state.command[0] += step
        elif key == glfw.KEY_D: self.state.command[0] -= step
        elif key == glfw.KEY_Q: self.state.command[2] += step
        elif key == glfw.KEY_E: self.state.command[2] -= step

        params = self.state.tuning_params
        p_step = self.config.param_adjust_steps
        if key == glfw.KEY_I: params.kp += p_step['kp']
        elif key == glfw.KEY_K: params.kp -= p_step['kp']
        elif key == glfw.KEY_L: params.kd += p_step['kd']
        elif key == glfw.KEY_J: params.kd -= p_step['kd']
        elif key == glfw.KEY_Y: params.action_scale += p_step['action_scale']
        elif key == glfw.KEY_H: params.action_scale -= p_step['action_scale']
        elif key == glfw.KEY_P: params.bias += p_step['bias']
        elif key == glfw.KEY_SEMICOLON: params.bias -= p_step['bias']
        
        params.kp = max(0, params.kp)
        params.kd = max(0, params.kd)
        params.action_scale = max(0, params.action_scale)

================================================================================
--- FILE: main.py ---
---------------------

# main.py
import sys
import numpy as np
import mujoco

from config import load_config
from state import SimulationState
from simulation import Simulation
from policy import ONNXPolicy
from observation import ObservationBuilder
from rendering import DebugOverlay
from keyboard_input_handler import KeyboardInputHandler
from xbox_input_handler import XboxInputHandler
from floating_controller import FloatingController
from serial_communicator import SerialCommunicator

def main():
    """主程式入口：初始化所有組件並運行模擬迴圈。"""
    from xbox_controller import XboxController 
    print("\n--- 機器人模擬控制器 (多輸入模式版) ---")
    
    config = load_config()
    state = SimulationState(config)
    sim = Simulation(config)
    
    floating_controller = FloatingController(config, sim.model, sim.data)
    state.floating_controller_ref = floating_controller
    serial_comm = SerialCommunicator()
    
    keyboard_handler = KeyboardInputHandler(state)
    keyboard_handler.register_callbacks(sim.window)
    xbox_handler = XboxInputHandler(state)
    if xbox_handler.is_available():
        state.toggle_input_mode("GAMEPAD")
    
    try:
        assumed_dim = next(iter(config.observation_recipes))
        recipe = config.observation_recipes[assumed_dim]
    except StopIteration:
        sys.exit("❌ 錯誤: 在 config.yaml 中沒有定義任何 observation_recipes。")

    obs_builder = ObservationBuilder(recipe, sim.data, sim.model, sim.torso_id, sim.default_pose, config)
    base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
    policy = ONNXPolicy(config, base_obs_dim)
    
    if policy.model_input_dim != base_obs_dim:
        if policy.model_input_dim in config.observation_recipes:
            print(f"⚠️ 維度不匹配，自動切換到維度 {policy.model_input_dim} 的正確配方...")
            recipe = config.observation_recipes[policy.model_input_dim]
            # 重新初始化 ObservationBuilder 以使用新的配方
            obs_builder = ObservationBuilder(recipe, sim.data, sim.model, sim.torso_id, sim.default_pose, config)
            base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
        else:
            sys.exit(f"❌ 致命錯誤: 模型期望維度 ({policy.model_input_dim}) 與配方產生的觀察維度 ({base_obs_dim}) 不符，且找不到匹配配方！")

    ALL_OBS_DIMS = {'z_angular_velocity':1, 'gravity_vector':3, 'commands':3, 'joint_positions':12, 'joint_velocities':12, 'foot_contact_states':4, 'linear_velocity':3, 'angular_velocity':3, 'last_action':12, 'phase_signal':1}
    used_dims = {k: ALL_OBS_DIMS[k] for k in recipe if k in ALL_OBS_DIMS}
    overlay = DebugOverlay(recipe, used_dims)

    def hard_reset():
        """完全重置整個模擬環境。"""
        print("\n--- 正在執行完全重置 (Hard Reset) ---")
        sim.reset()
        policy.reset()
        if state.control_mode == "FLOATING":
            state.set_control_mode("WALKING")
        state.reset_control_state(sim.data.time)
        state.clear_command()
        state.hard_reset_requested = False

    def soft_reset():
        """僅重置機器人姿態和控制器狀態，不重置模擬時間和物理世界。"""
        print("\n--- 正在執行空中姿態重置 (Soft Reset) ---")
        sim.data.qpos[7:] = sim.default_pose
        sim.data.qvel[6:] = 0
        policy.reset()
        state.clear_command()
        mujoco.mj_forward(sim.model, sim.data)
        state.soft_reset_requested = False

    hard_reset()
    print("\n--- 模擬開始 (SPACE: 暫停, N:下一步) ---")
    print("    (F: 懸浮, G: 關節測試, T: 序列埠, M: 輸入模式, R: 硬重置, X: 軟重置)")

    state.execute_one_step = False

    while not sim.should_close():
        if state.single_step_mode and not state.execute_one_step:
            sim.render(state, overlay)
            continue
        if state.execute_one_step:
            state.execute_one_step = False

        if state.input_mode == "GAMEPAD": xbox_handler.update_state()
        
        if state.hard_reset_requested: hard_reset()
        if state.soft_reset_requested: soft_reset()

        state.latest_pos = sim.data.body('torso').xpos.copy()
        state.latest_quat = sim.data.body('torso').xquat.copy()
        if serial_comm.is_connected: state.serial_latest_messages = serial_comm.get_latest_messages()
        if state.serial_command_to_send:
            serial_comm.send_command(state.serial_command_to_send)
            state.serial_command_to_send = ""

        if state.control_mode != "SERIAL_MODE":
            # 1. 觀察 (現在是絕對角度)
            base_obs = obs_builder.get_observation(state.command, policy.last_action)
            # 2. 決策 (輸出目標絕對角度)
            onnx_input, action_raw = policy.get_action(base_obs)
            state.latest_onnx_input = onnx_input.flatten()
            state.latest_action_raw = action_raw

            # 3. 計算最終控制指令
            if state.control_mode == "JOINT_TEST":
                state.sim_mode_text = "Joint Test"
                final_ctrl = sim.default_pose + state.joint_test_offsets
            else:
                state.sim_mode_text = state.control_mode
                # =================================================================
                # === 【核心修改】將 AI 輸出解讀為絕對目標角度                     ===
                # === final_ctrl 直接等於 AI 的決策 (經過縮放)                ===
                # =================================================================
                final_ctrl = action_raw * state.tuning_params.action_scale
            
            # 4. 儲存並應用控制
            state.latest_final_ctrl = final_ctrl
            sim.apply_control(final_ctrl, state.tuning_params)
            
            # 5. 步進模擬
            target_time = sim.data.time + config.control_dt
            while sim.data.time < target_time:
                mujoco.mj_step(sim.model, sim.data)
        
        sim.render(state, overlay)

    sim.close()
    xbox_handler.close()
    serial_comm.close()
    print("\n模擬結束，程式退出。")

if __name__ == "__main__":
    main()

================================================================================
--- FILE: observation.py ---
----------------------------

# observation.py
import numpy as np
import mujoco
from config import AppConfig

class ObservationBuilder:
    def __init__(self, recipe: list, data, model, torso_id, default_pose, config: AppConfig):
        self.recipe = recipe
        self.data = data
        self.model = model
        self.torso_id = torso_id
        # 在絕對角度模式下，default_pose 主要用於重置和關節測試模式
        self.default_pose = default_pose
        self.config = config
        self._component_generators = self._register_components()
        for component in self.recipe:
            if component not in self._component_generators:
                print(f"⚠️ 警告: 觀察配方中的元件 '{component}' 沒有對應的產生器函式，將被忽略。")

    def _register_components(self):
        """註冊所有已知的觀察元件及其對應的產生器函式。"""
        return {
            'z_angular_velocity': self._get_z_angular_velocity,
            'gravity_vector': self._get_gravity_vector,
            'commands': self._get_commands,
            'joint_positions': self._get_joint_positions,
            'last_action': self._get_last_action,
            'linear_velocity': self._get_linear_velocity,
            'angular_velocity': self._get_full_angular_velocity,
            'joint_velocities': self._get_joint_velocities,
            'foot_contact_states': self._get_foot_contact_states,
            'phase_signal': self._get_phase_signal,
        }

    def get_observation(self, command, last_action) -> np.ndarray:
        """根據配方列表，依序呼叫產生器函式並拼接成最終的觀察向量。"""
        obs_list = []
        for name in self.recipe:
            if name in self._component_generators:
                obs_list.append(self._component_generators[name](command=command, last_action=last_action))
        
        if not obs_list:
            return np.array([], dtype=np.float32)

        return np.concatenate(obs_list).astype(np.float32)

    def _get_torso_inverse_rotation(self):
        """輔助函式：計算軀幹姿態的逆四元數。"""
        torso_quat = self.data.xquat[self.torso_id]
        norm = np.sum(np.square(torso_quat))
        if norm < 1e-8: torso_quat = np.array([1., 0, 0, 0])
        torso_quat /= np.sqrt(np.sum(np.square(torso_quat)))
        return np.array([torso_quat[0], -torso_quat[1], -torso_quat[2], -torso_quat[3]]) / np.sum(np.square(torso_quat))

    def _rotate_vec_by_quat_inv(self, v, q_inv):
        """輔助函式：使用逆四元數將世界座標系向量轉換為局部座標系。"""
        u, s = q_inv[1:], q_inv[0]
        return 2 * np.dot(u, v) * u + (s * s - np.dot(u, u)) * v + 2 * s * np.cross(u, v)

    def _get_z_angular_velocity(self, **kwargs):
        inv_torso_rot = self._get_torso_inverse_rotation()
        local_rpy_rate = self._rotate_vec_by_quat_inv(self.data.cvel[self.torso_id, 0:3], inv_torso_rot)
        return np.array([local_rpy_rate[2]]) * 0.25

    def _get_gravity_vector(self, **kwargs):
        inv_torso_rot = self._get_torso_inverse_rotation()
        return self._rotate_vec_by_quat_inv(np.array([0, 0, -1]), inv_torso_rot)

    def _get_commands(self, command, **kwargs):
        return command * np.array(self.config.command_scaling_factors) 

    def _get_joint_positions(self, **kwargs):
        # =================================================================
        # === 【核心修改】直接返回關節的【絕對角度】                    ===
        # === 這樣 AI 觀察到的就是真實的物理世界的角度值。            ===
        # =================================================================
        return self.data.qpos[7:]

    def _get_joint_velocities(self, **kwargs):
        return self.data.qvel[6:] * 0.05

    def _get_foot_contact_states(self, **kwargs):
        foot_geom_names = ['FR', 'FL', 'RR', 'RL']
        foot_geom_ids = [mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_GEOM, name) for name in foot_geom_names]
        contacts = np.zeros(4, dtype=np.float32)
        for i in range(self.data.ncon):
            con = self.data.contact[i]
            for foot_idx, foot_geom_id in enumerate(foot_geom_ids):
                if foot_geom_id != -1 and (con.geom1 == foot_geom_id or con.geom2 == foot_geom_id):
                    contacts[foot_idx] = 1.0
                    break
        return contacts

    def _get_last_action(self, last_action, **kwargs):
        # 在絕對角度模式下，last_action 就是上一個目標絕對角度
        return last_action

    def _get_linear_velocity(self, **kwargs):
        inv_torso_rot = self._get_torso_inverse_rotation()
        return self._rotate_vec_by_quat_inv(self.data.cvel[self.torso_id, 3:], inv_torso_rot)

    def _get_full_angular_velocity(self, **kwargs):
        inv_torso_rot = self._get_torso_inverse_rotation()
        return self._rotate_vec_by_quat_inv(self.data.cvel[self.torso_id, :3], inv_torso_rot)
        
    def _get_phase_signal(self, **kwargs):
        return np.array([self.data.time % 1.0], dtype=np.float32)

================================================================================
--- FILE: policy.py ---
-----------------------

# policy.py
import numpy as np
import onnxruntime as ort
import sys
import os
from collections import deque
from config import AppConfig

class ONNXPolicy:
    """
    封裝 ONNX 模型的載入、觀察歷史管理和推論邏輯。
    """
    def __init__(self, config: AppConfig, base_obs_dim: int):
        self.config = config
        self.base_obs_dim = base_obs_dim
        
        print(f"正在載入 ONNX 模型: {config.onnx_model_path}")
        sess_options = ort.SessionOptions()
        cache_path = os.path.splitext(config.onnx_model_path)[0] + ".optimized.ort"
        
        if os.path.exists(cache_path):
            print(f"⚡️ 發現優化模型快取，將從 '{cache_path}' 快速載入。")
        else:
            print(f"🐢 首次載入，將創建優化模型快取於 '{cache_path}' (可能需要一些時間)...")

        sess_options.optimized_model_filepath = cache_path
        sess_options.graph_optimization_level = ort.GraphOptimizationLevel.ORT_ENABLE_ALL

        try:
            self.sess = ort.InferenceSession(
                config.onnx_model_path, 
                sess_options=sess_options,
                providers=['CPUExecutionProvider']
            )
        except Exception as e:
            sys.exit(f"❌ 錯誤: 無法載入 ONNX 模型 '{config.onnx_model_path}': {e}")

        self.input_name = self.sess.get_inputs()[0].name
        self.output_name = self.sess.get_outputs()[0].name
        self.model_input_dim = self.sess.get_inputs()[0].shape[1]
        
        print(f"✅ 模型載入成功! 模型期望輸入維度: {self.model_input_dim}")
        self._determine_history_length()

        self.obs_history = deque(
            [np.zeros(self.base_obs_dim, dtype=np.float32)] * self.history_length, 
            maxlen=self.history_length
        )
        self.last_action = np.zeros(config.num_motors, dtype=np.float32)

    def _determine_history_length(self):
        """根據模型輸入維度和基礎觀察維度，自動計算歷史長度。"""
        if self.base_obs_dim == 0:
            print("⚠️ 警告: 基礎觀察維度為 0，無法計算歷史長度。")
            self.history_length = 0
            return
            
        if self.model_input_dim % self.base_obs_dim != 0:
            print(
                f"⚠️ 警告: 基礎觀察維度 ({self.base_obs_dim}) 無法整除模型輸入維度 "
                f"({self.model_input_dim})。歷史堆疊功能可能不準確。"
            )
            self.history_length = 1
        else:
            self.history_length = self.model_input_dim // self.base_obs_dim
        
        if self.history_length > 1:
            print(f"🤖 自動偵測到模型使用歷史堆疊，長度為: {self.history_length} 幀。")
        else:
            print("🤖 模型僅使用當前觀察 (歷史長度 = 1)。")

    def get_action(self, base_obs: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
        """根據當前的基礎觀察，更新歷史並執行模型推論，回傳動作。"""
        if self.history_length == 0:
            return np.array([]), np.zeros(self.config.num_motors)

        self.obs_history.append(base_obs)
        onnx_input = np.concatenate(list(self.obs_history)).astype(np.float32).reshape(1, -1)
        
        if onnx_input.shape[1] != self.model_input_dim:
            return onnx_input, np.zeros(self.config.num_motors)
            
        action_raw = self.sess.run([self.output_name], {self.input_name: onnx_input})[0].flatten()
        self.last_action[:] = action_raw
        return onnx_input, action_raw

    def reset(self):
        """重置觀察歷史和上一個動作。"""
        self.obs_history.clear()
        if self.history_length > 0:
            for _ in range(self.history_length):
                self.obs_history.append(np.zeros(self.base_obs_dim, dtype=np.float32))
        self.last_action.fill(0.0)
        print("✅ ONNX 策略狀態已重置。")

================================================================================
--- FILE: project_dump.txt ---
------------------------------

# 專案程式碼彙整: C:\git_project\simulation_test_recoil
================================================================================

================================================================================
--- FILE: config.py ---
-----------------------

# config.py
import yaml
from dataclasses import dataclass, field
from typing import Dict, List, Any

@dataclass
class TuningParamsConfig:
    """從設定檔載入的初始調校參數資料類別。"""
    kp: float
    kd: float
    action_scale: float
    bias: float

@dataclass
class FloatingControllerConfig:
    """懸浮控制器的設定。"""
    target_height: float
    kp_vertical: float
    kd_vertical: float
    kp_attitude: float
    kd_attitude: float

@dataclass
class AppConfig:
    """儲存所有應用程式設定的資料類別。"""
    mujoco_model_file: str
    onnx_model_path: str
    num_motors: int
    physics_timestep: float
    control_freq: float
    control_dt: float
    warmup_duration: float
    command_scaling_factors: List[float]
    
    keyboard_velocity_adjust_step: float
    gamepad_sensitivity: Dict[str, float]
    param_adjust_steps: Dict[str, float]

    initial_tuning_params: TuningParamsConfig
    observation_recipes: Dict[int, List[str]]
    floating_controller: FloatingControllerConfig

def load_config(path: str = "config.yaml") -> AppConfig:
    """
    從 YAML 檔案載入設定並回傳一個 AppConfig 物件。
    """
    try:
        with open(path, 'r', encoding='utf-8') as f:
            config_data = yaml.safe_load(f)
    except FileNotFoundError:
        raise FileNotFoundError(f"設定檔 '{path}' 不存在。請確保檔案路徑正確。")
    except Exception as e:
        raise IOError(f"讀取或解析設定檔 '{path}' 時發生錯誤: {e}")

    tuning_params = TuningParamsConfig(**config_data['initial_tuning_params'])
    floating_config = FloatingControllerConfig(**config_data['floating_controller'])
    
    config_obj = AppConfig(
        mujoco_model_file=config_data['mujoco_model_file'],
        onnx_model_path=config_data['onnx_model_path'],
        num_motors=config_data['num_motors'],
        physics_timestep=config_data['physics_timestep'],
        control_freq=config_data['control_freq'],
        control_dt=1.0 / config_data['control_freq'],
        warmup_duration=config_data['warmup_duration'],
        command_scaling_factors=config_data['command_scaling_factors'],
        
        keyboard_velocity_adjust_step=config_data['keyboard_velocity_adjust_step'],
        gamepad_sensitivity=config_data['gamepad_sensitivity'],
        param_adjust_steps=config_data['param_adjust_steps'],
        
        initial_tuning_params=tuning_params,
        observation_recipes=config_data['observation_recipes'],
        floating_controller=floating_config
    )
    
    print("✅ 設定檔載入成功 (包含懸浮控制器設定)。")
    return config_obj

================================================================================
--- FILE: config.yaml ---
-------------------------

# ==================================
# === 模擬與模型設定 (Simulation & Model Settings)
# ==================================
# 檔案路徑 (File Paths)
mujoco_model_file: "assets/scene_mjx.xml"
onnx_model_path: "models/pupper_ppo_policy_30965760_tf_converted_穩定步態版.onnx"

# 核心參數 (Core Parameters)
num_motors: 12
physics_timestep: 0.004 # <-- 建議修改：提高模擬精度以增強穩定性
control_freq: 50.0
warmup_duration: 0.0

# ONNX 模型命令輸入縮放因子
# 順序: [vy 縮放, vx 縮放, wz 縮放]
command_scaling_factors: [1.0, 1.0, 1.0] 

# ==================================
# === 輸入控制設定 (Input Control Settings)
# ==================================
keyboard_velocity_adjust_step: 0.1 # m/s or rad/s per key press

gamepad_sensitivity:
  vx: 1.0   # 前後速度靈敏度 (左搖桿 Y)
  vy: 1.0   # 左右速度靈敏度 (左搖桿 X)
  wz: -1.5  # 轉向角速度靈敏度 (右搖桿 X), 負值表示右推右轉

param_adjust_steps:
  kp: 0.5
  kd: 0.05
  action_scale: 0.05
  bias: 5

# ==================================
# === 初始調校參數 (Initial Tuning Parameters)
# ==================================
initial_tuning_params:
  kp: 5.0
  kd: 0.50
  action_scale: 0.5
  bias: -15.0

# ==================================
# === 觀察配方 (Observation Recipes)
# ==================================
observation_recipes:
  31:
    - 'z_angular_velocity'
    - 'gravity_vector'
    - 'commands'
    - 'joint_positions'
    - 'last_action'
  48:
    - 'linear_velocity'
    - 'angular_velocity'
    - 'gravity_vector'
    - 'commands'
    - 'joint_positions'
    - 'joint_velocities'
    - 'last_action'

# ================================================================= #
# === 懸浮控制器設定 (Floating Controller Settings) - 精細調校版 ===
# ================================================================= #
floating_controller:
  target_height: 0.50     # 懸浮的目標高度 (米)
  kp_vertical: 80.0       # 垂直 P (再次降低以求平滑)
  kd_vertical: 18.0       # 垂直 D (保持與Kp的關係)
  kp_attitude: 20.0       # 姿態 P (再次降低)
  kd_attitude: 4.0        # 姿態 D (相應調整)

================================================================================
--- FILE: dump_project.py ---
-----------------------------

import os
import sys

# (如需產生目錄樹結構，請在命令提示字元或 PowerShell 執行: tree /F /A > tree_structure.txt)


# --- 組態設定 (可依需求修改) ---

# 1. 要忽略的資料夾名稱 (使用集合 set 查詢速度較快)
#    通常是版本控制、虛擬環境、相依性套件等
EXCLUDE_DIRS = {
    '.git', 'node_modules', '__pycache__', 'venv', '.vscode', 
    'dist', 'build', 'env', '.idea', 'target', '.DS_Store'
}

# 2. 要忽略的檔案類型 (副檔名)
#    通常是二進位檔案、日誌、壓縮檔等
EXCLUDE_EXTENSIONS = {
    '.pyc', '.pyo', '.o', '.so', '.dll', '.exe',
    '.img', '.iso', '.zip', '.tar', '.gz', '.rar',
    '.pdf', '.docx', '.xlsx', '.pptx', '.ort',
    '.jpg', '.jpeg', '.png', '.gif', '.bmp', '.svg',
    '.lock', '.log', '.swp', '.swo', '.stl', '.onnx'
}

# 3. (可選) 如果你只想包含特定類型的檔案，可以設定這個清單
#    如果此清單不是空的，腳本將只處理這些副檔名的檔案。
#    例如: INCLUDE_EXTENSIONS = {'.py', '.js', '.html', '.css'}
INCLUDE_EXTENSIONS = set() 

# --- 腳本主體 ---

def generate_code_dump(root_dir, output_filename):
    """
    遞迴掃描一個目錄，並將所有非忽略檔案的內容寫入單一輸出檔。
    """
    # 檢查根目錄是否存在
    if not os.path.isdir(root_dir):
        print(f"錯誤：目錄 '{root_dir}' 不存在。")
        return

    processed_files_count = 0
    
    try:
        # 使用 'w' (寫入模式) 和 utf-8 編碼開啟檔案
        # errors='ignore' 會在遇到無法解碼的字元時忽略它，避免因二進位檔案出錯
        with open(output_filename, 'w', encoding='utf-8', errors='ignore') as outfile:
            # 在輸出檔案的開頭加上標題
            outfile.write(f"# 專案程式碼彙整: {os.path.abspath(root_dir)}\n")
            outfile.write("=" * 80 + "\n\n")

            # os.walk 會遞迴地走過目錄樹
            for dirpath, dirnames, filenames in os.walk(root_dir, topdown=True):
                
                # --- 過濾資料夾 ---
                # 這是 os.walk 的一個技巧：直接修改 dirnames 列表，
                # os.walk 就不會再進入這些被移除的資料夾。
                dirnames[:] = [d for d in dirnames if d not in EXCLUDE_DIRS]

                # 排序檔案，讓輸出結果更一致
                for filename in sorted(filenames):
                    # 取得檔案副檔名
                    _, extension = os.path.splitext(filename)
                    extension = extension.lower()

                    # --- 過濾檔案 ---
                    if extension in EXCLUDE_EXTENSIONS:
                        continue
                    
                    if INCLUDE_EXTENSIONS and extension not in INCLUDE_EXTENSIONS:
                        continue

                    # 組合完整檔案路徑
                    file_path = os.path.join(dirpath, filename)
                    
                    # 取得相對於根目錄的路徑，讓輸出更簡潔
                    relative_path = os.path.relpath(file_path, root_dir)

                    try:
                        # 寫入檔案分隔線和路徑標題
                        header = f"--- FILE: {relative_path.replace(os.sep, '/')} ---"
                        outfile.write("=" * 80 + "\n")
                        outfile.write(header + "\n")
                        outfile.write("-" * len(header) + "\n\n")
                        
                        print(f"正在處理: {relative_path}")

                        # 讀取原始檔案內容並寫入輸出檔
                        with open(file_path, 'r', encoding='utf-8', errors='ignore') as infile:
                            content = infile.read()
                            outfile.write(content)
                            outfile.write("\n\n")
                        
                        processed_files_count += 1

                    except Exception as e:
                        # 處理讀取檔案時可能發生的其他錯誤
                        error_msg = f"--- 無法讀取檔案: {relative_path} (錯誤: {e}) ---\n\n"
                        outfile.write(error_msg)
                        print(f"警告: {error_msg.strip()}")

        # 顯示成功訊息
        print("\n" + "=" * 80)
        print(f"✅ 成功！共處理了 {processed_files_count} 個檔案。")
        print(f"輸出結果已儲存至: {os.path.abspath(output_filename)}")
        print("=" * 80)

    except IOError as e:
        print(f"錯誤：無法寫入輸出檔案 '{output_filename}'。請檢查權限。 ({e})")
    except Exception as e:
        print(f"發生未預期的錯誤: {e}")


if __name__ == "__main__":
    # 決定要掃描的根目錄
    # 如果執行時有給參數，就用第一個參數當作路徑，否則使用當前目錄 "."
    target_dir = sys.argv[1] if len(sys.argv) > 1 else '.'
    
    # 決定輸出檔案的名稱
    output_file = 'project_dump.txt'
    
    # 執行主函式
    generate_code_dump(target_dir, output_file)

================================================================================
--- FILE: floating_controller.py ---
------------------------------------

# floating_controller.py
import mujoco
import numpy as np
from config import AppConfig

class FloatingController:
    """
    透過啟用/禁用 weld 約束和設定 mocap body 的位置，
    來將機器人主幹固定在空中。
    """
    def __init__(self, config: AppConfig, model, data):
        """
        初始化懸浮控制器，並獲取必要的 MuJoCo ID 和索引。
        """
        self.config = config.floating_controller
        self.model = model
        self.data = data
        self.is_functional = False
        
        try:
            anchor_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, 'anchor')
            if anchor_body_id == -1: raise ValueError("在 XML 中找不到名為 'anchor' 的 body。")
            
            self.mocap_index = model.body_mocapid[anchor_body_id]
            if self.mocap_index == -1: raise ValueError("'anchor' body 不是一個 mocap body。")

            self.weld_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_EQUALITY, 'torso_anchor_weld')
            if self.weld_id == -1: raise ValueError("在 XML 中找不到名為 'torso_anchor_weld' 的 weld 約束。")

            self.is_functional = True
            print(f"✅ 固定式懸浮控制器初始化完成。Mocap Index: {self.mocap_index}")
        except ValueError as e:
            print(f"❌ 懸浮控制器初始化錯誤: {e}")
            print("     請確保 scene_mjx.xml 檔案已正確定義 'anchor' body 和 'torso_anchor_weld' 約束。懸浮功能將被禁用。")

    def enable(self, current_pos: np.ndarray):
        """啟用懸浮模式。"""
        if not self.is_functional: return
        
        target_pos = np.array([current_pos[0], current_pos[1], self.config.target_height])
        self.data.mocap_pos[self.mocap_index] = target_pos
        self.data.mocap_quat[self.mocap_index] = np.array([1., 0, 0, 0]) # 保持水平姿態
        self.data.eq_active[self.weld_id] = 1
        print("🚀 已啟用固定懸浮模式。")

    def disable(self):
        """禁用懸浮模式。"""
        if not self.is_functional: return
        self.data.eq_active[self.weld_id] = 0
        print("🐾 已禁用固定懸浮模式。")

================================================================================
--- FILE: keyboard_input_handler.py ---
---------------------------------------

# keyboard_input_handler.py
import glfw
from state import SimulationState

class KeyboardInputHandler:
    """
    處理所有鍵盤輸入事件，包括對序列埠和關節測試模式的特殊處理。
    """
    def __init__(self, state: SimulationState):
        self.state = state
        self.config = state.config

    def register_callbacks(self, window):
        """註冊所有需要的 GLFW 回調。"""
        glfw.set_key_callback(window, self.key_callback)
        glfw.set_char_callback(window, self.char_callback)

    def char_callback(self, window, codepoint):
        """處理字元輸入，用於在 SERIAL_MODE 下建立指令。"""
        if self.state.control_mode == "SERIAL_MODE":
            self.state.serial_command_buffer += chr(codepoint)

    def key_callback(self, window, key, scancode, action, mods):
        """處理按鍵事件，根據不同模式分派邏輯。"""
        if action == glfw.PRESS:
            if key == glfw.KEY_SPACE:
                self.state.single_step_mode = not self.state.single_step_mode
                status = "PAUSED (Press N for next step)" if self.state.single_step_mode else "PLAYING"
                print(f"\n--- SIMULATION {status} ---")
                return

            if self.state.single_step_mode and key == glfw.KEY_N:
                self.state.execute_one_step = True
                return

        if self.state.control_mode == "SERIAL_MODE":
            if action == glfw.PRESS or action == glfw.REPEAT:
                if key == glfw.KEY_ENTER:
                    self.state.serial_command_to_send = self.state.serial_command_buffer
                    self.state.serial_command_buffer = ""
                elif key == glfw.KEY_BACKSPACE:
                    self.state.serial_command_buffer = self.state.serial_command_buffer[:-1]
                elif key == glfw.KEY_T and action == glfw.PRESS:
                    self.state.set_control_mode("WALKING")
            return

        if self.state.control_mode == "JOINT_TEST":
            if action == glfw.PRESS:
                if key == glfw.KEY_1: self.state.joint_test_index = (self.state.joint_test_index - 1) % 12
                elif key == glfw.KEY_2: self.state.joint_test_index = (self.state.joint_test_index + 1) % 12
                elif key == glfw.KEY_UP: self.state.joint_test_offsets[self.state.joint_test_index] += 0.1
                elif key == glfw.KEY_DOWN: self.state.joint_test_offsets[self.state.joint_test_index] -= 0.1
                elif key == glfw.KEY_C: self.state.joint_test_offsets.fill(0.0)
                elif key == glfw.KEY_G: self.state.set_control_mode("WALKING")
            return

        if action != glfw.PRESS: return

        if key == glfw.KEY_ESCAPE: glfw.set_window_should_close(window, 1); return
        if key == glfw.KEY_R: self.state.hard_reset_requested = True; return
        if key == glfw.KEY_TAB: self.state.display_page = (self.state.display_page + 1) % self.state.num_display_pages; return
        if key == glfw.KEY_M: self.state.toggle_input_mode("GAMEPAD" if self.state.input_mode == "KEYBOARD" else "KEYBOARD"); return
        
        # --- 新增：X 鍵觸發軟重置 ---
        if key == glfw.KEY_X:
            self.state.soft_reset_requested = True
            return
        
        if key == glfw.KEY_F:
            new_mode = "FLOATING" if self.state.control_mode == "WALKING" else "WALKING"
            self.state.set_control_mode(new_mode)
            return
        if key == glfw.KEY_T: self.state.set_control_mode("SERIAL_MODE"); return
        if key == glfw.KEY_G: self.state.set_control_mode("JOINT_TEST"); return

        if self.state.input_mode != "KEYBOARD": return
        
        step = self.config.keyboard_velocity_adjust_step
        if key == glfw.KEY_C: self.state.clear_command()
        elif key == glfw.KEY_W: self.state.command[1] += step
        elif key == glfw.KEY_S: self.state.command[1] -= step
        elif key == glfw.KEY_A: self.state.command[0] += step
        elif key == glfw.KEY_D: self.state.command[0] -= step
        elif key == glfw.KEY_Q: self.state.command[2] += step
        elif key == glfw.KEY_E: self.state.command[2] -= step

        params = self.state.tuning_params
        p_step = self.config.param_adjust_steps
        if key == glfw.KEY_I: params.kp += p_step['kp']
        elif key == glfw.KEY_K: params.kp -= p_step['kp']
        elif key == glfw.KEY_L: params.kd += p_step['kd']
        elif key == glfw.KEY_J: params.kd -= p_step['kd']
        elif key == glfw.KEY_Y: params.action_scale += p_step['action_scale']
        elif key == glfw.KEY_H: params.action_scale -= p_step['action_scale']
        elif key == glfw.KEY_P: params.bias += p_step['bias']
        elif key == glfw.KEY_SEMICOLON: params.bias -= p_step['bias']
        
        params.kp = max(0, params.kp)
        params.kd = max(0, params.kd)
        params.action_scale = max(0, params.action_scale)

================================================================================
--- FILE: main.py ---
---------------------

# main.py
import sys
import numpy as np
import mujoco

from config import load_config
from state import SimulationState
from simulation import Simulation
from policy import ONNXPolicy
from observation import ObservationBuilder
from rendering import DebugOverlay
from keyboard_input_handler import KeyboardInputHandler
from xbox_input_handler import XboxInputHandler
from floating_controller import FloatingController
from serial_communicator import SerialCommunicator

def main():
    """主程式入口：初始化所有組件並運行模擬迴圈。"""
    from xbox_controller import XboxController 
    print("\n--- 機器人模擬控制器 (多輸入模式版) ---")
    
    config = load_config()
    state = SimulationState(config)
    sim = Simulation(config)
    
    floating_controller = FloatingController(config, sim.model, sim.data)
    state.floating_controller_ref = floating_controller
    serial_comm = SerialCommunicator()
    
    keyboard_handler = KeyboardInputHandler(state)
    keyboard_handler.register_callbacks(sim.window)
    xbox_handler = XboxInputHandler(state)
    if xbox_handler.is_available():
        state.toggle_input_mode("GAMEPAD")
    
    try:
        assumed_dim = next(iter(config.observation_recipes))
        recipe = config.observation_recipes[assumed_dim]
    except StopIteration:
        sys.exit("❌ 錯誤: 在 config.yaml 中沒有定義任何 observation_recipes。")

    obs_builder = ObservationBuilder(recipe, sim.data, sim.model, sim.torso_id, sim.default_pose, config)
    base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
    policy = ONNXPolicy(config, base_obs_dim)
    
    if policy.model_input_dim != base_obs_dim:
        if policy.model_input_dim in config.observation_recipes:
            print(f"⚠️ 維度不匹配，自動切換到維度 {policy.model_input_dim} 的正確配方...")
            recipe = config.observation_recipes[policy.model_input_dim]
            # 重新初始化 ObservationBuilder 以使用新的配方
            obs_builder = ObservationBuilder(recipe, sim.data, sim.model, sim.torso_id, sim.default_pose, config)
            base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
        else:
            sys.exit(f"❌ 致命錯誤: 模型期望維度 ({policy.model_input_dim}) 與配方產生的觀察維度 ({base_obs_dim}) 不符，且找不到匹配配方！")

    ALL_OBS_DIMS = {'z_angular_velocity':1, 'gravity_vector':3, 'commands':3, 'joint_positions':12, 'joint_velocities':12, 'foot_contact_states':4, 'linear_velocity':3, 'angular_velocity':3, 'last_action':12, 'phase_signal':1}
    used_dims = {k: ALL_OBS_DIMS[k] for k in recipe if k in ALL_OBS_DIMS}
    overlay = DebugOverlay(recipe, used_dims)

    def hard_reset():
        """完全重置整個模擬環境。"""
        print("\n--- 正在執行完全重置 (Hard Reset) ---")
        sim.reset()
        policy.reset()
        if state.control_mode == "FLOATING":
            state.set_control_mode("WALKING")
        state.reset_control_state(sim.data.time)
        state.clear_command()
        state.hard_reset_requested = False

    def soft_reset():
        """僅重置機器人姿態和控制器狀態，不重置模擬時間和物理世界。"""
        print("\n--- 正在執行空中姿態重置 (Soft Reset) ---")
        sim.data.qpos[7:] = sim.default_pose
        sim.data.qvel[6:] = 0
        policy.reset()
        state.clear_command()
        mujoco.mj_forward(sim.model, sim.data)
        state.soft_reset_requested = False

    hard_reset()
    print("\n--- 模擬開始 (SPACE: 暫停, N:下一步) ---")
    print("    (F: 懸浮, G: 關節測試, T: 序列埠, M: 輸入模式, R: 硬重置, X: 軟重置)")

    state.execute_one_step = False

    while not sim.should_close():
        if state.single_step_mode and not state.execute_one_step:
            sim.render(state, overlay)
            continue
        if state.execute_one_step:
            state.execute_one_step = False

        if state.input_mode == "GAMEPAD": xbox_handler.update_state()
        
        if state.hard_reset_requested: hard_reset()
        if state.soft_reset_requested: soft_reset()

        state.latest_pos = sim.data.body('torso').xpos.copy()
        state.latest_quat = sim.data.body('torso').xquat.copy()
        if serial_comm.is_connected: state.serial_latest_messages = serial_comm.get_latest_messages()
        if state.serial_command_to_send:
            serial_comm.send_command(state.serial_command_to_send)
            state.serial_command_to_send = ""

        if state.control_mode != "SERIAL_MODE":
            # 1. 觀察 (現在是絕對角度)
            base_obs = obs_builder.get_observation(state.command, policy.last_action)
            # 2. 決策 (輸出目標絕對角度)
            onnx_input, action_raw = policy.get_action(base_obs)
            state.latest_onnx_input = onnx_input.flatten()
            state.latest_action_raw = action_raw

            # 3. 計算最終控制指令
            if state.control_mode == "JOINT_TEST":
                state.sim_mode_text = "Joint Test"
                final_ctrl = sim.default_pose + state.joint_test_offsets
            else:
                state.sim_mode_text = state.control_mode
                # =================================================================
                # === 【核心修改】將 AI 輸出解讀為絕對目標角度                     ===
                # === final_ctrl 直接等於 AI 的決策 (經過縮放)                ===
                # =================================================================
                final_ctrl = action_raw * state.tuning_params.action_scale
            
            # 4. 儲存並應用控制
            state.latest_final_ctrl = final_ctrl
            sim.apply_control(final_ctrl, state.tuning_params)
            
            # 5. 步進模擬
            target_time = sim.data.time + config.control_dt
            while sim.data.time < target_time:
                mujoco.mj_step(sim.model, sim.data)
        
        sim.render(state, overlay)

    sim.close()
    xbox_handler.close()
    serial_comm.close()
    print("\n模擬結束，程式退出。")

if __name__ == "__main__":
    main()

================================================================================
--- FILE: observation.py ---
----------------------------



================================================================================
--- FILE: readme.md ---
-----------------------

前置安裝：你需要安裝 PyYAML。在你的終端機中執行：
pip install onnxruntime numpy
pip install PyYAML
pip install mujoco glfw //這個看看環境有沒有載，我不是用這個
pip install inputs //搖桿用的
pip install pygame
pip install pyserial



================================================================================
--- FILE: rendering.py ---
--------------------------

# rendering.py
import mujoco
import numpy as np
import time
from state import SimulationState
from typing import TYPE_CHECKING, List, Dict

if TYPE_CHECKING:
    from simulation import Simulation

class DebugOverlay:
    """
    負責在 MuJoCo 視窗上渲染所有文字除錯資訊。
    """
    def __init__(self, recipe: List[str], recipe_dims: Dict[str, int]):
        self.recipe = recipe
        self.component_dims = recipe_dims
        self.display_pages_content = [
            ['linear_velocity', 'angular_velocity', 'gravity_vector', 'commands'],
            ['joint_positions', 'joint_velocities', 'last_action'],
        ]
        state_class_ref = SimulationState
        state_class_ref.num_display_pages = len(self.display_pages_content)

    def render(self, viewport, context, state: SimulationState, sim: "Simulation"):
        """根據當前控制模式，選擇並呼叫對應的渲染函式。"""
        if state.control_mode == "SERIAL_MODE":
            self.render_serial_console(viewport, context, state)
        elif state.control_mode == "JOINT_TEST":
            self.render_joint_test_overlay(viewport, context, state, sim)
        else:
            self.render_simulation_overlay(viewport, context, state, sim)

    def render_serial_console(self, viewport, context, state: SimulationState):
        """渲染一個全螢幕的序列埠控制台介面。"""
        mujoco.mjr_rectangle(viewport, 0.2, 0.2, 0.2, 0.9)
        title = "--- SERIAL CONSOLE MODE (Press T to exit) ---"
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_BIG, mujoco.mjtGridPos.mjGRID_TOPLEFT, viewport, title, None, context)
        log_text = "\n".join(state.serial_latest_messages)
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, viewport, "\n\n" + log_text, " ", context)
        cursor = "_" if int(time.time() * 2) % 2 == 0 else " "
        buffer_text = f"> {state.serial_command_buffer}{cursor}"
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_BOTTOMLEFT, viewport, buffer_text, None, context)
    
    def render_joint_test_overlay(self, viewport, context, state: SimulationState, sim: "Simulation"):
        """渲染關節手動測試模式的專用介面。"""
        mujoco.mjr_rectangle(viewport, 0.2, 0.25, 0.3, 0.9)
        help_text = (
            "--- JOINT TEST MODE ---\n\n"
            "Press '1' / '2' to Select Joint\n"
            "Press UP / DOWN to Adjust Offset\n"
            "Press 'C' to Clear All Offsets\n\n"
            "Press 'G' to Return to Walking Mode"
        )
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_BIG, mujoco.mjtGridPos.mjGRID_TOPRIGHT, viewport, help_text, None, context)
        joint_names = [
            "0: FR_Abduction", "1: FR_Hip", "2: FR_Knee",
            "3: FL_Abduction", "4: FL_Hip", "5: FL_Knee",
            "6: RR_Abduction", "7: RR_Hip", "8: RR_Knee",
            "9: RL_Abduction", "10: RL_Hip", "11: RL_Knee"
        ]
        num_joints_per_col = 6
        left_col_text, right_col_text = "", ""
        for i, name in enumerate(joint_names):
            prefix = ">> " if i == state.joint_test_index else "   "
            offset_val = state.joint_test_offsets[i]
            final_val = sim.default_pose[i] + offset_val
            line_text = f"{prefix}{name:<15}: Offset={offset_val:+.2f}, Final={final_val:+.2f}\n"
            if i < num_joints_per_col: left_col_text += line_text
            else: right_col_text += line_text
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, viewport, left_col_text, None, context)
        right_col_rect = mujoco.MjrRect(int(viewport.width * 0.3), 0, int(viewport.width * 0.3), viewport.height)
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, right_col_rect, right_col_text, None, context)

    def render_simulation_overlay(self, viewport, context, state: SimulationState, sim: "Simulation"):
        """渲染正常的模擬除錯資訊。"""
        def format_vec(label: str, vec, precision=3, label_width=24):
            if vec is None or vec.size == 0: return f"{label:<{label_width}}None"
            vec_str = np.array2string(vec, precision=precision, floatmode='fixed', suppress_small=True, threshold=100)
            return f"{label:<{label_width}}{vec_str}"

        help_text = (
            "--- CONTROLS ---\n\n"
            "[Universal]\n"
            "  SPACE: Pause/Play | N: Next Step\n" # <-- 已更新
            "  F: Float | G: Joint Test | T: Serial\n"
            "  ESC: Exit       | R: Reset\n"
            "  X: Soft Reset (in Float/Test mode)\n" # <-- 新增此行
            "  M: Input Mode   | TAB: Info Page\n"
            "  C: Clear Cmd (Keyboard)\n\n"
            "[Keyboard Mode]\n"
            "  WASD/QE: Move/Turn\n"
            "  I/K: Kp | L/J: Kd\n"
            "  Y/H: ActScl | P/;: Bias\n\n"
            "[Gamepad Mode]\n"
            "  L-Stick: Move | R-Stick: Turn\n"
            "  D-Pad U/D: Kp | D-Pad R/L: Kd\n"
            "  LB/RB: ActScl | Y/A: Bias\n"
            "  Select/View: Reset"
        )
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPRIGHT, viewport, help_text, None, context)

        p = state.tuning_params
        top_left_text = (
            f"Mode: {state.control_mode} | Input: {state.input_mode}\n"
            f"Time: {sim.data.time:.2f} s\n\n"
            f"--- Tuning Params ---\n"
            f"{format_vec('Kp:', np.array([p.kp]), 1)}\n"
            f"{format_vec('Kd:', np.array([p.kd]), 2)}\n"
            f"{format_vec('Act Scale:', np.array([p.action_scale]), 3)}\n"
            f"{format_vec('Bias:', np.array([p.bias]), 1)}\n\n"
            f"--- Command ---\n"
            f"{format_vec('User Cmd:', state.command)}\n"
        )
        if state.control_mode == "FLOATING":
            current_height = sim.data.qpos[2]
            target_height = sim.config.floating_controller.target_height
            top_left_text += (
                f"\n--- Floating Info ---\n"
                f"{format_vec('Target H:', np.array([target_height]), 3)}\n"
                f"{format_vec('Current H:', np.array([current_height]), 3)}\n"
            )
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_TOPLEFT, viewport, top_left_text, None, context)
        
        bottom_left_text = f"--- ONNX INPUTS (Page {state.display_page + 1}/{state.num_display_pages}) ---\n"
        onnx_input_vec = state.latest_onnx_input
        if onnx_input_vec.size > 0 and state.display_page < len(self.display_pages_content):
            current_page_components = self.display_pages_content[state.display_page]
            base_obs_dim = sum(self.component_dims.values()) if self.component_dims else 0
            if base_obs_dim > 0:
                history_len = len(onnx_input_vec) // base_obs_dim
                current_full_obs_idx = 0
                for comp_name_in_recipe in self.recipe:
                    dim = self.component_dims.get(comp_name_in_recipe, 0)
                    if dim > 0:
                        if comp_name_in_recipe in current_page_components:
                            start_idx, end_idx = current_full_obs_idx, current_full_obs_idx + dim
                            value_slice = onnx_input_vec[start_idx:end_idx]
                            bottom_left_text += format_vec(f"{comp_name_in_recipe} [{dim}d]:", value_slice, 2) + "\n"
                        current_full_obs_idx += dim
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_BOTTOMLEFT, viewport, bottom_left_text, None, context)
        
        torso_lin_vel = sim.data.cvel[sim.torso_id, 3:]
        torso_ang_vel_local = self._get_local_ang_vel(sim.data, sim.torso_id)
        bottom_right_text = (
            f"--- ONNX OUTPUTS & STATE ---\n"
            f"{format_vec('Raw Action:', state.latest_action_raw)}\n"
            f"{format_vec('Final Ctrl:', state.latest_final_ctrl)}\n\n"
            f"--- Robot State ---\n"
            f"{format_vec('Torso Z:', np.array([sim.data.qpos[2]]))}\n"
            f"{format_vec('Lin Vel (World):', torso_lin_vel)}\n"
            f"{format_vec('Ang Vel (Local):', torso_ang_vel_local)}"
        )
        mujoco.mjr_overlay(mujoco.mjtFont.mjFONT_NORMAL, mujoco.mjtGridPos.mjGRID_BOTTOMRIGHT, viewport, bottom_right_text, None, context)
    
    def _get_local_ang_vel(self, data, torso_id):
        """輔助函式，計算局部角速度用於顯示。"""
        torso_quat = data.xquat[torso_id]
        norm = np.sum(np.square(torso_quat))
        if norm < 1e-8: return np.zeros(3)
        torso_quat /= np.sqrt(norm)
        q_inv = np.array([torso_quat[0], -torso_quat[1], -torso_quat[2], -torso_quat[3]]) / norm
        u, s = q_inv[1:], q_inv[0]
        world_ang_vel = data.cvel[torso_id, :3]
        return 2 * np.dot(u, world_ang_vel) * u + (s*s - np.dot(u, u)) * world_ang_vel + 2*s*np.cross(u, world_ang_vel)

================================================================================
--- FILE: serial_communicator.py ---
------------------------------------

# serial_communicator.py
import serial
import time
import sys
import threading
import serial.tools.list_ports
from collections import deque

class SerialCommunicator:
    """
    一個類別，封裝了與序列埠設備的通訊邏輯。
    它使用背景執行緒來非阻塞地讀取數據。
    """
    def __init__(self, max_log_lines=15):
        """
        初始化通訊器，掃描並讓使用者選擇埠。
        """
        self.ser = None
        self.read_thread = None
        self.exit_signal = threading.Event()
        self.is_connected = False
        
        # 使用 deque 來儲存最新的幾行日誌，用於在畫面上顯示
        self.message_log = deque(maxlen=max_log_lines)
        
        self.port_name = self._select_serial_port()
        if self.port_name:
            self.connect()

    def _select_serial_port(self):
        """
        掃描並讓使用者選擇序列埠。優先自動檢測 Teensy。
        返回選定的序列埠名稱，如果找不到則返回 None。
        """
        print("正在掃描可用的序列埠...")
        ports = serial.tools.list_ports.comports()
        if not ports:
            print("--- 警告: 未找到任何序列埠。序列埠功能將被禁用。 ---")
            return None

        # 嘗試根據 VID/PID 自動識別 Teensy
        teensy_ports = [p for p in ports if p.vid == 0x16C0 and p.pid == 0x0483]
        if len(teensy_ports) == 1:
            print(f"自動檢測到 Teensy: {teensy_ports[0].device}")
            return teensy_ports[0].device
        
        # 如果自動識別失敗，讓使用者手動選擇
        print("\n請從以下列表中選擇您的 Teensy 設備:")
        for i, port in enumerate(ports):
            print(f"  [{i}] {port.device} - {port.description}")
        while True:
            try:
                # 允許使用者直接按 Enter 跳過選擇
                choice_str = input(f"請輸入選擇的編號 (0-{len(ports)-1}) 或直接按 Enter 跳過: ")
                if not choice_str:
                    print("已跳過序列埠選擇。")
                    return None
                choice = int(choice_str)
                if 0 <= choice < len(ports):
                    return ports[choice].device
                else:
                    print("輸入無效，請重新輸入。")
            except (ValueError, IndexError):
                print("輸入無效，請輸入列表中的數字。")

    def connect(self, baud_rate=115200):
        """連接到指定的序列埠並啟動讀取執行緒。"""
        if not self.port_name: return
        try:
            print(f"\n正在連接到 {self.port_name}...")
            self.ser = serial.Serial(self.port_name, baud_rate, timeout=0.1)
            time.sleep(0.5) # 等待設備重啟
            self.ser.reset_input_buffer()
            self.ser.reset_output_buffer()
            print("✅ 序列埠連接成功。")

            self.exit_signal.clear()
            self.read_thread = threading.Thread(target=self._read_from_port, daemon=True)
            self.read_thread.start()
            self.is_connected = True

        except serial.SerialException as e:
            print(f"❌ 序列埠連接失敗: {e}")
            self.is_connected = False

    def _read_from_port(self):
        """在背景執行緒中讀取數據並存入日誌。"""
        while not self.exit_signal.is_set():
            try:
                if self.ser and self.ser.is_open and self.ser.in_waiting > 0:
                    response = self.ser.readline().decode('utf-8', 'ignore').strip()
                    if response:
                        self.message_log.append(response) # 將訊息加入日誌
            except serial.SerialException:
                self.message_log.append("[錯誤] 序列埠已斷開。")
                self.is_connected = False
                break
            time.sleep(0.01)

    def send_command(self, command: str):
        """向序列埠發送指令。"""
        if self.is_connected and command:
            try:
                command_to_send = command + '\n'
                self.ser.write(command_to_send.encode('utf-8'))
                self.message_log.append(f"> {command}") # 將發送的指令也加入日誌
            except serial.SerialException as e:
                 self.message_log.append(f"[錯誤] 發送失敗: {e}")
                 self.is_connected = False


    def get_latest_messages(self) -> list:
        """獲取日誌中的所有訊息。"""
        return list(self.message_log)

    def close(self):
        """安全地關閉序列埠和讀取執行緒。"""
        if self.read_thread:
            self.exit_signal.set()
            if self.read_thread.is_alive():
                self.read_thread.join(timeout=1)
        if self.ser and self.ser.is_open:
            self.ser.close()
            print(f"序列埠 {self.port_name} 已安全關閉。")
        self.is_connected = False

================================================================================
--- FILE: simulation.py ---
---------------------------

# simulation.py
import mujoco
import glfw
import sys
import numpy as np
from typing import TYPE_CHECKING

from config import AppConfig
from state import SimulationState, TuningParams

# 使用 TYPE_CHECKING 來避免循環導入，同時又能獲得 Pylance/MyPy 的型別提示
if TYPE_CHECKING:
    from rendering import DebugOverlay
    from keyboard_input_handler import KeyboardInputHandler

class Simulation:
    """
    封裝 MuJoCo 模擬、GLFW 視窗和渲染邏輯。
    新增了完整的滑鼠視角控制功能。
    """
    def __init__(self, config: AppConfig):
        """初始化 MuJoCo 模型、資料、GLFW 視窗以及滑鼠控制相關狀態。"""
        self.config = config
        
        try:
            self.model = mujoco.MjModel.from_xml_path(config.mujoco_model_file)
        except Exception as e:
            sys.exit(f"❌ 錯誤: 無法載入 XML 檔案 '{config.mujoco_model_file}': {e}")
            
        self.data = mujoco.MjData(self.model)
        self.model.opt.timestep = config.physics_timestep

        self.torso_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, 'torso')
        if self.torso_id == -1:
            sys.exit("❌ 錯誤: 在 XML 中找不到名為 'torso' 的 body。")
        
        home_key_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_KEY, 'home')
        if home_key_id != -1:
            self.default_pose = self.model.key_qpos[home_key_id][7:].copy()
        else:
            self.default_pose = np.zeros(config.num_motors)
            print("⚠️ 警告: 在 XML 中未找到名為 'home' 的 keyframe，將使用零作為預設姿態。")

        if not glfw.init(): sys.exit("❌ 錯誤: GLFW 初始化失敗。")
        self.window = glfw.create_window(1200, 900, "MuJoCo 模擬器 (含滑鼠控制)", None, None)
        if not self.window:
            glfw.terminate()
            sys.exit("❌ 錯誤: GLFW 視窗建立失敗。")
        glfw.make_context_current(self.window)
        glfw.swap_interval(1)

        # --- 新增：初始化滑鼠控制所需變數 ---
        self.mouse_button_left = False
        self.mouse_button_right = False
        self.last_mouse_x = 0
        self.last_mouse_y = 0
        # --- 新增結束 ---

        self.cam = mujoco.MjvCamera()
        self.opt = mujoco.MjvOption()
        mujoco.mjv_defaultCamera(self.cam)
        mujoco.mjv_defaultOption(self.opt)
        self.cam.distance, self.cam.elevation, self.cam.azimuth = 2.5, -20, 90
        
        self.scene = mujoco.MjvScene(self.model, maxgeom=10000)
        
        # --- 根據您的要求，將字體大小設定為 100% ---
        self.context = mujoco.MjrContext(self.model, mujoco.mjtFontScale.mjFONTSCALE_100)
        
        # --- 新增：註冊滑鼠相關的回調函式 ---
        glfw.set_cursor_pos_callback(self.window, self._mouse_move_callback)
        glfw.set_mouse_button_callback(self.window, self._mouse_button_callback)
        glfw.set_scroll_callback(self.window, self._scroll_callback)
        # --- 新增結束 ---

        print("✅ MuJoCo 模擬環境與視窗初始化完成 (含滑鼠控制)。")

    # --- 新增：滑鼠事件回調函式 ---
    def _mouse_button_callback(self, window, button, action, mods):
        """處理滑鼠按鍵按下和釋放事件。"""
        if button == glfw.MOUSE_BUTTON_LEFT:
            if action == glfw.PRESS:
                self.mouse_button_left = True
                self.last_mouse_x, self.last_mouse_y = glfw.get_cursor_pos(window)
            elif action == glfw.RELEASE:
                self.mouse_button_left = False
        elif button == glfw.MOUSE_BUTTON_RIGHT:
            if action == glfw.PRESS:
                self.mouse_button_right = True
                self.last_mouse_x, self.last_mouse_y = glfw.get_cursor_pos(window)
            elif action == glfw.RELEASE:
                self.mouse_button_right = False

    def _mouse_move_callback(self, window, xpos, ypos):
        """處理滑鼠移動事件，根據按下的按鍵來旋轉或平移視角。"""
        if not (self.mouse_button_left or self.mouse_button_right):
            return

        dx = xpos - self.last_mouse_x
        dy = ypos - self.last_mouse_y
        self.last_mouse_x = xpos
        self.last_mouse_y = ypos

        width, height = glfw.get_window_size(window)

        # 根據按下的按鍵決定操作類型
        action_type = None
        if self.mouse_button_right:
            action_type = mujoco.mjtMouse.mjMOUSE_MOVE_H # 平移
        elif self.mouse_button_left:
            action_type = mujoco.mjtMouse.mjMOUSE_ROTATE_H # 旋轉

        if action_type:
            mujoco.mjv_moveCamera(self.model, action_type, dx / height, dy / height, self.scene, self.cam)

    def _scroll_callback(self, window, xoffset, yoffset):
        """處理滑鼠滾輪事件，用於縮放視角。"""
        # yoffset > 0 表示向上滾動 (放大), yoffset < 0 表示向下滾動 (縮小)
        mujoco.mjv_moveCamera(self.model, mujoco.mjtMouse.mjMOUSE_ZOOM, 0, -0.05 * yoffset, self.scene, self.cam)
    # --- 新增結束 ---

    def register_callbacks(self, keyboard_handler: "KeyboardInputHandler"):
        """註冊所有來自鍵盤處理器的回調函式。"""
        keyboard_handler.register_callbacks(self.window)

    def reset(self):
        """重置 MuJoCo 模擬狀態到初始狀態。"""
        mujoco.mj_resetData(self.model, self.data)
        mujoco.mj_forward(self.model, self.data)
        print("✅ MuJoCo 模擬已重置。")

    def should_close(self) -> bool:
        """檢查視窗是否應該關閉。"""
        return glfw.window_should_close(self.window)
        
    def apply_control(self, ctrl_cmd: np.ndarray, params: TuningParams):
        """將控制指令和調校參數應用到 MuJoCo 模型。"""
        self.model.actuator_gainprm[:, 0] = params.kp
        self.model.dof_damping[6:] = params.kd
        self.model.actuator_biasprm[:, 1] = params.bias
        self.data.ctrl[:] = ctrl_cmd

    def step(self, state: SimulationState):
        """執行物理模擬，直到模擬時間趕上控制計時器。"""
        while self.data.time < state.control_timer:
            mujoco.mj_step(self.model, self.data)

    def render(self, state: SimulationState, overlay: "DebugOverlay"):
        """渲染當前場景和除錯資訊。"""
        # 僅在非序列埠模式下自動追蹤軀幹
        if state.control_mode != "SERIAL_MODE":
            # 如果滑鼠正在操作，則暫時停止自動追蹤，以提供更好的手動控制體驗
            if not (self.mouse_button_left or self.mouse_button_right):
                 self.cam.lookat = self.data.body('torso').xpos
        
        viewport = mujoco.MjrRect(0, 0, *glfw.get_framebuffer_size(self.window))
        
        if state.control_mode != "SERIAL_MODE":
            mujoco.mjv_updateScene(self.model, self.data, self.opt, None, self.cam, mujoco.mjtCatBit.mjCAT_ALL, self.scene)
            mujoco.mjr_render(viewport, self.scene, self.context)
        
        overlay.render(viewport, self.context, state, self)
        
        glfw.swap_buffers(self.window)
        glfw.poll_events()
        
    def close(self):
        """關閉視窗並終止 GLFW。"""
        glfw.terminate()

================================================================================
--- FILE: state.py ---
----------------------

# state.py
from __future__ import annotations
import numpy as np
from dataclasses import dataclass, field
from config import AppConfig
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from floating_controller import FloatingController

@dataclass
class TuningParams:
    """用於即時調整機器人控制參數的類別。"""
    kp: float
    kd: float
    action_scale: float
    bias: float

@dataclass
class SimulationState:
    """管理所有模擬中動態變化的狀態，取代 global 變數。"""
    config: AppConfig
    command: np.ndarray = field(default_factory=lambda: np.zeros(3, dtype=np.float32))
    tuning_params: TuningParams = field(init=False)
    
    # --- 重置旗標 ---
    hard_reset_requested: bool = False # R 鍵觸發的完全重置
    soft_reset_requested: bool = False # X 鍵觸發的空中姿態重置

    control_timer: float = 0.0
    
    # --- 模式狀態 ---
    sim_mode_text: str = "Initializing"
    input_mode: str = "KEYBOARD"
    control_mode: str = "WALKING"  # 可選值: "WALKING", "FLOATING", "SERIAL_MODE", "JOINT_TEST"

    # --- UI & 跨模組資料 ---
    latest_onnx_input: np.ndarray = field(default_factory=lambda: np.array([]))
    latest_action_raw: np.ndarray = field(default_factory=lambda: np.zeros(12))
    latest_final_ctrl: np.ndarray = field(default_factory=lambda: np.zeros(12))
    latest_pos: np.ndarray = field(default_factory=lambda: np.zeros(3))
    latest_quat: np.ndarray = field(default_factory=lambda: np.array([1., 0., 0., 0.]))
    display_page: int = 0
    num_display_pages: int = 2

    # --- 序列埠模式相關狀態 ---
    serial_command_buffer: str = ""
    serial_command_to_send: str = ""
    serial_latest_messages: list = field(default_factory=list)

    # --- 關節手動測試模式相關狀態 ---
    joint_test_index: int = 0
    joint_test_offsets: np.ndarray = field(default_factory=lambda: np.zeros(12))

    # --- 物件引用 ---
    floating_controller_ref: 'FloatingController' = None

    # --- 單步執行模式 ---
    single_step_mode: bool = False
    execute_one_step: bool = False

    def __post_init__(self):
        """在初始化後，根據設定檔設定初始值。"""
        self.tuning_params = TuningParams(
            kp=self.config.initial_tuning_params.kp,
            kd=self.config.initial_tuning_params.kd,
            action_scale=self.config.initial_tuning_params.action_scale,
            bias=self.config.initial_tuning_params.bias
        )
        self.latest_action_raw = np.zeros(self.config.num_motors)
        self.latest_final_ctrl = np.zeros(self.config.num_motors)
        print("✅ SimulationState 初始化完成。")

    def reset_control_state(self, sim_time: float):
        self.control_timer = sim_time
        # 注意：這裡不再重置 reset_requested 旗標，由主迴圈處理
        print("✅ 控制狀態已重置。")

    def clear_command(self):
        self.command.fill(0.0)
        print("運動指令已清除。")

    def toggle_input_mode(self, new_mode: str):
        if self.input_mode != new_mode:
            self.input_mode = new_mode
            self.clear_command()
            print(f"輸入模式已切換至: {self.input_mode}")
            
    def set_control_mode(self, new_mode: str):
        """切換主控制模式，並呼叫對應的啟用/禁用函式。"""
        if self.control_mode == new_mode: return

        if self.control_mode == "FLOATING":
            if self.floating_controller_ref and self.floating_controller_ref.is_functional:
                self.floating_controller_ref.disable()
        
        self.control_mode = new_mode
        print(f"控制模式已切換至: {self.control_mode}")

        if new_mode == "FLOATING":
            if self.floating_controller_ref and self.floating_controller_ref.is_functional:
                self.floating_controller_ref.enable(self.latest_pos)
        elif new_mode == "JOINT_TEST":
            self.joint_test_offsets.fill(0.0)

================================================================================
--- FILE: test_joystick.py ---
------------------------------

# test_joystick.py
import pygame
import time

pygame.init()
pygame.joystick.init()

if pygame.joystick.get_count() == 0:
    print("錯誤：未偵測到任何搖桿。")
    exit()

joystick = pygame.joystick.Joystick(0)
joystick.init()

print(f"已連接到: {joystick.get_name()}")
print(f"搖桿有 {joystick.get_numaxes()} 個軸。")
print("\n請移動您的搖桿，觀察每個軸的編號和數值變化...")
print("按 Ctrl+C 結束測試。")

try:
    while True:
        for event in pygame.event.get():
            if event.type == pygame.JOYAXISMOTION:
                print(f"軸 (Axis) {event.axis}: {event.value:.3f}")
        time.sleep(0.01)
except KeyboardInterrupt:
    print("\n測試結束。")

pygame.quit()

================================================================================
--- FILE: verify_model_mode.py ---
----------------------------------

# verify_model_mode.py
import numpy as np
import mujoco
import sys
import time
from pathlib import Path

# --- 導入您專案的模組 ---
from config import load_config
from policy import ONNXPolicy
from observation import ObservationBuilder # 我們將使用您修改後的版本

# --- 腳本設定 ---
SIMULATION_DURATION = 3.0
PERTURBATION_VALUE = 0.3
STABILITY_THRESHOLD = 0.05
HIP_JOINT_INDICES = [1, 4, 7, 10]

def run_simulation(model, data, policy, obs_builder, duration):
    """
    運行一個模擬片段並收集最後的 Raw Action 數據。
    這個版本假設是「絕對角度模式」。
    """
    # 在這個測試腳本中，我們直接使用一個固定的PD增益
    model.actuator_gainprm[:, 0] = 5.0
    model.dof_damping[6:] = 0.5
    
    start_time = data.time
    recent_actions = []

    # 簡單的熱身
    warmup_duration = 1.0
    while data.time - start_time < warmup_duration:
        base_obs = obs_builder.get_observation(np.zeros(3), policy.last_action)
        _, action_raw = policy.get_action(base_obs)
        # 【核心】使用絕對角度模式計算控制指令
        final_ctrl = action_raw * 1.0 # action_scale 設為 1.0
        data.ctrl[:] = final_ctrl
        mujoco.mj_step(model, data)

    # 真正開始收集數據
    collection_start_time = data.time
    while data.time - collection_start_time < (duration - warmup_duration):
        base_obs = obs_builder.get_observation(np.zeros(3), policy.last_action)
        _, action_raw = policy.get_action(base_obs)
        recent_actions.append(action_raw.copy())
        
        final_ctrl = action_raw * 1.0
        data.ctrl[:] = final_ctrl
        mujoco.mj_step(model, data)

    if not recent_actions:
        print("❌ 錯誤：未能收集到任何 action 數據。")
        return None
        
    return np.mean(recent_actions, axis=0)

def reset_to_key(model, data, key_id, perturbation=None):
    """
    手動將模擬重置到指定的 keyframe，並可選擇性地施加擾動。
    """
    mujoco.mj_resetData(model, data)
    qpos = model.key_qpos[key_id].copy()
    if perturbation is not None:
        qpos[7:] += perturbation
    data.qpos[:] = qpos
    data.qvel[:] = model.key_qvel[key_id]
    mujoco.mj_forward(model, data)


def verify():
    """執行驗證的主函式。"""
    print("=" * 60)
    print("🤖 模型輸出模式驗證工具 (絕對角度模式驗證版) 🤖")
    print("=" * 60)

    try:
        print("1. 載入設定與模型...")
        config = load_config()
        if not Path(config.mujoco_model_file).exists():
            print(f"❌ 錯誤：找不到模型檔案 '{config.mujoco_model_file}'")
            return

        model = mujoco.MjModel.from_xml_path(config.mujoco_model_file)
        data = mujoco.MjData(model)
        
        home_key_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_KEY, 'home')
        if home_key_id == -1:
            print("❌ 錯誤：在 XML 中找不到名為 'home' 的 keyframe。")
            return
        
        default_pose_from_key = model.key_qpos[home_key_id][7:].copy()
        
        # 確保使用與模型匹配的觀察配方 (假設為48維)
        obs_dim = 48
        if obs_dim not in config.observation_recipes:
            print(f"❌ 錯誤: config.yaml 中缺少維度為 {obs_dim} 的 observation_recipes。")
            return
        recipe = config.observation_recipes[obs_dim]
             
        # 【核心】我們在這裡實例化的 obs_builder 會使用您修改後的 absolute mode 版本
        obs_builder = ObservationBuilder(recipe, data, model, mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, 'torso'), default_pose_from_key, config)
        base_obs_dim = len(obs_builder.get_observation(np.zeros(3), np.zeros(config.num_motors)))
        
        policy_config = config
        policy_config.initial_tuning_params.action_scale = 1.0 # 測試時固定為1.0
        policy = ONNXPolicy(policy_config, base_obs_dim)
        print("✅ 資源載入成功！")
        print("-" * 60)

        # --- 實驗一：基準測試 (Baseline Test) ---
        print("2. 執行【實驗一：基準測試】")
        print("   - 從標準的 'home' 姿態開始。")
        
        reset_to_key(model, data, home_key_id)
        policy.reset()
        
        stable_action_base = run_simulation(model, data, policy, obs_builder, SIMULATION_DURATION)
        if stable_action_base is None: return

        hip_action_base = np.mean(stable_action_base[HIP_JOINT_INDICES])
        print(f"   📊 基準穩定後 Raw Action (髖關節平均值): {hip_action_base:.4f}")
        print("-" * 60)
        time.sleep(1)

        # --- 實驗二：擾動初始姿態測試 (Perturbation Test) ---
        print("3. 執行【實驗二：擾動測試】")
        print(f"   - 從一個被擾動過的初始姿態開始 (髖關節增加 {PERTURBATION_VALUE})。")
        
        perturbation_vector = np.zeros(12)
        perturbation_vector[HIP_JOINT_INDICES] = PERTURBATION_VALUE
        reset_to_key(model, data, home_key_id, perturbation=perturbation_vector)
        policy.reset()

        stable_action_perturbed = run_simulation(model, data, policy, obs_builder, SIMULATION_DURATION)
        if stable_action_perturbed is None: return
        
        hip_action_perturbed = np.mean(stable_action_perturbed[HIP_JOINT_INDICES])
        print(f"   📊 擾動穩定後 Raw Action (髖關節平均值): {hip_action_perturbed:.4f}")
        print("-" * 60)

        # --- 4. 分析與結論 ---
        print("4. 分析結果與結論...")
        
        # 在絕對角度模式下，兩個實驗的輸出應該幾乎相同
        diff = abs(hip_action_perturbed - hip_action_base)
        print(f"   - 兩個實驗的 Raw Action 穩定值之差: {diff:.4f}")
        print("-" * 60)

        if diff < STABILITY_THRESHOLD:
            print("✅ 【結論】驗證成功！模型的行為與【絕對角度模式 (Absolute-based)】的預期相符。")
            print("   無論從哪個初始姿態開始，模型都能收斂到幾乎相同的目標角度輸出。")
            print("   您在 main.py 和 observation.py 中的絕對角度模式修改是【正確的】。")
        else:
            print("❌ 【結論】驗證失敗！模型的行為與【絕對角度模式】的預期不符。")
            print("   模型的輸出會因為初始姿態的不同而產生巨大差異，這不符合絕對角度模型的特徵。")
            print("   這可能意味著模型實際上是「偏移量模式」，或者模型本身不夠穩定。")
            print("   建議與模型作者確認訓練時的觀察空間和動作空間定義。")
        
        print("=" * 60)

    except Exception as e:
        print(f"\n❌ 驗證過程中發生錯誤: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    verify()

================================================================================
--- FILE: xbox_controller.py ---
--------------------------------

# xbox_controller.py
import pygame

class XboxController:
    """
    一個使用 Pygame 函式庫來讀取 Xbox 搖桿輸入的類別。
    這個版本是非阻塞的，可以安全地在主迴圈中更新。
    """
    def __init__(self):
        """初始化 Pygame 並偵測搖桿。"""
        pygame.init() # 初始化所有 pygame 模組
        pygame.joystick.init() # 初始化搖桿模組

        self.joystick = None
        if pygame.joystick.get_count() > 0:
            self.joystick = pygame.joystick.Joystick(0) # 獲取第一個搖桿
            self.joystick.init() # 初始化該搖桿
            print(f"✅ Pygame 偵測到搖桿: {self.joystick.get_name()}")
        else:
            print("⚠️ Pygame 未偵測到任何搖桿。")
            
        self.deadzone = 0.15
        # 狀態字典的結構保持不變，以相容 xbox_input_handler.py
        self.state = {
            'left_analog_x': 0.0, 'left_analog_y': 0.0,
            'right_analog_x': 0.0, 'right_analog_y': 0.0,
            'dpad': (0, 0),
            'button_a': 0, 'button_b': 0, 'button_x': 0, 'button_y': 0,
            'button_l1': 0, 'button_r1': 0,
            'button_select': 0, 'button_start': 0,
        }

    def is_connected(self) -> bool:
        """檢查搖桿是否已成功初始化。"""
        return self.joystick is not None

    def update(self):
        """
        處理 Pygame 事件佇列，更新搖桿狀態。
        這個方法應該在主模擬迴圈中被頻繁呼叫。
        """
        if not self.is_connected():
            return
            
        for event in pygame.event.get(): # 處理所有待辦事件
            if event.type == pygame.JOYAXISMOTION:
                # 類比搖桿 (Axis)
                # Axis 0: 左搖桿 X (-1 to 1)
                # Axis 1: 左搖桿 Y (-1 to 1, 上為負)
                # Axis 4: 右搖桿 X (-1 to 1)
                # Axis 3: 右搖桿 Y (-1 to 1, 上為負)
                if event.axis == 0: self.state['left_analog_x'] = event.value
                elif event.axis == 1: self.state['left_analog_y'] = event.value
                elif event.axis == 2: self.state['right_analog_x'] = event.value
                elif event.axis == 3: self.state['right_analog_y'] = event.value

            elif event.type == pygame.JOYBUTTONDOWN:
                # 按鈕按下
                if event.button == 0: self.state['button_a'] = 1
                elif event.button == 1: self.state['button_b'] = 1
                elif event.button == 2: self.state['button_x'] = 1
                elif event.button == 3: self.state['button_y'] = 1
                elif event.button == 4: self.state['button_l1'] = 1
                elif event.button == 5: self.state['button_r1'] = 1
                elif event.button == 6: self.state['button_select'] = 1
                elif event.button == 7: self.state['button_start'] = 1

            elif event.type == pygame.JOYBUTTONUP:
                # 按鈕釋放
                if event.button == 0: self.state['button_a'] = 0
                elif event.button == 1: self.state['button_b'] = 0
                elif event.button == 2: self.state['button_x'] = 0
                elif event.button == 3: self.state['button_y'] = 0
                elif event.button == 4: self.state['button_l1'] = 0
                elif event.button == 5: self.state['button_r1'] = 0
                elif event.button == 6: self.state['button_select'] = 0
                elif event.button == 7: self.state['button_start'] = 0

            elif event.type == pygame.JOYHATMOTION:
                # D-Pad
                self.state['dpad'] = event.value

    def get_input(self) -> dict:
        """獲取當前搖桿狀態的淺拷貝，並應用死區。"""
        # 應用死區
        for axis in ['left_analog_x', 'left_analog_y', 'right_analog_x', 'right_analog_y']:
            if abs(self.state[axis]) < self.deadzone:
                self.state[axis] = 0.0
        return self.state.copy()

    def close(self):
        """關閉 Pygame。"""
        pygame.quit()

================================================================================
--- FILE: xbox_input_handler.py ---
-----------------------------------

# xbox_input_handler.py
from state import SimulationState
from xbox_controller import XboxController # 現在會導入 pygame 版本的控制器

class XboxInputHandler:
    """
    處理 Xbox 搖桿的輸入，並將其轉換為對 SimulationState 的更新。
    """
    def __init__(self, state: SimulationState):
        """初始化 XboxInputHandler。"""
        self.state = state
        self.config = state.config
        self.controller = XboxController()
        self.last_input_state = self.controller.get_input() if self.is_available() else {}
    
    def is_available(self) -> bool:
        """檢查搖桿是否已成功初始化並連接。"""
        return self.controller.is_connected()

    def update_state(self):
        """從搖桿讀取輸入並更新 SimulationState。"""
        if not self.is_available():
            if self.state.input_mode == "GAMEPAD":
                print("🎮 搖桿已斷開，自動切換回鍵盤模式。")
                self.state.toggle_input_mode("KEYBOARD")
            return

        # *** 關鍵修改：先處理事件，再讀取狀態 ***
        self.controller.update() 
        current_input = self.controller.get_input()
        
        # 後續的邏輯完全不變
        self.state.command[0] = current_input['left_analog_x'] * self.config.gamepad_sensitivity['vy']
        self.state.command[1] = current_input['left_analog_y'] * self.config.gamepad_sensitivity['vx'] * -1 # Y軸反向
        self.state.command[2] = current_input['right_analog_x'] * self.config.gamepad_sensitivity['wz']

        p_step, params = self.config.param_adjust_steps, self.state.tuning_params

        if current_input['button_select'] and not self.last_input_state.get('button_select', 0):
            self.state.reset_requested = True
            
        dpad_y = current_input['dpad'][1]
        last_dpad_y = self.last_input_state.get('dpad', (0,0))[1]
        if dpad_y == 1 and last_dpad_y != 1: params.kp += p_step['kp']
        if dpad_y == -1 and last_dpad_y != -1: params.kp -= p_step['kp']
        
        dpad_x = current_input['dpad'][0]
        last_dpad_x = self.last_input_state.get('dpad', (0,0))[0]
        if dpad_x == 1 and last_dpad_x != 1: params.kd += p_step['kd']
        if dpad_x == -1 and last_dpad_x != -1: params.kd -= p_step['kd']

        if current_input['button_r1'] and not self.last_input_state.get('button_r1', 0): params.action_scale += p_step['action_scale']
        if current_input['button_l1'] and not self.last_input_state.get('button_l1', 0): params.action_scale -= p_step['action_scale']
        if current_input['button_y'] and not self.last_input_state.get('button_y', 0): params.bias += p_step['bias']
        if current_input['button_a'] and not self.last_input_state.get('button_a', 0): params.bias -= p_step['bias']
        
        self.last_input_state = current_input
        
        params.kp = max(0, params.kp)
        params.kd = max(0, params.kd)
        params.action_scale = max(0, params.action_scale)

    def close(self):
        """關閉搖桿連接。"""
        if self.controller:
            self.controller.close()

================================================================================
--- FILE: assets/pupper.xml ---
-------------------------------

<!-- 
  Pupper Model - Final Corrected Version
-->
<mujoco model="pupper_env">
    <compiler angle="radian" autolimits="true"/>

    <option timestep="0.001" gravity="0 0 -9.81" 
            iterations="5" ls_iterations="10" noslip_iterations="2">
        <flag eulerdamp="disable"/>
    </option>

    <default>
        <default class="pupper">
            <joint armature="0.01" damping="0.5239" solimplimit="0.9 0.99 0.001" solreflimit="0.02 1"/>
            <geom type="mesh" contype="0" conaffinity="0" rgba="0.8 0.6 .4 1"/>
            <general biastype="affine" gainprm="35.0 0 0" biasprm="0 -35.0 0"/>
            <default class="pupper/collision/foot">
                <geom type="sphere" 
                      contype="1" conaffinity="1" 
                      group="3"
                      friction="1.0 0.2 0.1" 
                      solimp="0.9 0.99 0.001" 
                      solref="0.02 1"
                      rgba="1 0 0 1"/>
            </default>
        </default>
    </default>

    <asset>
        <mesh name="body" file="mesh/body.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Hip_L" file="mesh/Hip_L.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Hip_R" file="mesh/Hip_R.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Upper_Leg_L" file="mesh/Upper_Leg_L.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Upper_Leg_R" file="mesh/Upper_Leg_R.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Lower_Leg_L" file="mesh/Lower_Leg_L.stl" scale="0.001 0.001 0.001"/>
        <mesh name="Lower_Leg_R" file="mesh/Lower_Leg_R.stl" scale="0.001 0.001 0.001"/>
    </asset>

    <worldbody>
        <body name="torso" pos="0 0 0.2" childclass="pupper">
            <freejoint name="root"/>
            <camera name="track" pos="1.958 -2.348 0.591" xyaxes="0.768 0.641 0.000 -0.101 0.122 0.987" mode="trackcom"/>
            <inertial pos="0.00109 -0.074 0" mass="0.7833" diaginertia="0.0003688 0.002508 0.002674"/>
            <geom name="torso_geom" mesh="body"/>
            <site name="imu_frame" pos="0 0 0" size="0.01" type="sphere" rgba="1 0 0 0.5"/>

            <!-- ==================== Front-Right Leg ==================== -->
            <body name="leg_front_right" pos="-0.046891 -0.203946 -0.0064">
                <inertial pos="0 0 0" mass="0.1081" diaginertia="3.698e-05 7.127e-06 4.075e-05"/>
                <joint name="abduction_front_right" type="hinge" axis="0 1 0" pos="0 0 0" range="-1.0472 1.0472"/>
                <geom name="fr_block_geom" mesh="Hip_R"/>
                <body name="upper_leg_front_right" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
                    <inertial pos="0 0 0" mass="0.1321" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                    <joint name="hip_front_right" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.76166 3.81442"/>
                    <geom name="fr_geom" mesh="Upper_Leg_R"/>
                    <body name="lower_leg_front_right" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
                        <inertial pos="0 0 0" mass="0.1036" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                        <joint name="knee_front_right" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.78540 1.65806"/>
                        <geom name="fr_l2_geom" mesh="Lower_Leg_R"/>
                        
                        <!-- FINAL FIX: 將 site 的名字改回 "foot_front_right"，以匹配 Python 環境的需求。-->
                        <site name="foot_front_right" pos="0.003475 0 -0.11" size="0.009525" type="sphere" rgba="0 1 0 0.5"/>
                        <geom name="foot_front_right_collision" class="pupper/collision/foot" 
                              pos="0.003475 0 -0.11" size="0.009525"/>
                    </body>
                </body>
            </body>
            
            <!-- ==================== Front-Left Leg ==================== -->
            <body name="leg_front_left" pos="0.047109 -0.203946 -0.0064">
                <inertial pos="0 0 0" mass="0.1081" diaginertia="3.698e-05 7.127e-06 4.075e-05"/>
                <joint name="abduction_front_left" type="hinge" axis="0 1 0" pos="0 0 0" range="-1.0472 1.0472"/>
                <geom name="fl_block_geom" mesh="Hip_L"/>
                <body name="upper_leg_front_left" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
                    <inertial pos="0 0 0" mass="0.1321" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                    <joint name="hip_front_left" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.76166 3.81442"/>
                    <geom name="fl_geom" mesh="Upper_Leg_L"/>
                    <body name="lower_leg_front_left" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
                        <inertial pos="0 0 0" mass="0.1036" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                        <joint name="knee_front_left" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.78540 1.65806"/>
                        <geom name="fl_l2_geom" mesh="Lower_Leg_L"/>
                        <site name="foot_front_left" pos="-0.003475 0 -0.11" size="0.009525" type="sphere" rgba="0 1 0 0.5"/>
                        <geom name="foot_front_left_collision" class="pupper/collision/foot" 
                              pos="-0.003475 0 -0.11" size="0.009525"/>
                    </body>
                </body>
            </body>
            
            <!-- ==================== Hind-Right Leg ==================== -->
            <body name="leg_hind_right" pos="-0.046896 -0.004096 -0.0064">
                <inertial pos="0 0 0" mass="0.1081" diaginertia="3.698e-05 7.127e-06 4.075e-05"/>
                <joint name="abduction_hind_right" type="hinge" axis="0 1 0" pos="0 0 0" range="-1.0472 1.0472"/>
                <geom name="br_block_geom" mesh="Hip_R"/>
                <body name="upper_leg_hind_right" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
                    <inertial pos="0 0 0" mass="0.1321" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                    <joint name="hip_hind_right" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.76166 3.81442"/>
                    <geom name="br_geom" mesh="Upper_Leg_R"/>
                    <body name="lower_leg_hind_right" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
                        <inertial pos="0 0 0" mass="0.1036" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                        <joint name="knee_hind_right" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.78540 1.65806"/>
                        <geom name="br_l2_geom" mesh="Lower_Leg_R"/>
                        <site name="foot_hind_right" pos="0.003475 0 -0.11" size="0.009525" type="sphere" rgba="0 1 0 0.5"/>
                        <geom name="foot_hind_right_collision" class="pupper/collision/foot" 
                              pos="0.003475 0 -0.11" size="0.009525"/>
                    </body>
                </body>
            </body>
            
            <!-- ==================== Hind-Left Leg ==================== -->
            <body name="leg_hind_left" pos="0.047104 -0.004096 -0.0064">
                <inertial pos="0 0 0" mass="0.1081" diaginertia="3.698e-05 7.127e-06 4.075e-05"/>
                <joint name="abduction_hind_left" type="hinge" axis="0 1 0" pos="0 0 0" range="-1.0472 1.0472"/>
                <geom name="bl_block_geom" mesh="Hip_L"/>
                <body name="upper_leg_hind_left" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
                    <inertial pos="0 0 0" mass="0.1321" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                    <joint name="hip_hind_left" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.76166 3.81442"/>
                    <geom name="bl_geom" mesh="Upper_Leg_L"/>
                    <body name="lower_leg_hind_left" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
                        <inertial pos="0 0 0" mass="0.1036" diaginertia="0.0002253 6.493e-05 0.0002502"/>
                        <joint name="knee_hind_left" type="hinge" axis="1 0 0" pos="0 0 0" range="-0.78540 1.65806"/>
                        <geom name="bl_l2_geom" mesh="Lower_Leg_L"/>
                        <site name="foot_hind_left" pos="-0.003475 0 -0.11" size="0.009525" type="sphere" rgba="0 1 0 0.5"/>
                        <geom name="foot_hind_left_collision" class="pupper/collision/foot" 
                              pos="-0.003475 0 -0.11" size="0.009525"/>
                    </body>
                </body>
            </body>
        </body>
    </worldbody>

    <actuator>
        <general class="pupper" joint="abduction_front_right"/>
        <general class="pupper" joint="hip_front_right"/>
        <general class="pupper" joint="knee_front_right"/>
        <general class="pupper" joint="abduction_front_left"/>
        <general class="pupper" joint="hip_front_left"/>
        <general class="pupper" joint="knee_front_left"/>
        <general class="pupper" joint="abduction_hind_right"/>
        <general class="pupper" joint="hip_hind_right"/>
        <general class="pupper" joint="knee_hind_right"/>
        <general class="pupper" joint="abduction_hind_left"/>
        <general class="pupper" joint="hip_hind_left"/>
        <general class="pupper" joint="knee_hind_left"/>
    </actuator>
    
    <sensor>
        <!-- Sensor section remains unchanged -->
    </sensor>

    <keyframe>
        <key name="home"
            qpos="0 0 0.2 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0"
            ctrl="0 0 0 0 0 0 0 0 0 0 0 0" />
    </keyframe>
</mujoco>

================================================================================
--- FILE: assets/pupper_mjx.xml ---
-----------------------------------

<mujoco model="pupper">
  <!-- 
    ============================================================
    ===               FINAL PATH CORRECTION                  ===
    ============================================================
    - meshdir: 設為 "mesh"。
      這表示網格檔案位於與此 XML 檔案(pupper_mjx.xml)同級的 "mesh" 資料夾中。
      由於 pupper_mjx.xml 在 assets/ 下，所以 MuJoCo 會去尋找 assets/mesh/，
      這正是我們想要的，且不會有多餘的路徑疊加。
  -->
  <compiler angle="radian" meshdir="mesh" autolimits="true"/>

  <option iterations="1" ls_iterations="5" timestep="0.004" integrator="Euler">
    <flag eulerdamp="disable"/>
  </option>

  <custom>
    <numeric data="30" name="max_contact_points"/>
    <numeric data="12" name="max_geom_pairs"/>
  </custom>

  <!-- 預設值設定 -->
  <default>
    <default class="pupper">
      <joint armature="0.01" damping="0.0045"/>
      <position forcerange="-1.7 1.7" inheritrange="1" kp="4" />
      <general biastype="none" />
      <default class="abduction"><joint axis="0 1 0" range="-1.0472 1.0472" frictionloss="0.28"/></default>
      <default class="hip"><joint axis="1 0 0" range="-0.76166 3.81442" frictionloss="0.28"/></default>
      <default class="knee"><joint axis="1 0 0" range="-0.78540 1.65806" frictionloss="0.28"/></default>
      <default class="visual"><geom type="mesh" contype="0" conaffinity="0" group="2"/></default>
      <default class="collision">
        <geom group="3"/>
        <default class="foot"><geom type="sphere" size="0.009525" solimp="0.9 .95 0.01" condim="3" friction="0.8 0.1 0.1"/></default>
      </default>
    </default>
  </default>

  <!-- 
    資產定義 (file 屬性保持不變，只留檔案名稱)
  -->
  <asset>
    <mesh name="body" file="body.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Hip_L" file="Hip_L.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Hip_R" file="Hip_R.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Upper_Leg_L" file="Upper_Leg_L.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Upper_Leg_R" file="Upper_Leg_R.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Lower_Leg_L" file="Lower_Leg_L.stl" scale="0.001 0.001 0.001"/>
    <mesh name="Lower_Leg_R" file="Lower_Leg_R.stl" scale="0.001 0.001 0.001"/>
  </asset>

  <!-- worldbody, actuator, sensor 區塊完全保持不變 -->
  <worldbody>
    <light name="spotlight" mode="targetbodycom" target="torso" pos="3 0 4"/>
    <body name="torso" pos="0 0 0.2" childclass="pupper">
      <camera name="track" pos="0.8 -1.0 0.5" xyaxes="0.707 0.707 0 -0.354 0.354 0.866" mode="trackcom"/>
      <site name="head" pos="0.15 0 0" rgba="1 0 0 1" size="0.02" group="5"/>
      <inertial pos="0.00109 -0.074 0" mass="0.7833" diaginertia="0.0003688 0.002508 0.002674"/>
      <freejoint/>
      <geom class="visual" mesh="body"/>
      <geom class="collision" type="box" size="0.06 0.11 0.03" pos="0 -0.07 0"/>
      <site name="imu" pos="0 -0.122542 0" size="0.01" group="5"/>
      <!-- FR Leg -->
      <body name="FR_hip" pos="-0.046891 -0.203946 -0.0064">
        <joint class="abduction" name="FR_hip_joint"/>
        <geom class="visual" mesh="Hip_R"/>
        <body name="FR_thigh" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
          <joint class="hip" name="FR_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_R"/>
          <body name="FR_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <joint class="knee" name="FR_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_R"/>
            <geom name="FR" class="foot" pos="0.003475 0 -0.11"/>
            <site name="FR" pos="0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
      <!-- FL Leg -->
      <body name="FL_hip" pos="0.047109 -0.203946 -0.0064">
        <joint class="abduction" name="FL_hip_joint"/>
        <geom class="visual" mesh="Hip_L"/>
        <body name="FL_thigh" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
          <joint class="hip" name="FL_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_L"/>
          <body name="FL_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <joint class="knee" name="FL_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_L"/>
            <geom name="FL" class="foot" pos="-0.003475 0 -0.11"/>
            <site name="FL" pos="-0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
      <!-- RR Leg -->
      <body name="RR_hip" pos="-0.046896 -0.004096 -0.0064">
        <joint class="abduction" name="RR_hip_joint"/>
        <geom class="visual" mesh="Hip_R"/>
        <body name="RR_thigh" pos="-0.037 0.028 0" axisangle="1 0 0 0.7854">
          <joint class="hip" name="RR_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_R"/>
          <body name="RR_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <joint class="knee" name="RR_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_R"/>
            <geom name="RR" class="foot" pos="0.003475 0 -0.11"/>
            <site name="RR" pos="0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
      <!-- RL Leg -->
      <body name="RL_hip" pos="0.047104 -0.004096 -0.0064">
        <joint class="abduction" name="RL_hip_joint"/>
        <geom class="visual" mesh="Hip_L"/>
        <body name="RL_thigh" pos="0.037 0.028 0" axisangle="1 0 0 0.7854">
          <joint class="hip" name="RL_thigh_joint"/>
          <geom class="visual" mesh="Upper_Leg_L"/>
          <body name="RL_calf" pos="0 0 -0.08" axisangle="1 0 0 -1.57">
            <joint class="knee" name="RL_calf_joint"/>
            <geom class="visual" mesh="Lower_Leg_L"/>
            <geom name="RL" class="foot" pos="-0.003475 0 -0.11"/>
            <site name="RL" pos="-0.003475 0 -0.11" type="sphere" size="0.009525" group="5"/>
          </body>
        </body>
      </body>
    </body>
  </worldbody>

  <actuator>
    <position class="abduction" name="FR_hip" joint="FR_hip_joint"/>
    <position class="hip" name="FR_thigh" joint="FR_thigh_joint"/>
    <position class="knee" name="FR_calf" joint="FR_calf_joint"/>
    <position class="abduction" name="FL_hip" joint="FL_hip_joint"/>
    <position class="hip" name="FL_thigh" joint="FL_thigh_joint"/>
    <position class="knee" name="FL_calf" joint="FL_calf_joint"/>
    <position class="abduction" name="RR_hip" joint="RR_hip_joint"/>
    <position class="hip" name="RR_thigh" joint="RR_thigh_joint"/>
    <position class="knee" name="RR_calf" joint="RR_calf_joint"/>
    <position class="abduction" name="RL_hip" joint="RL_hip_joint"/>
    <position class="hip" name="RL_thigh" joint="RL_thigh_joint"/>
    <position class="knee" name="RL_calf" joint="RL_calf_joint"/>
  </actuator>

  <sensor>
    <gyro site="imu" name="gyro"/>
    <velocimeter site="imu" name="local_linvel"/>
    <accelerometer site="imu" name="accelerometer"/>
  </sensor>
</mujoco>

================================================================================
--- FILE: assets/scene.xml ---
------------------------------

<mujoco model="pupper scene">
  <!-- 包含機器人模型 -->
  <include file="pupper.xml"/>

  <statistic center="0 0 0.1" extent="0.8"/>

  <visual>
    <headlight diffuse="0.6 0.6 0.6" ambient="0.3 0.3 0.3" specular="0 0 0"/>
    <rgba haze="0.15 0.25 0.35 1"/>
    <global azimuth="120" elevation="-20"/>
  </visual>

  <asset>
    <texture type="skybox" builtin="gradient" rgb1="0.3 0.5 0.7" rgb2="0 0 0" width="512" height="3072"/>
    <texture type="2d" name="groundplane" builtin="checker" mark="edge" rgb1="0.2 0.3 0.4" rgb2="0.1 0.2 0.3"
      markrgb="0.8 0.8 0.8" width="300" height="300"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance="0.2"/>
  </asset>

  <worldbody>
    <light pos="0 0 1.5" dir="0 0 -1" directional="true"/>
    <camera name="default" pos="0.846 -1.465 0.916" xyaxes="0.866 0.500 0.000 -0.171 0.296 0.940"/>
    <geom name="floor" size="0 0 0.05" type="plane" material="groundplane"/>
    
  <keyframe>
    <!-- 為Pupper定義一個'home'站立姿態 -->
    <!-- qpos: [root_pos(3), root_quat(4), FR(3), FL(3), RR(3), RL(3)] -->
    <!-- 原始Pupper模型的home: [0 0.4 -0.8] for each leg (abduction, hip, knee) -->
    <key name="home" qpos="
    0 0 0.2
    1 0 0 0
    0 0.0 0.0
    0 0.0 0.0
    0 0.0 0.0
    0 0.0 0.0"
      ctrl="0 0 0  0 0 0  0 0 0  0 0 0"/>
  </keyframe>


    <!-- =========================================================== -->
    <!-- === 新增部分 1：Mocap Body (我們的空中錨點) === -->
    <!-- mocap="true" 表示它的位置由我們手動設定 -->
    <!-- 將其放在 worldbody 的頂層 -->
    <body name="anchor" pos="0 0 0.35" mocap="true">
      <!-- 我們可以給它一個看不見的 geom 來視覺化它的位置，方便除錯 -->
      <geom type="sphere" size="0.02" rgba="1 0 0 0.5" contype="0" conaffinity="0"/>
    </body>
    <!-- =========================================================== -->

  </worldbody>

  <!-- ============================================================= -->
  <!-- === 新增部分 2：Weld 約束 === -->
  <!-- 將其放在 mujoco 標籤的頂層 -->
  <!-- 這個約束將 pupper.xml 中的 "torso" "焊接" 到我們上面定義的 "anchor" 上 -->
  <!-- active="false" 表示預設是禁用的 -->
  <equality>
    <weld name="torso_anchor_weld" body1="torso" body2="anchor" solimp="0.9 0.95 0.001" solref="0.02 1" active="false"/>
  </equality>
  <!-- ============================================================= -->

</mujoco>

================================================================================
--- FILE: assets/scene_mjx.xml ---
----------------------------------

<mujoco model="Pupper Scene MJX">
  <!-- 
    ============================================================
    ===               1. 包含機器人模型                      ===
    ============================================================
    使用 <include> 標籤將外部的機器人定義檔案載入到當前場景。
    這使得場景和機器人的定義可以分開管理，非常方便。
  -->
  <include file="pupper_mjx.xml"/>

  <!-- 
    ============================================================
    ===               2. 全局設定 (Visual & Statistic)       ===
    ============================================================
  -->
  <statistic center="0 0 0.1" extent="0.8" meansize="0.04"/>

  <visual>
    <!-- 燈光設定 -->
    <headlight diffuse=".8 .8 .8" ambient=".2 .2 .2" specular="1 1 1"/>
    <!-- 全局攝影機視角 -->
    <global azimuth="120" elevation="-20"/>
    <!-- 渲染品質 -->
    <quality shadowsize="4096"/> <!-- 陰影貼圖大小，4096 是個不錯的品質與效能平衡點 -->
  </visual>

  <!-- 
    ============================================================
    ===               3. 資產定義 (Asset)                      ===
    ============================================================
    定義場景中使用的材質、貼圖等。
  -->
  <asset>
    <!-- 優化點: 將天空和地板的顏色改為非純白，以提供更好的視覺對比 -->
    <texture type="skybox" builtin="gradient" rgb1=".6 .7 .8" rgb2=".2 .3 .4" width="800" height="800"/>
    <texture type="2d" name="groundplane" builtin="checker" mark="edge" rgb1=".2 .3 .4" rgb2=".1 .2 .3" markrgb=".8 .8 .8"
      width="300" height="300"/>
    <material name="groundplane" texture="groundplane" texuniform="true" texrepeat="5 5" reflectance="0"/>
  </asset>

  <!-- 
    ============================================================
    ===               4. 世界物體 (World Body)                 ===
    ============================================================
    定義場景中的靜態物體，例如地板。
  -->
  <worldbody>
    <geom name="floor" size="0 0 0.05" type="plane" material="groundplane" condim="3" contype="1" conaffinity="0"/>
    
    <!-- 
      Mocap Body: 一個特殊的物體，其位置不受物理模擬影響，
      而是由外部設定。我們用它作為一個固定的"空中錨點"。
    -->
    <body name="anchor" pos="0 0 0.35" mocap="true">
      <geom type="sphere" size="0.02" rgba="1 0 0 0.5" contype="0" conaffinity="0"/>
    </body>
  </worldbody>

  <!-- 
    ============================================================
    ===               5. 約束 (Equality Constraint)          ===
    ============================================================
    定義物體之間的約束關係。
  -->
  <equality>
    <!--
      Weld 約束: 將機器人的 torso 和空中的 anchor "焊接" 在一起。
      - active="false": 這個約束預設是關閉的。
      - 用途: 我們可以在程式中動態地開啟這個約束，將機器人固定在空中，
               方便觀察動作或進行除錯，而不用擔心它會倒下。
    -->
    <weld name="torso_anchor_weld" body1="torso" body2="anchor" solimp="0.9 0.95 0.001" solref="0.02 1" active="false"/>
  </equality>
  
  <!-- 
    ============================================================
    ===               6. 關鍵幀 (Keyframe)                     ===
    ============================================================
    儲存特定的模型狀態 (qpos, ctrl 等)，方便重置到指定姿態。
  -->
  <keyframe>
    <!--
      'home' 關鍵幀: 定義了機器人的初始姿態。
      - qpos: [根關節位置(3), 根關節姿態(4), 12個關節的角度]
      - 優化點: 提供了一個稍微蹲伏的姿態，比完全伸直的腿更實用。
        這個姿態是 (abduction=0.0, hip=0.8, knee=-1.6)
    -->
    <!--
    <key name="home" qpos="
    0 0 0.3
    1 0 0 0
    0.0  0.8 -1.6
    0.0  0.8 -1.6
    0.0  0.8 -1.6
    0.0  0.8 -1.6"/>-->

    <key name="home" qpos="
    0 0 0.3
    1 0 0 0 
    0.0  0.0  0.0  
    0.0  0.0  0.0  
    0.0  0.0  0.0  
    0.0  0.0  0.0 "/>
    
  </keyframe>
</mujoco>

